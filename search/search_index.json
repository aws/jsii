{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>jsii</code> allows code in any language to naturally interact with JavaScript classes. It is the technology that enables the AWS Cloud Development Kit to deliver polyglot libraries from a single codebase!</p> <p>A class library written in TypeScript can be used in projects authored in TypeScript or Javascript (as usual), but also in C# (and other languages from the .NET family), Go, Java, Python, ... More languages will be added in the future!</p> <p>Warning</p> <p>Due to JSON marshaling costs and the absence of a distributed garbage collector feature, <code>jsii</code> modules are best suited for development and build tools, as opposed to performance-sensitive or resource-constrained applications.</p> <p>See Runtime Architecture for more information.</p>"},{"location":"#an-example-is-worth-a-thousand-words","title":"An example is worth a thousand words","text":"<p>Consider the following TypeScript class:</p> <pre><code>/**\n * A simple greeter, hello world style.\n */\nexport class Greeter {\n/**\n   * Greets the designated person.\n   *\n   * @param name the person to greet.\n   *\n   * @returns a greeting.\n   */\npublic greet(name: string) {\nreturn `Hello, ${name}!`;\n}\n}\n</code></pre> <p>By compiling our source module using <code>jsii</code>, we can now package it as modules in one of the supported target languages. Each target module has the exact same API as the source. This allows users of that target language to use <code>Greeter</code> like any other native type:</p> C# <pre><code>var greeter = new Greeter();\ngreeter.Greet(\"World\"); // =&gt; Hello, World!\n</code></pre> Go <pre><code>greeter := NewGreeter()\ngreeter.Greet(\"World\") // =&gt; Hello, World!\n</code></pre> Java <pre><code>final Greeter greeter = new Greeter();\ngreeter.greet(\"World\"); // =&gt; Hello, World!\n</code></pre> JavaScript <pre><code>const greeter = new Greeter();\ngreeter.greet(\"World\"); // =&gt; Hello, World!\n</code></pre> Python <pre><code>greeter = Greeter()\ngreeter.greet(\"World\") # =&gt; Hello, World!\n</code></pre>"},{"location":"#how-to-use-this-website","title":"How to use this website","text":"<p>The documentation in this website is separated in different topics, which can be navigated using links in the site's header bar:</p> <ul> <li>The Welcome section provides a high level overview of jsii.</li> <li> <p>The User Guides section includes the following:</p> <ul> <li>The Library Author Guide is intended for developers who are looking to author libraries   using jsii to enable polyglot support for their work.</li> <li>The Library Consumer Guide is intended for developers who are consuming libraries   generated by jsii in the various supported target languages.</li> <li>The Language Implementation is intended for developers who are looking to add   support for a new target language in jsii.</li> </ul> </li> <li> <p>The Specification provides detailed information on the internal components of jsii.</p> </li> <li>The Architecture Decision Records contains the log of all architectural decisions made while developing the   jsii project.</li> </ul>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<p>The jsii project welcomes all kind of contributions. You can refer to the Contribution Guide on GitHub to get more information about how to contribute to the project in general.</p> <p>Tip</p> <p>You can submit pull requests for documentation updates without leaving the comfort of your web browser!</p> <p>All pages of this website have a  icon on the top right of each page that links to a GitHub web editor for the source of the page in question.</p>"},{"location":"decisions/_README/","title":"Format","text":"<p>So you want to add a new Architecture Decision Record to this section. This document highlights how to proceed in order to achieve a consistent look and feel, and that we capture sufficient information.</p>"},{"location":"decisions/_README/#create-a-new-document","title":"Create a new document","text":"<p>Each ADR document should be named using the following format: <code>YYYY-MM-DD-short-name.md</code>. This allows ensuring the documents are rendered in the correct order on the website. If is recommended to prefix the file name with the date at which the decision has been made, in ISO-8601 format.</p>"},{"location":"decisions/_README/#template","title":"Template","text":"<p>The following template is to be used: https://github.com/joelparkerhenderson/architecture_decision_record/blob/master/adr_template_madr.md</p>"},{"location":"decisions/introduction/","title":"Introduction","text":"<p>This section of the jsii reference is a log of all Architectural Decisions taken during the development of the jsii project. The Records are presented in reverse-chronological order (most recent decisions are listed first).</p>"},{"location":"overview/features/","title":"Features","text":""},{"location":"overview/features/#typescript-support","title":"TypeScript Support","text":"<p>The <code>jsii</code> compiler leverages the original TypeScript compiler API to compile TypeScript source files and produce JavaScript output and TypeScript declaration files, while also extracting the compiled module's API signatures in a jsii assembly file.</p> <p>To determine the version of TypeScript that is in use by the installed release of <code>jsii</code>, simply look at the <code>jsii --version</code> output:</p> <pre><code># jsii --version\n1.15.0 (build 585166b), typescript 3.9.7\n</code></pre> <p>You can then refer to the TypeScript documentation to determine which language features are available in that specific TypeScript release.</p> <p>Warning</p> <p>The <code>jsii</code> compiler imposes some restrictions on what TypeScript features can be used to declare the APIs exported by a jsii module, in order to ensure those APIs can be consistently represented in other languages. For more information, refer to the TypeScript Restrictions page.</p>"},{"location":"overview/features/#target-languages","title":"Target Languages","text":"<p>The following target languages are currently offered by <code>jsii-pacmak</code>, or are currently being developed:</p> Language Status C#  Generally Available Go  Generally Available Java  Generally Available JavaScript  Generally Available Kotlin         Development Python  Generally Available TypeScript  Generally Available Status Definitions <ul> <li> Generally Available languages are fully supported. The generated APIs will not   change in breaking ways across minor and patch releases.</li> <li> Developer Preview languages are experimental. The generated APIs may change in breaking   ways across minor releases.</li> <li> Development languages are not yet ready for consumption. They are actively developed and   may still lack certain essential features.</li> </ul>"},{"location":"overview/runtime-architecture/","title":"Runtime Architecture","text":""},{"location":"overview/runtime-architecture/#generated-libraries","title":"Generated Libraries","text":"<p>When using <code>jsii-pacmak</code> to generate libraries in different programming languages, the Javascript code is bundled within the generated library, so that it can be used at runtime. This is the reason why a <code>node</code> runtime needs to be available in order to execute code that depends on jsii libraries.</p> <p>The generated libraries have a dependency on a Runtime client library for the language, which contains the necessary logic to start a child <code>node</code> process with the <code>jsii-runtime</code>. The <code>jsii-runtime</code> manages JSON-based inter-process communication over its <code>STDIN</code>, <code>STDOUT</code> and <code>STDERR</code>, and manages a <code>@jsii/kernel</code> instance that acts as a container for the Javascript code that backs the jsii libraries.</p>"},{"location":"overview/runtime-architecture/#architecture-overview","title":"Architecture Overview","text":"<p>A representation of the execution environment of an application using jsii libraries from a different language follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502                         \u2502               \u2502            \u2502    \u2502    \u2502    \u2502\n\u2502    Host Application     \u2502               \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502\n\u2502                         \u2502               \u2502            \u2502    \u2502    \u2502    \u2502\n\u2502      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524\n\u2502      \u2502                  \u2502               \u2502                           \u2502\n\u2502      \u2502Generated Bindings\u2502               \u2502       @jsii/runtime       \u2502\n\u2502      \u2502                  \u2502               \u2502                           \u2502\n\u2502      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   Requests    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      \u2502                  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502                    \u2502\n\u2502      \u2502Host jsii Runtime \u2502   Responses   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524                    \u2502\n\u2502      \u2502     Library      \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502                    \u2502\n\u2502      \u2502                  \u2502    Console    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524    node            \u2502\n\u2502      \u2502                  \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n\u2502      Host Runtime       \u2502               \u2502      (Child Process)      \u2502\n\u2502  (JVM, .NET Core, ...)  \u2502               \u2502                           \u2502\n\u2502                         \u2502               \u2502                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502                          Operating System                           \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"overview/runtime-architecture/#communication-protocol","title":"Communication Protocol","text":"<p>As shown in the architecture overview diagram, the <code>@jsii/runtime</code> process receives requests via its <code>STDIN</code> stream, sends responses via its <code>STDOUT</code> stream, and sends console output through the <code>STDERR</code> stream.</p> <p>All those messages are sent in JSON-encoded objects. On <code>STDIN</code> and <code>STDOUT</code>, the request-response protocol is defined by the kernel api specification. On <code>STDERR</code> messages are encoded in the following way:</p> <ul> <li><code>{ \"stderr\": \"&lt;base64-encoded data&gt;\" }</code> when the console data is to be   written on the Host Application's <code>STDERR</code> stream.</li> <li><code>{ \"stdout\": \"&lt;base64-encoded data&gt;\" }</code> when the console data is to be   written on the Host Application's <code>STDOUT</code> stream.</li> <li>Any data that is not valid JSON, or that does not match either of the formats   described above must be written as-is on the Host Application's <code>STDERR</code>   stream.</li> </ul> <p>In order to allow the hosted original JavaScript libraries to naturally interact with <code>process.stdout</code>, <code>process.stderr</code> and all other APIs that make use of those streams (such as <code>console.log</code> and <code>console.error</code>), the <code>@jsii/runtime</code> process does in fact spawn a second <code>node</code> process to allow intercepting the console data to properly encode it. Below is a diagram describing the process arrangement that achieves this:</p> <pre><code>                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n                                          \u2502            \u2502    \u2502    \u2502    \u2502\n                                          \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502\n                                          \u2502            \u2502    \u2502    \u2502    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524\n\u2502                         \u2502               \u2502                           \u2502\n\u2502  @jsii/runtime Wrapper  \u2502               \u2502    @jsii/runtime Core     \u2502\n\u2502                         \u2502               \u2502                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502STDIN \u2502                  \u2502        X\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502    Console    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524                    \u2502\n\u2502STDOUT\u2502                  \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u2502    Console    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524        node        \u2502\n\u2502STDERR\u2502   node           \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502     JSON      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524  (Child Process)   \u2502\n\u2502                         \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 FD#3 \u2502                    \u2502\n\u2502                         \u2502               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n\u2502                         \u2502               \u2502                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502                          Operating System                           \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Missing Feature</p> <p>As shown on the diagram above, there is nothing connected to the Core process' <code>FD#0</code> (<code>STDIN</code>). This feature will be added in the future, but currently this means jsii libraries have no way of accepting input through <code>STDIN</code>.</p> <p>The Wrapper process manages the Core process such that:</p> <p>Info</p> <p>It would be possible to use a single <code>node</code> process (the <code>@jsii/runtime</code> Core process) for any platform that supposed spawning child processes with additional open file descriptors. This is for example not possible in Java and C#, which is why this dual-process contraption was devised.</p> <p>In such cases, the Host Application would spawn the Core process and directly operate on the file descriptors as described below.</p> <ul> <li>Any requests received from the Host Application through the Wrapper's   <code>STDIN</code> stream is forwarded to the Core process' <code>FD#3</code>.</li> <li>Any response written to the Core's <code>FD#3</code> stream is forwarded to the Host   Application though the Wrapper's <code>STDOUT</code>.</li> <li>Any data sent to the Core's <code>STDERR</code> is base64-encoded and wrapped in a JSON   object with the <code>\"stderr\"</code> key, then forwarded to the Host   Application through the Wrapper's <code>STDERR</code></li> <li>Any data sent to the Core's <code>STDOUT</code> is base64-encoded and wrapped in a JSON   object with the <code>\"stdout\"</code> key, then forwarded to the Host   Application through the Wrapper's <code>STDERR</code></li> </ul> <p>Danger</p> <p>As with any file descriptor besides <code>FD#0</code> (<code>STDIN</code>), <code>FD#1</code> (<code>STDOUT</code>) and <code>FD#2</code> (<code>STDERR</code>) that was not opened by the application, JavaScript libraries loaded in the <code>@jsii/kernel</code> instance are not allowed to interact directly with file descriptor <code>FD#3</code>.</p>"},{"location":"overview/runtime-architecture/#initialization-process","title":"Initialization Process","text":"<p>The initialization workflow can be described as:</p> <ol> <li>The host (Java, .NET, ...) application starts on its own runtime     (JVM, .NET Runtime, ...)</li> <li>When the host code encounters a jsii entity for the first time (creating     an instance of a jsii type, loading a static constant, ...), the runtime     client library creates a child <code>node</code> process, and loads the <code>jsii-runtime</code>     library (specified by the <code>JSII_RUNTIME</code> environment variable, or the     version that is bundled in the runtime client library)</li> <li>The runtime client library  interacts with the child <code>node</code> process by     exchanging JSON-encoded messages through the <code>node</code> process' STDIN and     <code>STDOUT</code>. It maintains a thread (or equivalent) that decodes messages from     the child's <code>STDERR</code> stream, and forwards the decoded data to it's host     process' <code>STDERR</code> and <code>STDOUT</code> as needed.</li> <li>The runtime client library automatically loads the Javascript modules     bundled within the generated bindings (and their depedencies, bundled in     other generated bindings) into the <code>node</code> process when needed.</li> <li>Calls into the Generated bindings are encoded into JSON requests and sent     to the child <code>node</code> process, which will execute the corresponding     Javascript code, then responds back.</li> <li>Upon exiting, the host process closes the communication channels with the     child <code>node</code> process, causing it to exit.</li> </ol>"},{"location":"overview/toolchain/","title":"Toolchain","text":"<p>jsii consists of multiple single-purposed programs which can be used to compose various workflows.</p> <p>Info</p> <p>We are considering creating an \"umbrella entrypoint\" to make it easier to consume.</p> Name Stability Description jsii Stable Compiles TypeScript to jsii module jsii-pacmak Stable Creates ready-to-publish language-specific packages from jsii modules jsii-reflect Stable Strong-typed reflection library for jsii type systems jsii-diff Stable API backwards compatibility checker jsii-rosetta Experimental Transpile code snippets (in docs) from TypeScript to jsii languages jsii-config Experimental Interactive tool for generating jsii configuration jsii-release Community Publishes jsii modules to all supported package managers jsii-srcmak Community Generates relocatable source code in jsii languages from typescript jsii-docgen Community Generates markdown API documentation for jsii modules Stability Definitions <ul> <li>Stable: Projects that comply with the Semantic Versioning specification, and will hence not change   behavior or receive other breaking changes across minor and patch version bumps.</li> <li>Experimental: Projects that are under active development and may change behavior or receive other breaking   changes across minor releases.</li> <li>Community: a community-maintained project, not officially supported by the jsii core team.</li> </ul>"},{"location":"specification/1-introduction/","title":"Introduction","text":"<p>This document provides a high level overview of jsii, starting with its design tenets. It introduces the concepts and components that compose jsii.</p>"},{"location":"specification/1-introduction/#updating-the-specification","title":"Updating the Specification","text":""},{"location":"specification/1-introduction/#introduction_1","title":"Introduction","text":"<p>The jsii specification follows the guiding principles of an RFC. It is a living document that describes the current understanding of how the various components of jsii are operating, as well as the approaches used to ensure consistent behavior across the various supported languages.</p> <p>The document is hosted with the jsii codebase, making it easy to determine what specification was in place at the time of a give jsii release (by ways of referring to the <code>vX.Y.Z</code> git tag). A single version of the specification is considered active at any given time: the version of the specification that is represented on the <code>HEAD</code> commit of the <code>main</code> branch of the <code>aws/jsii</code> repository. The active specification must be the base version for any update proposal.</p> <p>The process to update the specification is intended to be as lightweight as possible, while ensuring sufficient conversation takes place before implementing significant (and breaking) changes. Since the process to update the specification is part of the specification itself, it is amenable to be changed following the process described in the currently active specification.</p>"},{"location":"specification/1-introduction/#process","title":"Process","text":"<p>While the general process for updating the specification is to create a GitHub pull request against the <code>aws/jsii</code> repository, the exact requirements for what should be included in the pull request vary depending on the type of update that is proposed:</p> <ul> <li> Changing Behavior describes the process to be followed when introducing changes to the   behavior of any component of jsii: new features, breaking changes to existing features, ...</li> <li> Addressing Gaps is the process used for adding specification around existing but unspecified   behavior.</li> <li> Trivial Changes explains how to propose changes that improve the specification without changing   its meaning.</li> </ul>"},{"location":"specification/1-introduction/#changing-behavior","title":"Changing Behavior","text":"<p>If the change is not backwards compatible (it is a breaking change to an existing feature, or it is a new feature that requires all runtime libraries implement support immediately), a new RFC should be created in the <code>awslabs/aws-cdk-rfcs</code> repository, following the RFC Process. This ensures enough time is spent considering alternatives to breaking changes, and to create consensus that the change is desirable before time is spent implementing it.</p> <p>Note</p> <p>While going through the RFC process upfront is strongly recommended, contributors may choose not to file an RFC for a behavior change. In this case however, any core maintainer may decide that an RFC is required and block the contribution until the RFC process has been followed.</p> <p>It is worth noting that a draft pull request with proposed modifications to the specification (and possibly a proof-of-concept implementation), can be extremely useful.</p> <p>When the RFC is ready, a GitHub pull request is created that must contain:</p> <ul> <li>Relevant additions or modifications to the specification documents</li> <li>Relevant additions or modifications to the compliance suite</li> <li>Implementation of the new behavior, including new or updated tests in all the language bindings</li> </ul> <p>The pull request's body must reference the RFC if there has been one, and otherwise must include all discussion necessary to explain the reasoning behind the proposal (including alternatives considered, risks, ...).</p>"},{"location":"specification/1-introduction/#addressing-gaps","title":"Addressing Gaps","text":"<p>Proposals that increase the specification's coverage (desribing behavior that already exists) are handled as GitHub pull requests that must contain the following elements:</p> <ul> <li>Relevant additions to the specification documents</li> <li>New compliance test(s) that enshrine the described behavior</li> <li>Implementation of the new compliance test(s) for all Generally Available language bindings</li> </ul> <p>The pull request body should provide pointers to any and all elements that can be used to verify that the behavior that is described is indeed what is currently implemented.</p>"},{"location":"specification/1-introduction/#trivial-changes","title":"Trivial Changes","text":"<p>Proposal of trivial changes, such as correcting typos in the document, or re-phrasing elements of the specification without altering the meaning (typically to improve clarity) are handled in a simple GitHub pull request.</p>"},{"location":"specification/1-introduction/#design-tenets-unless-you-know-better-ones","title":"Design Tenets (unless you know better ones)","text":"<ul> <li>jsii APIs strive to feel idiomatic in all supported languages.</li> <li>jsii applications behave identically regardless of the language they are written in. It favors correctness over   performance.</li> <li>jsii does not attempt to support all TypeScript idioms (many features of TypeScript cannot be expressed in some   target languages).</li> <li>Unsupported idioms will cause a compile-time error to be emitted.</li> <li>When prohibiting an idiom, jsii strives to provide an error message that gives the user insight into why the     pattern cannot be supported.</li> <li>jsii does not force API design opinions on the developer:</li> <li>Reserved names are limited to a minimum.</li> <li>TypeScript API design patterns that are known to result in poor developer experience when represented in other     languages will cause warnings to be issued, but the developer is ultimately entitled to decide whether they want to     take or leave the advice.</li> <li>jsii produces artifacts compatible with idiomatic tools whenever possible:</li> <li>Generated libraries can be easily published to the \"standard\" package repository for the language.</li> <li>Standard tools can be used to work with the generated libraries, and do not require any special configuration.</li> </ul>"},{"location":"specification/1-introduction/#annotations","title":"Annotations","text":"<p>Annotations are present in the jsii specification to provide additional information to the reader that is non-normative. Those take the form of block-quotes that use the following chart:</p> <p>Unimplemented</p> <p>Is used to annotate parts of the specification that are known to be partially or incorrectly implemented in the current releases. Those are known issues in the current implementation that will be addressed in the future.</p> <p>Question</p> <p>Is used to annotate open questions. They are typically in parts of the specification that is likely to change in future releases, and that may be good candidates for introducing RFCs.</p> <p>Danger</p> <p>Is used to draw the reader's attention on specific points. They are used primarily to help the reader identify areas of the specification that, when incorrectly implemented, may result in hard-to-troubleshoot bugs; or to identify behavior that is intentionally undefined.</p> <p>Info</p> <p>Is used to provide additional context which may not be obvious to the reader. They typically contain trivia that can help the reader understand the motivation for certain behaviors that are not always intuitive.</p>"},{"location":"specification/1-introduction/#concepts","title":"Concepts","text":"<p>jsii allows developers to author code once in TypeScript, while allowing use in a variety of other programming languages (including C#, Java and Python).</p>"},{"location":"specification/1-introduction/#assemblies","title":"Assemblies","text":"<p>The jsii Assembly document contains a specific representation of the API exported by the TypeScript module. Similar to a header file in the C++ world, it contains only information about the signatures of APIs (type names with method and property signatures, associated documentation elements, ...) and no implementation.</p> <p>The npm package produced as a result of compiling the TypeScript source remains the source of truth with respects to implementation of the API.</p>"},{"location":"specification/1-introduction/#host-kernel","title":"Host &amp; Kernel","text":"<p>The jsii runtime architecture defines two processes:</p> <ol> <li>The host process runs the users' code native environment (a Java virtual machine, the .NET Runtime, ...).</li> <li>The kernel process hosts the JavaScript code from the standard npm package defined by the user (and their    dependencies), which is loaded and managed by a standardized <code>@jsii/kernel</code> package.</li> </ol> <p>The host process is responsible for starting the kernel process as needed. A designated host runtime library provides helper functions that will perform the necessary initialization when needed, so the host app does not need to include any special boilerplate code.</p> <p>The two processes exchange messages over a designated communication channel (for example, using pipes), using a kernel API that is standardized in the jsii specification.</p>"},{"location":"specification/1-introduction/#components","title":"Components","text":"<p>Several tools are involved in making this possible:</p> <ul> <li><code>jsii</code> is a modified TypeScript compiler. In addition to generating JavaScript code from the source, it   produces a jsii Assembly document.</li> <li><code>jsii-pacmak</code> generates language bindings from a package compiled using <code>jsii</code>. It generates code in host   languages that expose the API declared in the jsii Assembly document.</li> <li>Host runtime libraries centralize features used by code generated by <code>jsii-pacmak</code>, such as primitives to interact   with the kernel process, so that this code does not need to be duplicated in every generated module.</li> <li><code>@jsii/kernel</code> (and <code>@jsii/runtime</code>) provide the functionality exposed by the kernel process, and allow the   host code to seamlessly interact with the JavaScript implementation.</li> </ul>"},{"location":"specification/2-type-system/","title":"The jsii type system","text":""},{"location":"specification/2-type-system/#preamble","title":"Preamble","text":"<p>The base language for authoring jsii libraries for re-use from other languages is TypeScript, which compiles to JavaScript. Consequently, the base type system that jsii sources from is that of TypeScript.</p> <p>When used from another language than TypeScript or JavaScript, jsii libraries are running the JavaScript code in a child node process, and data is exchanged using JSON-based protocol.</p> <p>This document describes how TypeScript types map into the jsii type system.</p> <p>The API represented by the jsii assembly only covers declarations that are exported from the main file in the TypeScript project (as specified in the <code>package.json</code> file by the <code>types</code> attribute). Restrictions described in this document only apply to such declarations, the rest of the module can leverage any TypeScript feature.</p>"},{"location":"specification/2-type-system/#basic-types","title":"Basic Types","text":""},{"location":"specification/2-type-system/#introduction","title":"Introduction","text":"<p>In order to build useful programs, the simplest units of data need to be modeled: booleans, numbers, strings, etc... Those basic building blocks are the foundations on which APIs stand. jsii supports much of the same types that TypeScript and JavaScript support, although with notable differences.</p>"},{"location":"specification/2-type-system/#boolean","title":"Boolean","text":"<p>The jsii type system mirrors TypeScript's <code>boolean</code>, which is the simplest primitive data types, with only two supported values: <code>true</code> and <code>false</code>.</p>"},{"location":"specification/2-type-system/#number","title":"Number","text":"<p>The jsii type system mirrors TypeScript's <code>number</code>. All numbers are floating point values.</p>"},{"location":"specification/2-type-system/#string","title":"String","text":"<p>The jsii type system mirrors TypeScript's <code>string</code>. Strings are used to represent textual data.</p>"},{"location":"specification/2-type-system/#list","title":"List","text":"<p>TypeScript arrays (<code>Array&lt;T&gt;</code>, <code>T[]</code>, <code>ReadonlyArray&lt;T&gt;</code> and <code>readonly T[]</code>) are represented as lists in the jsii type model. Lists are shared between the node process and the host process by-value, meaning a copy of the array is produced each time it is passed through the process boundary.</p> <p>Info</p> <p>Items in the list may be passed by-reference (according to their type's specification), in which case mutating operations performed on those may be visible across the process boundary.</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#enum","title":"Enum","text":"<p>As in many languages, <code>enum</code> can be used to represent a group of related constants. While TypeScript <code>enum</code> entries are associated with a value that is either a <code>string</code> or a <code>number</code>, the jsii type system does not allow for those to be down-casted to their value type (e.g: a <code>string</code>-valued <code>enum</code> entry cannot be directly passed into a <code>string</code> parameter).</p> <p>Info</p> <p>Unlike in certain languages such as Java, <code>enum</code> types cannot declare new properties or methods.</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#any-and-unknown","title":"Any and Unknown","text":"<p>TypeScript defines two opaque types: <code>any</code> and <code>unknown</code> that can be used to represent a value of arbitrary type. The difference between them is that while <code>any</code> is assignable to any other type, <code>unknown</code> requires a type assertion or explicit cast to be performed before it can be assigned.</p> <p>Both of these types map to an <code>Any</code> primitive type in the jsii type system, and the subtle distinction between <code>any</code> and <code>unknown</code> is lost in the process.</p> <p>Info</p> <p>It is important to note that, contrary to the other types in the TypeScript type system, <code>any</code> and <code>unknown</code> types are inherently <code>null</code>-able.</p>"},{"location":"specification/2-type-system/#void","title":"Void","text":"<p>As in most languages, the <code>void</code> type is used to denote a method does not return anything.</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#null-and-undefined","title":"Null and Undefined","text":"<p>JavaScript differentiates <code>undefined</code> and <code>null</code> values. While <code>undefined</code> denotes that no value has been set, <code>null</code> denotes an intentional signal of there being no data. Most other programming languages (particularly statically typed languages) however lack this distinction, and the jsii type model consequently considers <code>null</code> and <code>undefined</code> are semantically equivalent.</p> <p>Info</p> <p>Unlike certain other programming languages, such as Java, TypeScript does not allow <code>null</code> (or <code>undefined</code>) values unless the type signature expressedly supports that (with the exception of <code>any</code> and <code>unknown</code>, which are implicitly <code>null</code>-able, as was discussed earlier).</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#object","title":"Object","text":"<p>TypeScript's <code>object</code> type denotes anything that is not a primitive type, meaning anything other than a <code>number</code>, <code>string</code>, <code>boolean</code>, <code>bigint</code>, <code>symbol</code>, <code>null</code> or <code>undefined</code>.</p> <p>In the jsii type model, <code>object</code> indicates a block of structured data that can be shared by-value across the process boundary. As a consequence, they may not include any method.</p> <p>Unimplemented</p> <p>This type is called <code>Json</code> in the current implementation.</p> <p>Question</p> <p>The by-value nature of <code>object</code> is problematic because TypeScript makes no guarantee with respects to the absence of methods on <code>object</code>, and properties may be dynamic.</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#promises","title":"Promises","text":"<p>jsii supports asynchronous methods, and the TypeScript <code>Promise&lt;T&gt;</code> type has to be used as the result of <code>async</code> methods. Promises can only be used as the result type of methods, not as the type of a property or parameter.</p>"},{"location":"specification/2-type-system/#unsupported-typescript-basic-types","title":"Unsupported TypeScript basic types","text":"<p>Due to how such types cannot be represented in many other programming languages, the jsii type model does not support the following TypeScript entities:</p> <ul> <li>Tuples, a group of arbitrarily-typed values, often used as the result type for multi-valued functions.</li> <li>The <code>never</code> type, which is used as the return type of functions that will not yield control back to their invoker   (infinite loops, <code>process.exit()</code>, ...).</li> <li><code>bigint</code> and <code>symbol</code> don't have equivalents in many other programming languages and are generally of limited value in   API design.</li> </ul>"},{"location":"specification/2-type-system/#complex-types","title":"Complex Types","text":"<p>The goal of the jsii is to enable cross-language re-use of class libraries. TypeScript enables representing classic object-oriented concepts, such as classes and interfaces. The jsii type system supports some additional nuances on top of those, to better represent TypeScript and JavaScript idioms in a way that enables generating convenient APIs in other languages.</p>"},{"location":"specification/2-type-system/#classes","title":"Classes","text":"<p>Exported TypeScript classes are represented in the jsii type system, with the following restrictions from plain TypeScript:</p> <ul> <li>Methods overloads are not supported.</li> <li>Overridden methods or properties must retain the exact same type signature as the one declared in a parent type. The   jsii type system strictly enforces the Liskov substitution principle.</li> </ul>"},{"location":"specification/2-type-system/#interfaces-structs","title":"Interfaces &amp; Structs","text":"<p>Exported TypeScript interfaces are interpreted as one of two entities in the jsii type system:</p> <ul> <li>If the <code>interface</code> name is prefixed with an <code>I</code> (e.g: <code>ISomething</code>), it is interpreted as a behavioral interface.</li> <li>Otherwise (e.g: <code>Something</code>), it is interpreted as a struct.</li> </ul>"},{"location":"specification/2-type-system/#behavioral-interfaces","title":"Behavioral Interfaces","text":"<p>Behavioral interfaces are the usual object-oriented interface: they can extend other behavioral interfaces, and can be extended by classes. They may however not extend structs.</p>"},{"location":"specification/2-type-system/#structs","title":"Structs","text":"<p>Structs are used to model the JavaScript idiom of receiving options as an object literal passed as the last parameter of a function. They are a formal description of a bag of properties, and are not meant to be implemented by other types. Since those types are used as inputs, they can be handled as pure-data, immutable objects, and the following restrictions apply:</p> <ul> <li>A struct cannot declare any method: they must be kept behavior-free.</li> <li>All properties declared by a struct must be <code>readonly</code>. The values of the properties may however be mutable.</li> </ul> <p>Structs may extend one or more other structs, but cannot extend or be extended by behavioral interfaces, and may not be implemented by classes.</p>"},{"location":"specification/2-type-system/#type-unions","title":"Type Unions","text":"<p>In certain cases, several different kinds of values are acceptable for a given parameter or return type. TypeScript models those cases using type unions, which are represented as <code>TypeA | TypeB</code>. The jsii type model supports those, however most other statically typed languages do not have such a concept, making those parameters or return values difficult to use from those languages, as the value has to be declared using the most generic reference type available (for example, in Java, those are returned as <code>java.lang.Object</code>).</p> <p>When used as inputs (parameters, or properties of a struct), it may be possible to generate method overloads that will allow for a convenient API in languages that support overloads.</p> <p>In general however, type unions are discouraged and should only be used when there is no alternative way to model the API.</p> <p>Find out more here</p>"},{"location":"specification/2-type-system/#serialization-behavior","title":"Serialization Behavior","text":"<p>When values are passed between the host process and the <code>node</code> process, they are serialized as JSON documents. They can be passed by value or by reference, depending on the type of the value as well as the declared type of the transfer point (method return type, property type, argument type, ...).</p> <p>The table below describes the serialization behavior applied for each possible declared type (rows) for a value of a given dynamic type (columns). The  sign expresses cases that are illegal and should cause immediate failure. The term primitive encompasses <code>boolean</code>, <code>string</code>, and <code>number</code>.</p> <code>undefined</code> <code>Date</code> primitive <code>Array</code> instance <code>object</code> <code>void</code> <code>undefined</code> <code>undefined</code> <code>undefined</code> <code>undefined</code> <code>undefined</code> <code>undefined</code> <code>Date</code> <code>undefined</code> Date primitive <code>undefined</code> Identity <code>enum</code> <code>undefined</code> Enum <code>List</code> <code>undefined</code> Array <code>Map</code> <code>undefined</code> Mapping <code>interface</code> <code>undefined</code> Reference Reference <code>struct</code> <code>undefined</code> Value <code>class</code> <code>undefined</code> Reference Reference <code>any</code> <code>undefined</code> Date Identity Array Reference Value or Reference <p>In the case of <code>object</code> being passed though <code>any</code>, the value may be serialized by Value only if the value being passed does not have any method or dynamic accessor. Otherwise, it must be passed by Reference instead.</p> <p>Danger</p> <p>The serialization behavior around <code>undefined</code> values is affected by the <code>optional</code> attribute of the declared type. As discussed earlier, the <code>any</code> type is implicitly <code>optional</code>; but all other types' serialization process will only allow serialization of <code>undefined</code> if they were declared <code>optional</code>.</p>"},{"location":"specification/2-type-system/#array-serialization","title":"Array Serialization","text":"<p>Arrays are serialized into the standard JSON representation for them. Each value in the array is serialized according to the behavior dictated by the declared element type of the list, combined with the dynamic type of the value itself.</p>"},{"location":"specification/2-type-system/#date-serialization","title":"Date Serialization","text":"<p>JSON has no standard expression for <code>Date</code>. A special JSON object representation is used to allow unambiguously conveying a date. The wrapper has a single key (<code>$jsii.date</code>) with the ISO 8601-1 UTC representation of the <code>Date</code> value:</p> <pre><code>{ \"$jsii.date\": \"2020-01-20T14:04:00.000Z\" }\n</code></pre>"},{"location":"specification/2-type-system/#enum-serialization","title":"Enum Serialization","text":"<p>In JavaScript, <code>enum</code> entries are represented by their value equivalent. In order to support statically typed representations in other languages, these are serialized using a dedicated wrapper object, using a single key (<code>$jsii.enum</code>) with the fully qualified name of the <code>enum</code> entry (formatted as <code>&lt;enum type fqn&gt;/&lt;entry name&gt;</code>):</p> <pre><code>{ \"$jsii.enum\": \"@scope/module.EnumType/ENTRY_NAME\" }\n</code></pre>"},{"location":"specification/2-type-system/#identity-serialization","title":"Identity Serialization","text":"<p>The identity serialization is achieved by using the standard JSON representation of the primitive type. JSON strings are expressed using the <code>UTF-8</code> character set.</p>"},{"location":"specification/2-type-system/#mapping-serialization","title":"Mapping Serialization","text":"<p>Key-value pairs are passed by-value between the processes and is wrapped using a single-key (<code>$jsii.map</code>) associated with the JSON representation of the encoded object; where values are serialized according to the behavior dictated by the element type of the mapping, combined with the dynamic type of the value itself:</p> <pre><code>{\n\"$jsii.map\": {\n\"foo\": {\n\"date\": { \"$jsii.date\": \"2020-01-20T14:04:00.000Z\" },\n\"map\": { \"$jsii.map\": {} }\n}\n}\n}\n</code></pre>"},{"location":"specification/2-type-system/#reference-serialization","title":"Reference Serialization","text":"<p>Objects serialized by reference are passed using a special object that provides sufficient information to tie back to the instance within its owning process. It includes a <code>$jsii.byref</code> key associated with a string that uniquely identifies the instance, and an optional <code>$jsii.interfaces</code> key that provides a list of interfaces that the object implements.</p> <pre><code>{\n\"$jsii.byref\": \"@scope/module.Foo@1337\",\n\"$jsii.interfaces\": [\"@scope/module.IBar\", \"@scope/module.IBaz\"]\n}\n</code></pre>"},{"location":"specification/2-type-system/#value-serialization","title":"Value Serialization","text":"<p>Structs can be serialized by-value. In those cases, the value is wrapped using a special object that encapsulates the type information for the provided data as well as the struct's members.</p> <p>The wrapper uses a single <code>$jsii.struct</code> key with a <code>fqn</code> key that indicates the fully qualified name of the struct type, and a <code>data</code> key that contains the members of the struct, serialized according to the behavior described in this document.</p> <pre><code>{\n\"$jsii.struct\": {\n\"fqn\": \"@scope/module.StructType\",\n\"data\": {\n\"enumValue\": { \"$jsii.enum\": \"@scope/module.EnumType.ENTRY_NAME\" },\n\"stringProperty\": \"Hello, I'm a string!\"\n}\n}\n}\n</code></pre>"},{"location":"specification/2-type-system/#submodules","title":"Submodules","text":""},{"location":"specification/2-type-system/#overview","title":"Overview","text":"<p>Typescript allows grouping declarations together in namespaces, which are interpreted by jsii as submodules. Submodules names are the fully qualified name of the namespace from the package's root (if a package <code>foo</code> defines a namespace <code>ns1</code>, which itself contains <code>ns2</code>, the submodule for <code>ns2</code> will be named <code>foo.ns1.ns2</code>).</p> <p>Submodules are delcared in the jsii assembly under the <code>submodules</code> key. This is also where specific configuration is registered, if different from the parent submodule or package.</p> <p>Submodules are hierarchical, and their fully qualified name is representative of the relationship. For example the <code>assm.foo.bar</code> submodule is considered to be nested under the <code>assm.foo</code> submodule.</p>"},{"location":"specification/2-type-system/#restrictions","title":"Restrictions","text":"<p>Submodules cannot be involved in dependency cycles. While it is possible to build such cycles in JavaScript, that configuration cannot be reliably reprensented in certain other programming languages (e.g: Python).</p> <p>Unimplemented</p> <p><code>jsii</code> does not currently check for circular submodule dependencies. Invalid dependency patterns may result in errors at code generation by <code>jsii-pacmak</code>, or at runtime.</p> <p>Since this would result in ambiguity that cannot be consistently resolved, a given type can only be exported as part of one submodule.</p>"},{"location":"specification/2-type-system/#declaration","title":"Declaration","text":"<p>There are two supported ways to introduce submodules:</p> <ul> <li>Using the namespaced export syntax:   <pre><code>export * as ns from './module';\n</code></pre></li> <li>Using an explicit namespace declaration:   <pre><code>export namespace ns {\n/* ... */\n}\n</code></pre></li> </ul> <p>Submodules declared using the <code>export * as ns from './module';</code> syntax can be documented using a markdown document located at <code>./module/README.md</code>.</p> <p>Unimplemented</p> <p>The <code>./module/README.md</code> file support is not yet implemented.</p>"},{"location":"specification/2-type-system/#submodule-configuration","title":"Submodule Configuration","text":"<p>In languages where this is relevant (e.g: Python), submodules are rendered as native submodules. In languages where a namespace system exists (Java uses packages, C# uses namespaces, ...), submodules are rendered using that.</p> <p>By default, submodule names are rendered appropriately in the target language (this typically involves adjusting the case of submodule name fragments to the idiomatic form in the language). In certain cases however, a developer can choose to use a different configuration by defining the submodule using the namespaced-export syntax (<code>export * as namespace from './module-name';</code>) by placing a <code>.jsiirc.json</code> file next to the entry point of the namespaced module. For example, if <code>./module-name</code>'s entry point is <code>foo/bar/module-name/index.ts</code>, the submodule configuration resides in <code>foo/bar/module-name/.jsiirc.json</code>.</p> <p>Since submodules are hierarchical, the configuration of a given submodule defines the default configuration of submodules nested under it.</p>"},{"location":"specification/2-type-system/#code-generation","title":"Code Generation","text":"<p>In order to generate code in various programming languages, <code>jsii-pacmak</code> needs configuration that provides naming directives (e.g: Java package names, C# namespaces, Python module names, ...). This configuration is language-specific and each language implementation specifies and documents its own configuration schema.</p> <p>Configuration is sourced in the <code>package.json</code> file at the root of the npm package, under the special <code>jsii</code> key. The general schema is described in the configuration document.</p> <p>Unimplemented</p> <p>There is a proposition to allow this configuration to be placed in a <code>.jsiirc.json</code> file, which would take precedence over what is specified in <code>package.json</code>. Submodules introduced using the <code>export * as ns from './module';</code> syntax would then be able to define submodule-local configuration using the <code>./module/.jsiirc.json</code> file.</p>"},{"location":"specification/2-type-system/#references","title":"References","text":"<p>The TypeScript Handbook describes the language's type system and syntax elements that serve as the basis for the jsii type system. Additionally, the JavaScript type system is described in the JavaScript Fundamentals document.</p>"},{"location":"specification/3-kernel-api/","title":"The jsii kernel API","text":"<p>This document describes the API for the <code>@jsii/kernel</code> module, which is to be used by all host libraries. It provides the fundamental features necessary for host processes to interact with the original module's code.</p> <p>Note</p> <p>Currently, <code>@jsii/kernel</code> contains the bulk of the logic, however a separate <code>@jsii/runtime</code> package owns the dialogue between the host and kernel processes. The <code>@jsii/runtime</code> is a very thin glue layer and it will eventually be merged into <code>@jsii/kernel</code>.</p>"},{"location":"specification/3-kernel-api/#errors","title":"Errors","text":"<p>Most of the calls described in this document may result in an error being raised. It is the responsibility of the host runtime library to deal with such errors correctly: action retries, propagate the error to the host app's code, and so on.</p> <p>Error responses are signaled by the <code>error</code> key:</p> <pre><code>export interface ErrorResponse {\n/** A simple message describing what happened. */\nmessage: string;\n/** Whenever possible, the stack trace of the error. */\nstack?: string;\n}\n</code></pre> <p>Where possible, the host runtime libraries should make sure to affix their own stack trace information where relevant to the kernel process's stack trace when such errors are propagated to host app's code, in order to offer as much relevant context information as possible.</p>"},{"location":"specification/3-kernel-api/#initialization-the-hello-message","title":"Initialization - the <code>hello</code> message","text":"<p>The host library is responsible for spawning the <code>node</code> process that will run the original module's code. This <code>node</code> process runs the <code>@jsii/kernel</code> application, and API messages are exchanged via the <code>node</code> processes' standard input and output pipes.</p> <p>Upon initialization, the <code>@jsii/kernel</code> process introduces itself to the host application by emitting a single JSON message:</p> <pre><code>{\n\"hello\": \"@jsii/runtime@0.21.1\"\n}\n</code></pre> <p>Any additional key present on the <code>hello</code> message will be silently ignored by a host library that does not know how to process it, ensuring forward compatibility of this message, if and when new attributes are added.</p> <p>Note</p> <p>In the future, this message may be augmented with additional keys to enable feature negotiation between the host application and the <code>@jsii/kernel</code>.</p>"},{"location":"specification/3-kernel-api/#teardown-the-exit-message","title":"Teardown - the <code>exit</code> message","text":"<p>The host library should send the <code>exit</code> message when it no longer needs the <code>@jsii/kernel</code>. This message enables the <code>@jsii/kernel</code> to trigger clean-up operations, such as getting rid of temporary directories, in order to avoid littering the temporary directory with leftover files.</p> <p>The <code>exit</code> message has the following schema:</p> <pre><code>interface Exit {\n/** The exit code the `@jsii/kernel` process should return. Typically `0`. */\nreadonly exit: number;\n}\n</code></pre> <p>Important</p> <p>Once the <code>exit</code> message has been sent, no more data should be sent through to the <code>@jsii/kernel</code> process. The request stream should be closed as soon as the <code>exit</code> message was sent. Additional data may however be received from the <code>@jsii/kernel</code> that is intended to the <code>STDOUT</code> or <code>STDERR</code> console streams.</p>"},{"location":"specification/3-kernel-api/#general-kernel-api","title":"General Kernel API","text":"<p>Once the <code>hello</code> handshake is complete, a sequence of request and responses are exchanged with the <code>@jsii/kernel</code>. Requests take the form of JSON-encoded messages that all follow the following pattern:</p> <pre><code>interface Request {\n/**\n   * This field discriminates the various request types.\n   */\napi:\n| 'load' // Loading jsii assemblies into the Kernel\n| 'naming' // Obtaining naming information for loaded assemblies\n| 'stats' // Obtaining statistics about the Kernel usage\n| 'create' // Creating objects\n| 'del' // Destroying objects\n| 'invoke'\n| 'sinvoke' // Invoking methods (and static methods)\n| 'get'\n| 'sget' // Invoking getters (and static getters)\n| 'set'\n| 'sset' // Invoking setters (and static setters)\n| 'begin'\n| 'end'; // Asynchronous method invocation\n\n// ... request-type specific fields ...\n}\n</code></pre>"},{"location":"specification/3-kernel-api/#loading-jsii-assemblies-into-the-kernel","title":"Loading jsii assemblies into the Kernel","text":"<p>Before any jsii type can be used, the assembly that provides it must be loaded into the kernel. Similarly, all dependencies of a given jsii module must have been loaded into the kernel before the module itself can be loaded (the <code>@jsii/kernel</code> does not perform any kind of dependency resolution).</p> <p>Loading new assemblies into the <code>@jsii/kernel</code> is done using the <code>load</code> API:</p> <pre><code>interface LoadRequest {\n/** The name of the assembly being loaded */\nname: string;\n/** The version of the assembly being loaded */\nversion: string;\n/** The local path to the npm package for the assembly */\ntarball: string;\n\n// The discriminator\napi: 'load';\n}\n</code></pre> <p>The response to the <code>load</code> call provides some high-level information pertaining to the loaded assembly, which may be used by the host app to validate the result of the operation:</p> <pre><code>interface LoadResponse {\n/** The name of the assembly that was just loaded */\nassembly: string;\n/** The number of types the assembly declared */\ntypes: number;\n}\n</code></pre> <p>Once a module is loaded, all the types it declares immediately become available.</p>"},{"location":"specification/3-kernel-api/#obtaining-naming-information-for-loaded-assemblies","title":"Obtaining naming information for loaded assemblies","text":"<p>In certain cases, host runtime libraries may need to obtain naming information from assemblies in order to determine the translation table from a jsii fully-qualified name to a host-native name. This can be retrieved using the <code>naming</code> call:</p> <pre><code>export interface NamingRequest {\n/** The name of the assembly for which naming is requested */\nassembly: string;\n\n// The discriminator\napi: 'naming';\n}\n</code></pre> <p>In response to the <code>naming</code> call, the <code>@jsii/kernel</code> returns the configuration block for each language supported by the named <code>assembly</code>:</p> <pre><code>export interface NamingResponse {\n/** The naming information for the requested assembly. */\nnaming: {\n/**\n     * For each language, provides the jsii configuration block. The content of\n     * this configuration block is specified by each language implementation.\n     */\n[language: string]: { [key: string]: any };\n};\n}\n</code></pre>"},{"location":"specification/3-kernel-api/#obtaining-statistics-about-the-kernel-usage","title":"Obtaining statistics about the Kernel usage","text":"<p>The <code>stats</code> call can be used to obtain information about the current <code>Kernel</code> instance, which can be leveraged by unit tests or in order to produce metrics for tracking the health of a long-running jsii app.</p> <pre><code>export interface StatsRequest {\n// The discriminator\napi: 'stats';\n}\n</code></pre> <p>The response to the <code>stats</code> call contains synthetic information about the current state of the <code>Kernel</code>:</p> <pre><code>export interface StatsResponse {\n/** The number of object reference currently tracked by the Kernel */\nobjectCount: number;\n}\n</code></pre>"},{"location":"specification/3-kernel-api/#creating-objects","title":"Creating objects","text":"<p>Most jsii workflows start with creating instances of objects. This can mean creating a pure JavaScript object, instantiating a sub-class of some JavaScript class, or even creating a pure-host instance that implements a collection of behavioral interfaces.</p> <p>Creating objects is achieved using the <code>create</code> API, which accepts the following parameters:</p> <pre><code>interface CreateRequest {\n/** The jsii fully qualified name of the class */\nfqn: string;\n/** Any arguments to provide to the constructor */\nargs?: any[];\n/** Additional interfaces implemented in the host app */\ninterfaces?: string[];\n/** Any methods or property overridden in the host app */\noverrides?: Override[];\n\n// The discriminator\napi: 'create';\n}\n</code></pre> <p>The response to the object call is a decorated <code>ObjectReference</code> object (which is a common parameter to other calls in the <code>@jsii/kernel</code> API, used to refer to a particular instance):</p> <pre><code>interface ObjectReference {\n/** A handle that uniquely idenfies an instance */\n'$jsii.byref': string;\n}\n\ninterface CreateResponse extends ObjectReference {\n/** The list of interfaces implemented by the instance */\n'$jsii.interfaces'?: string[];\n}\n</code></pre> <p>The value of the <code>'$jsii.byref'</code> field of the <code>ObjectReference</code> type is formatted in the following way:</p> <pre><code>@aws-cdk/core.Stack@10003\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u252c\u2500\u2518\n         \u2502            \u2514\u2500 Opaque numeric identifier\n         \u2514\u2500 Object instance's base class' jsii fully qualified name\n</code></pre> <p>The first part of the reference identifier can have the special un-qualified value <code>Object</code> to denote the absence of a jsii-known base class (for example when the object only implements a jsii interface).</p>"},{"location":"specification/3-kernel-api/#additional-interfaces","title":"Additional Interfaces","text":"<p>Sometimes, the host app will extend a jsii class and implement new jsii interfaces that were not present on the original type. Such interfaces must be declared by providing their jsii fully qualified name as an entry in the <code>interfaces</code> list.</p> <p>Providing interfaces in this list that are implicitly present from another delcaration (either because they are already implemented by the class denoted by the <code>fqn</code> field, or because another entry in the <code>interfaces</code> list extends it) is valid, but not necessary. The <code>@jsii/kernel</code> is responsible for correctly handling redundant declarations.</p> <p>Danger</p> <p>While declared <code>interfaces</code> may contain redundant declarations of members already declared by other <code>interfaces</code> or by the type denoted by <code>fqn</code>, undefined behavior results if any such declaration is not identical to the others (e.g: property <code>foo</code> declared with type <code>boolean</code> on one of the <code>interfaces</code>, and with type <code>string</code> on another).</p>"},{"location":"specification/3-kernel-api/#overrides","title":"Overrides","text":"<p>For any method that is implemented or overridden from the host app, the <code>create</code> call must specify an <code>override</code> entry. This will inform the Kernel that calls to these methods must be relayed to the host app for execution, instead of executing the original library's version.</p> <p>An optional <code>cookie</code> string can be provided. This string will be recorded on the Javascript proxying implementation, and will be provided to the host app with any callback request. This information can be used, for example, to improve the performance of implementation lookups in the host app, where the necessary reflection calls would otherwise be prohibitively expensive.</p> <p>Override declarations adhere to the following schema:</p> <pre><code>interface MethodOverride {\n/** The name of the overridden method */\nmethod: string;\n/** An arbitrary override cookie string */\ncookie?: string;\n}\n\ninterface PropertyOverride {\n/** The name of the overridden property */\nproperty: string;\n/** An arbitrary override cookie string */\ncookie?: string;\n}\n\ntype Override = MethodOverride | PropertyOverride;\n</code></pre>"},{"location":"specification/3-kernel-api/#a-note-about-callbacks","title":"A note about callbacks","text":"<p>All <code>@jsii/runtime</code> calls that interact with object instances (that is, any call except for <code>load</code>, <code>naming</code> and <code>stats</code>; as well as the <code>del</code> call since jsii does not support customized destructors or finalizers) may result in the need to execute code that is defined in the host app, when the code path traverses a method or property that was implemented or overridden in the host app.</p> <p>Such cases will result in a callback request substituting itself to the response of the original call being made; execution of which will resume once the callback response is provided.</p> <p>A callback request is sent from the <code>@jsii/kernel</code>'s <code>node</code> process to the host app and has the following schema:</p> <pre><code>interface CallbackRequest {\n/** Callback requests are identified by the presence of the `callback` key */\ncallback: Callback;\n}\n\ninterface CallbackBase {\n/** A unique identifier for this callback request */\ncbid: string;\n/** The object on which the callback must be executed */\nobjref: ObjectReference;\n/** The callback cookie, if one was specified */\ncookie?: string;\n}\n\ninterface InvokeCallback extends CallbackBase {\n/** The name of the host method to be invoked */\nmethod: string;\n}\n\ninterface GetCallback extends CallbackBase {\n/** The name of the property to be read */\nproperty: string;\n}\n\ninterface SetCallback extends CallbackBase {\n/** The name of the property to be written to */\nproperty: string;\n/** The value to be set */\nvalue: any;\n}\n\ntype Callback = InvokeCallback | GetCallback | SetCallback;\n</code></pre> <p>In order to fulfill the callback request, the host app may need to perform futher API calls (loading new assemblies, creating new instances, invoking methods - including delegating to the <code>super</code> implementation, ...). Such calls will behave as they otherwise would (including the possible introduction of further callback requests).</p> <p>Once the host app has fulfilled the request, it must signal the result of that execution back to the <code>@jsii/kernel</code> process by using the <code>complete</code> call:</p> <pre><code>interface CompleteBase {\n/** The callback ID from the corresponding request */\ncbid: string;\n\n// The discriminator\napi: `complete`;\n}\n\ninterface CallbackSuccess extends CompleteBase {\n/** The result of the execution (`undefined` if void) */\nresult: any;\n}\n\ninterface CallbackFailure extends CompleteBase {\n/** The error that was raised during fulfillment */\nerr: string;\n}\n\ntype CompleteRequest = CallbackSuccess | CallbackFailure;\n</code></pre> <p>As discussed earlier, the response to the <code>complete</code> call is the result of resuming execution of the code path that triggered the callback request. This may be another callback request, or the final result of that call.</p> <p>The <code>callbacks</code> call may be used to determine the list of all outstanding callback requests:</p> <pre><code>interface CallbacksRequest {\n// The discriminator\napi: 'callbacks';\n}\n</code></pre> <p>This call results in a list of outstanding callbacks:</p> <pre><code>interface CallbacksResponse {\n/** The list of outstanding callback requests */\ncallbacks: Callback[];\n}\n</code></pre>"},{"location":"specification/3-kernel-api/#destroying-objects","title":"Destroying Objects","text":"<p>Once the host app no longer needs a particular object, it can be discarded. This can happen for example when the host reference to an object is garbage collected or freed. In order to allow the JavaScript process to also reclaim the associated memory footprint, the <code>del</code> API must be used:</p> <pre><code>interface DelRequest {\n/** The object reference that can be released */\nobjref: ObjectReference;\n\n// The discriminator\napi: 'del';\n}\n</code></pre> <p>Danger</p> <p>Failure to use the <code>del</code> API will result in memory leakage as the JavaScript process accumulates garbage in its Kernel instance. This can eventually result in a Javascript heap out of memory error, and the abnormal termination of the <code>node</code> process, and consequently of the host app.</p> <p>Unimplemented</p> <p>The existing host runtime libraries do not implement this behavior!</p> <p>Question</p> <p>There is currently no provision for the <code>node</code> process to inform the host app about object references it dropped. This mechanism is necessary in order to support garbage collection of resources that involve host-implemented code (in such cases, the host app must hold on to any instance it passed to JavaScript until it is no longer reachable from there).</p> <p>Upon successfully deleting an object reference, the <code>@jsii/kernel</code> will return an empty response object:</p> <pre><code>export interface DelResponse {}\n</code></pre>"},{"location":"specification/3-kernel-api/#invoking-methods-and-static-methods","title":"Invoking methods (and static methods)","text":"<p>Invoking methods is done via the <code>invoke</code> call:</p> <pre><code>interface InvokeRequest {\n/** The object reference on which a method is invoked */\nobjref: ObjectReference;\n/** The name of the method being invoked */\nmethod: string;\n/** Any arguments passed to the method invocation */\nargs?: any[];\n\n// The discriminator\napi: 'invoke';\n}\n</code></pre> <p>Static method invocations do not have a receiving instance, and instead are implemented by way of the <code>sinvoke</code> call:</p> <pre><code>interface StaticInvokeRequest {\n/** The jsii fully qualified name of the declaring type */\nfqn: string;\n/** The name of the static method being invoked */\nmethod: string;\n/** Any arguments passed to the method invocation */\nargs?: any[];\n\n// The discriminator\napi: 'sinvoke';\n}\n</code></pre> <p>Note that, unlike in certain programming languages such as Java, it is illegal to attempt invoking a static method on the static type of some instance using the <code>invoke</code> call. All static invocations must be done using <code>sinvoke</code>.</p> <p>Both the <code>invoke</code> and <code>sinvoke</code> calls result in the same response:</p> <pre><code>interface InvokeResponse {\n/** The result of the method invocation. */\nresult: any;\n}\n</code></pre> <p>When the method's return type is <code>void</code>, the <code>result</code> value should typically be <code>undefined</code>, however it may not be ?? (TypeScript may in certain circumstances allow returning a value from a <code>void</code> method): the host app should ignore such values.</p>"},{"location":"specification/3-kernel-api/#asynchronous-method-invocation","title":"Asynchronous method invocation","text":"<p>The <code>invoke</code> call can only be used to invoke synchronous methods. In order to invoke asynchronous methods, the <code>begin</code> and <code>end</code> calls must be used instead. Once the host app has entered an asynchronous workflow (after it makes the first <code>begin</code> call), and until it has completed all asynchronous operations (after all <code>begin</code> class are matched with an <code>end</code> call), no synchronous operation (including synchronous callbacks) may be initiated.</p> <pre><code>interface BeginRequest {\n/** The object reference on which an asynchronous method is invoked */\nobjref: ObjectReference;\n/** The name of the method being invoked */\nmethod: string;\n/** Any arguments passed to the method invocation */\nargs?: any[];\n\n// The discriminator\napi: 'begin';\n}\n</code></pre> <p>Question</p> <p>There is no static form of this call. Should there be one?</p> <p>The <code>begin</code> call results in a promise being made:</p> <pre><code>interface BeginResponse {\n/**\n   * An opaque string that uniquely idenfies the promised result of this\n   * invocation.\n   */\npromiseid: string;\n}\n</code></pre> <p>Whenever the host app needs to obtain the promised value (possibly in a blocking way), it makes the corresponding <code>end</code> call:</p> <pre><code>interface EndRequest {\n/** The promiseid that was returned from the corresponding `begin` call. */\npromiseid: string;\n\n// The discriminator\napi: 'end';\n}\n</code></pre> <p>This will result in the promise being awaited and then resolved:</p> <pre><code>interface EndResponse {\n/** The resolved value of the promise */\nresult: any;\n}\n</code></pre> <p>Danger</p> <p>All <code>begin</code> calls must be matched with an <code>end</code> call. Failure to do so may result in unhandled promise rejections that might cause the application to terminate in certain environments.</p>"},{"location":"specification/3-kernel-api/#invoking-getters-and-static-getters","title":"Invoking getters (and static getters)","text":"<p>In order to obtain the value of properties, the <code>get</code> call is used:</p> <pre><code>interface GetRequest {\n/** The object reference on which a poperty is read */\nobjref: ObjectReference;\n/** The name of the property being read */\nproperty: string;\n\n// The discriminator\napi: 'get';\n}\n</code></pre> <p>When operating on static properties, or in order to obtain the value of <code>enum</code> constants, the <code>sget</code> API must be used instead:</p> <pre><code>interface StaticGetRequest {\n/** The jsii fully qualified name of the declaring type */\nfqn: ObjectReference;\n/** The name of the property being read */\nproperty: string;\n\n// The discriminator\napi: 'sget';\n}\n</code></pre> <p>Both the <code>get</code> and <code>sget</code> calls result in the same response:</p> <pre><code>interface GetResponse {\n/** The value of the property. */\nresult: any;\n}\n</code></pre>"},{"location":"specification/3-kernel-api/#invoking-setters-and-static-setters","title":"Invoking setters (and static setters)","text":"<p>In order to change the value of a property, the <code>set</code> call is used:</p> <pre><code>interface SetRequest {\n/** The object reference on which a poperty is written to */\nobjref: ObjectReference;\n/** The name of the property being written to */\nproperty: string;\n/** The value that is written to the property */\nvalue: any;\n\n// The discriminator\napi: 'set';\n}\n</code></pre> <p>When operating on static properties, the <code>sset</code> API must be used instead:</p> <pre><code>interface StaticSetRequest {\n/** The jsii fully qualified name of the declaring type */\nfqn: ObjectReference;\n/** The name of the property being written to */\nproperty: string;\n/** The value that is written to the property */\nvalue: any;\n\n// The discriminator\napi: 'sset';\n}\n</code></pre> <p>Both the <code>set</code> and <code>sset</code> calls result in the same response, which is an empty object:</p> <pre><code>interface SetResponse {}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/","title":"Standard Compliance Suite","text":""},{"location":"specification/4-standard-compliance-suite/#goal","title":"Goal","text":"<p>The goal of the standard compliance suite is to be a normative description of the behaviors that all language runtime implementations (host runtime library in combination with code generation) must implement. This description takes the form of a collection of test cases that must be re-implemented in each host language, so that compliance can be asserted.</p> <p>Since the goal of jsii is to expose a single Object-Oriented API to multiple programming languages, it is important to ensure the behavior is consistent across all of them. This can be achieved by making sure that the interactions between the host and kernel processes are the same for a given use-case.</p>"},{"location":"specification/4-standard-compliance-suite/#format","title":"Format","text":"<p>In order to assert whether a new runtime implementation is correct, a formal compliance test suite is defined, that all language runtimes must fully implement before they can be deemed eligible for General Availability.</p> <p>This document describes these tests, as well as a general approach for ensuring conformance requirements are met in a systematic manner.</p>"},{"location":"specification/4-standard-compliance-suite/#categories","title":"Categories","text":"<p>Test cases in the standard compliance suite are grouped by categories, which help implementors direct their effort in the early stages of the implementation of new language bindings. Each category is declared in an <code>H3</code> title (a line that starts with <code>###</code>) within the [<code>## Test Suite</code>] title. A description of the category immediately follows the opening title. The category ends with the end of the document, or whenever another <code>H2</code> title is reached.</p>"},{"location":"specification/4-standard-compliance-suite/#test-case","title":"Test Case","text":"<p>Within a category title, test cases are delimited by <code>H4</code> (<code>####</code>) titles, which correspond to the test case name. The test case name should be kept concise (ideally within 75 characters) and try to be as descriptive as possible.</p> <p>Immediately after the <code>H4</code> title is an English language description of the test case that explains the property the test is designed to validate in as much detail as possible. As much as possible, test case descriptions should be self-sufficient.</p> <p>After the attributes table, a TypeScript block of code describes the canonical form of the test. It includes any type declaration that is used by the test (so the code example is self-contained). Assertions performed by the test should be written in the form of [<code>jest</code>] expectations.</p> <p>Question</p> <p>The assertion code is intended as a formal representation of the tests' normative procedure. It is not currently executed against the kernel, but this could be achieved in the future. Additionally, we might be able to automatically transliterate the tests to other languages using [<code>jsii-rosetta</code>].</p> <p>Finally, another code block details the sequence of messages that should be exchanged between the host and <code>node</code> processes during the execution of the test case, such that implementations can assert coherent behavior.</p> <p>Initial messages corresponding to the <code>hello</code> and <code>load</code> calls can be omitted at the beginning of the kernel trace. Those messages are typically identical across tests and there is little value in asserting around those. However, any <code>load</code> call happening after the first call that is neither the <code>hello</code> message or another <code>load</code> call must be included.</p> <p>The dialogue is the sequence of JSON formatted messages, from the perspective of the host app, using the following notation:</p> <ul> <li>Messages sent by the host runtime to the <code>node</code> process:   <pre><code>&gt; { \"api\": \"foo\" }\n</code></pre></li> <li>Messages received by the host runtime from the <code>node</code> process:   <pre><code>&lt; { \"result\": \"bar\" }\n</code></pre></li> <li>Comments to improve readability of the trace:   <pre><code># Comment continues until the end of the line\n</code></pre></li> <li>Blank lines can be added to logically group trace elements</li> </ul> <p>Question</p> <p>Is there a need to support some form of a capture mechanism to provision for non-deterministic results, or non-normative elements such as the exact Object IDs issued for created instances?</p> Show Template <p>Below is the template markdown to copy-paste when introducing a new test case in the compliance suite. New tests should always be added at the very end of the category they belong to, right after the last test in said category.</p> <pre><code>### Test Category\n\n#### Test Case Name\n\nA short english language description of what property this test verifies. The description should include enough detail\nfor a reader to be able to understand the test without having to search for any additional information. Prefer a long,\nunambiguous description to a terse one that could be subject to interpretation.\n\n&lt;details&gt;&lt;summary&gt;Show test&lt;/summary&gt;\n\n##### Reference Implementation\n\n```ts\n// GIVEN\nexport class Foo {\n/* ... */\n}\n\n// WHEN\nconst bar = new Foo().bar();\n\n// THEN\nexpect(bar.baz).toBeUndefined();\n```\n\n##### Reference Kernel Messaging\n\n```\n## You can omit the initial hello/load messages\n# &lt; { \"hello\": \"@jsii/runtime@1.2.3\" }\n# &gt; { \"load\": { \"name\": \"test-case-001\", \"version\": \"1.2.3\", \"tarball\": \"/tmp/jsii-kernel-test/lib.tgz\" } }\n# &lt; { \"assembly\": \"test-case-001\", \"types\": 3 }\n```\n\n&lt;/details&gt;\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#compliance","title":"Compliance","text":"<p>In order to be able to assert compliance of language binding libraries to the standard test suite, implementations are responsible for providing a test harness (typically as part of the runtime library) that can produce a standardized test report in the form of a JSON document that follows the following schema:</p> <pre><code>interface TestReport {\n/** The report is broken down by test category, using the name as-is */\n[category: string]: {\n/** For each test in the category, using its name as-is */\n[test: string]: {\n/** Whether the test passed or failed */\nstatus: 'PASS' | 'FAIL';\n/** The kernel messages captured during the test */\nkernelTrace: Array&lt;KernelMessage&gt;;\n};\n};\n}\n\ninterface KernelMessage {\n/** The direction the message was sent (Host -&gt; Kernel / Kernel -&gt; Host) */\ndirection: 'FromKernel' | 'ToKernel';\n/** The message, as a JSON object */\nmessage: { [key: string]: unknown };\n}\n</code></pre> <p>The <code>@jsii/compliance</code> package provides the necessary tools to consume such a test report, together with the Markdown document describing the compliance suite, and procuces a report describing compliance test coverage as well as information about any non-conformant test result.</p> <p>Unimplemented</p> <p>The <code>@jsii/compliance</code> tool does not exist yet.</p> <p>Question</p> <p>Should a \"somewhat standard\" format such as XUnit test report be used instead of rolling our own JSON document?</p>"},{"location":"specification/4-standard-compliance-suite/#test-suite","title":"Test Suite","text":""},{"location":"specification/4-standard-compliance-suite/#legacy","title":"Legacy","text":"<p>This section is due to contain all compliance tests that were implemented before the jsii specification was initially written. They are going to be gradually replaced by more focused tests with better descriptions.</p>"},{"location":"specification/4-standard-compliance-suite/#type-unions-are-correctly-disambiguated-by-the-kernel","title":"Type Unions are correctly disambiguated by the Kernel","text":"<p>In certain cases, two or more types in a Type Union can overlap in such a way that they are all valid structural types for the value. Statically typed languages however will not be satisfied with structural typing only, and require the correct declared type to be preserved.</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport interface BluePill {\nreadonly offeredTo: string;\nreadonly makesYouForgetTheMatrix?: boolean;\n}\nexport interface RedPill {\nreadonly offeredTo: string;\nreadonly makesYouExitTheMatrix?: boolean;\n}\nexport class Morpheus {\npublic static isBlue(pill: BluePill | RedPill): pill is BluePill {\nconst keys = new Set(Object.keys(pill));\nswitch (keys.size) {\ncase 1:\nreturn keys.has('offeredTo');\ncase 2:\nreturn keys.has('offeredTo') &amp;&amp; keys.has('makesYouForgetTheMatrix');\ndefault:\nreturn false;\n}\n}\npublic static isRed(pill: BluePill | RedPill): pill is RedPill {\nconst keys = new Set(Object.keys(pill));\nswitch (keys.size) {\ncase 1:\nreturn keys.has('offeredTo');\ncase 2:\nreturn keys.has('offeredTo') &amp;&amp; keys.has('makesYouExitTheMatrix');\ndefault:\nreturn false;\n}\n}\nprivate constructor() {}\n}\nexport class Neo {\npublic readonly tookBlue: boolean;\npublic readonly tookRed: boolean;\n\npublic constructor(public readonly pill: BluePill | RedPill) {\nthis.tookBlue = pill.offeredTo == 'Neo' &amp;&amp; Morpheus.isBlue(pill);\nthis.tookRed = pill.offeredTo == 'Neo' &amp;&amp; Morpheus.isRed(pill);\n}\n}\n\n// WHEN\nconst bluePillA = new Neo({ offeredTo: 'not Neo' });\nconst bluePillB = new Neo({ offeredTo: 'Neo', makesYouForgetTheMatrix: true });\nconst redPillA = new Neo({ offeredTo: 'not Neo' });\nconst redPillB = new Neo({ offeredTo: 'Neo', makesYouExitTheMatrix: true });\n\n// THEN\nexpect(bluePillA.pill instanceof BluePill).toBeTruthy();\nexpect(bluePillA.tookBlue).toBeFalsy();\nexpect(bluePillA.tookRed).toBeFalsy();\n\nexpect(bluePillB.pill instanceof BluePill).toBeTruthy();\nexpect(bluePillA.tookBlue).toBeTruthy();\nexpect(bluePillA.tookRed).toBeFalsy();\n\nexpect(redPillA.pill instanceof RedPill).toBeTruthy();\nexpect(bluePillA.tookBlue).toBeFalsy();\nexpect(bluePillA.tookRed).toBeFalsy();\n\nexpect(redPillB.pill instanceof RedPill).toBeTruthy();\nexpect(bluePillA.tookBlue).toBeFalsy();\nexpect(bluePillA.tookRed).toBeTruthy();\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace","title":"Kernel Trace","text":""},{"location":"specification/4-standard-compliance-suite/#partially-initialized-object-consumption","title":"Partially initialized object consumption","text":"<p>When a constructor passes <code>this</code> out from JavaScript to the host app, the reference must be correctly identified and passed across.</p> <p>Unimplemented</p> <p>The .NET Runtime does not currently honor object identity, meaning that despite the same object reference is returned twice, two distinct proxies exist for it in the host .NET app.</p> <p>Generally speaking, using pure object identity on jsii language front-ends is dangerous, as certain statically typed language will require the runtime to have different instances for different static types a given object reference is surfaced as. It may be necessary to introduce a helper akin to <code>Jsii.isSameObject(a, b)</code> to enable identity predicates to be used. Other helper functions may be necessary, too, such as one to obtain a \"consistent\" object hash for instances in Java (so they can be safely used with <code>HashMap</code>, ...).</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_1","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport abstract class PartiallyInitializedThisConsumer {\npublic abstract consumePartiallyInitializedThis(obj: ConstructorPassesThisOut): void;\n}\nexport class ConstructorPassesThisOut {\npublic constructor(consumer: PartiallyInitializedThisConsumer) {\nconsumer.consumePartiallyInitializedThis(this);\n}\n}\n\n// WHEN\nclass MyConsumer extends PartiallyInitializedThisConsumer {\npublic obj?: ConstructorPassesThisOut = null;\n\npublic consumePartiallyInitializedThis(obj: ConstructorPassesThisOut) {\nthis.obj = obj;\n}\n}\nconst consumer = new MyConsumer();\nconst object = new ConstructorPassesThisOut(consumer);\n\n// THEN\nexpect(consumer.obj).toBe(object);\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_1","title":"Kernel Trace","text":"<pre><code># &lt; {\"hello\":\"@jsii/runtime@...\"}\n# &gt; {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"}\n# &lt; {\"ok\":{\"assembly\":\"...\",\"types\":2}}\n\n&gt; {\"api\":\"create\",\"fqn\":\"test.PartiallyInitializedThisConsumer\",\"args\":[],\"overrides\":[{\"method\":\"consumePartiallyInitializedThis\"}],\"interfaces\":[]}\n&lt; {\"ok\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"}}\n&gt; {\"api\":\"create\",\"fqn\":\"test.ConstructorPassesThisOut\",\"args\":[{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]}\n&lt; {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"},\"method\":\"consumePartiallyInitializedThis\",\"args\":[{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}]}}}\n&gt; {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\"}}\n&lt; {\"ok\":{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#interfaces","title":"Interfaces","text":"<p>Tests in this section ensure correct behavior of behavioral interfaces.</p>"},{"location":"specification/4-standard-compliance-suite/#host-app-can-implement-an-interface-from-scratch","title":"Host app can implement an interface \"from scratch\"","text":"<p>It is possible for a \"pure\" host interface implementation to be passed across the language boundary, it's methods and properties can be used by JavaScript code within the Kernel process.</p> <p>Bug</p> <p>The .NET Runtime currently requires that pure interfaces implementations extend from <code>Amazon.JSII.Rutime.Deputy.DepytyBase</code>.</p> <p>Bug</p> <p>The Python Runtime currently expects a somewhat un-pythonic way to implement interfaces, which requires decorating the implementing class with <code>@jsii.implements(\"implemented-type.JsiiInterfaceFQN\")</code>.</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_2","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport interface IBehavioralInterface {\nmethodCall(): string;\nreadonly property: number;\n}\nexport class InterfaceConsumer {\nconstructor(private readonly iface: IBehavioralInterface) {}\n\npublic composeResult() {\nreturn `${this.iface.methodCall()} / ${this.iface.property}`;\n}\n}\n\n// WHEN\nclass Implementation implements IBehavioralInterface {\npublic readonly property = 1337;\npublic methodCall() {\nreturn 'Hello!';\n}\n}\nconst impl = new Implementation();\nconst consumer = new InterfaceConsumer(impl);\n\n// THEN\nexpect(consumer.composeResult()).toBe('Hello! / 1337');\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_2","title":"Kernel Trace","text":"<pre><code># &lt; {\"hello\":\"@jsii/runtime@...\"}\n# &gt; {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"}\n# &lt; {\"ok\":{\"assembly\":\"...\",\"types\":2}}\n\n&gt; {\"api\":\"create\",\"fqn\":\"Object\",\"args\":[],\"overrides\":[{\"method\":\"methodCall\"},{\"property\":\"property\"}],\"interfaces\":[\"test.IBehavioralInterface\"]}\n&lt; {\"ok\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]}}\n&gt; {\"api\":\"create\",\"fqn\":\"test.InterfaceConsumer\",\"args\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]}\n&lt; {\"ok\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"}}\n&gt; {\"api\":\"invoke\",\"objref\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"},\"method\":\"composeResult\",\"args\":[]}\n&lt; {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"method\":\"methodCall\",\"args\":[]}}}\n&gt; {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\",\"result\":\"Hello!\"}}\n&lt; {\"callback\":{\"cbid\":\"jsii::callback::20001\",\"get\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"property\":\"property\"}}}\n&gt; {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20001\",\"result\":1337.0}}\n&lt; {\"ok\":{\"result\":\"Hello! / 1337\"}}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#structs-keyword-arguments","title":"Structs &amp; Keyword Arguments","text":""},{"location":"specification/4-standard-compliance-suite/#ambiguous-arguments-are-handled-correctly","title":"Ambiguous arguments are handled correctly","text":"<p>When a method accepts both a positional parameter named <code>foo</code> and a struct parameter with a property named <code>foo</code>, the respective values are passed in the correct parameter location when calling into the JavaScript code.</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_3","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport interface StructType {\nreadonly foo: string;\n}\nexport class ClassType {\npublic constructor(public readonly foo: number, public readonly opts: StructType) {}\n}\n\n// WHEN\nvar result = new ClassType('Bazinga!', { foo: 1337 });\n\n// THEN\nexpect(typeof result.foo).toBe(1337);\nexpect(typeof result.opts.foo).toBe('Bazinga!');\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_3","title":"Kernel Trace","text":"<pre><code># &lt; {\"hello\":\"@jsii/runtime@...\"}\n# &gt; {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"}\n# &lt; {\"ok\":{\"assembly\":\"...\",\"types\":2}}\n\n&gt; {\"api\":\"create\",\"fqn\":\"test.ClassType\",\"args\":[1337.0,{\"$jsii.struct\":{\"fqn\":\"test.StructType\",\"data\":{\"foo\":\"Bazinga!\"}}}],\"overrides\":[],\"interfaces\":[]}\n&lt; {\"ok\":{\"$jsii.byref\":\"test.ClassType@10000\"}}\n&gt; {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"foo\"}\n&lt; {\"ok\":{\"value\":1337}}\n&gt; {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"opts\"}\n&lt; {\"ok\":{\"value\":{\"$jsii.byref\":\"Object@10001\",\"$jsii.interfaces\":[\"test.StructType\"]}}}\n&gt; {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"Object@10001\"},\"property\":\"foo\"}\n&lt; {\"ok\":{\"value\":\"Bazinga!\"}}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#collections","title":"Collections","text":"<p>Tests in this section ensure correct behavior of collections (<code>List</code> and <code>Map</code>).</p>"},{"location":"specification/4-standard-compliance-suite/#struct-elements-of-list-are-deserialized-to-the-correct-apparent-type","title":"Struct elements of <code>List</code> are deserialized to the correct apparent type","text":"<p>When the declared element type of a <code>List</code> is a struct, the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified.</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_4","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport interface StructType {\nreadonly property: string;\n}\nexport class StructProvider {\npublic static provide(): StructType[] {\nreturn [{ property: 'value' }];\n}\n}\n\n// WHEN\nconst items = StructProvider.provide();\n\n// THEN\nexpect(items.length).toBeGreaterThan(0);\nfor (const item of items) {\nexpect(item instanceof StructType).toBeTruthy();\n}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_4","title":"Kernel Trace","text":"<pre><code># &lt; {\"hello\":\"@jsii/runtime@...\"}\n# &gt; {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"}\n# &lt; {\"ok\":{\"assembly\":\"...\",\"types\":2}}\n\n&gt; {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]}\n&lt; {\"ok\":{\"result\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}]}}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#struct-elements-of-map-are-deserialized-to-the-correct-apparent-type","title":"Struct elements of <code>Map</code> are deserialized to the correct apparent type","text":"<p>When the declared element type of a <code>Map</code> is a struct, the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified.</p> Show test"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_5","title":"Reference Implementation","text":"<pre><code>// GIVEN\nexport interface StructType {\nreadonly property: string;\n}\nexport class StructProvider {\npublic static provide(): { [key: string]: StructType } {\nreturn { foo: { property: 'value' } };\n}\n}\n\n// WHEN\nconst items = StructProvider.provide();\n\n// THEN\nexpect(items.length).toBeGreaterThan(0);\nfor (const item of Object.values(items)) {\nexpect(item instanceof StructType).toBeTruthy();\n}\n</code></pre>"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_5","title":"Kernel Trace","text":"<pre><code># &lt; {\"hello\":\"@jsii/runtime@...\"}\n# &gt; {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"}\n# &lt; {\"ok\":{\"assembly\":\"...\",\"types\":2}}\n\n&gt; {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]}\n&lt; {\"ok\":{\"result\":{\"$jsii.map\":{\"foo\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}}}}}\n</code></pre>"},{"location":"specification/5-new-language-intake/","title":"New Language Intake","text":"<p>This document outlines the process to be followed when introducing a new jsii target language, including an estimated timeline (the exact timeline may vary significantly depending on the specifics of the language being added).</p> <p>The estimated total duration for the process is 4 to 6 months.</p>"},{"location":"specification/5-new-language-intake/#planning","title":"Planning","text":"<p> Estimated Duration: 2 weeks</p> <p>The first step is to study the jsii specification, as well as existing language implementations, in order to have the knowledge necessary to write a new language support proposal RFC. The RFC document produced will evolve and be polished as development of the new language support progresses, but the following elements must be present before any implementation begins:</p> <ul> <li>Identification of the language's standard package repository</li> <li>Proposal for the binding's configuration block</li> <li>Sample API representations in the proposed language</li> <li>In particular, any element from the jsii type model that does not naturally map into the proposed new language     needs to be represented</li> <li>Where several options exist, links to prior art are instrumental to validate the direction chosen</li> <li>Toolchain and platform requirements</li> </ul>"},{"location":"specification/5-new-language-intake/#code-generation-jsii-pacmak","title":"Code Generation (<code>jsii-pacmak</code>)","text":"<p> Estimated Duration: 4 to 6 weeks</p> <p>The necessary code must be added to [<code>jsii-pacmak</code>] in order to map the jsii assembly's declared types into the proposed language. While this code ought to leverage the new language's host runtime library, we begin with writing the code generator in order to ensure the appropriate developer experience is achieved in the new language before writing the back-end components.</p> <p>Code generators are authored in TypeScript.</p> <p>The necessary reserved words need to be registered in the <code>jsii</code> compiler, so that warnings are produced when identifiers are used in TypeScript code that require slugification or escaping in the target language (and will hence cause a degraded developer experience).</p>"},{"location":"specification/5-new-language-intake/#runtime-library","title":"Runtime Library","text":"<p> Estimated Duration: 4 to 6 weeks</p> <p>Now that the appropriate developer experience has been identified, the host runtime library supporting the generated code can be written. This component must be written in the new language.</p> <p>Unimplemented</p> <p>A reference architecture for host runtime libraries is to be developed, in order to ensure consistent naming and behavior across all the runtimes, reducing the cost of maintaining many of those.</p>"},{"location":"specification/5-new-language-intake/#building-packaging","title":"Building &amp; Packaging","text":"<p> Estimated Duration: 2 weeks</p> <p>Once code is generated and it has a host runtime library to rely on, [<code>jsii-pacmak</code>] needs to receive the additional logic required to compile and package the generated libraries as required, producing ready-to-publish artifacts.</p> <p>The necessary toolchain needs to be added to the [<code>jsii/superchain</code>] Docker image, so that <code>jsii</code> customers can rely on this to build artifacts for any of the supported languages.</p> <p>In addition to this, standardized Amazon CodePipeline actions need to be developed in order to support publishing to the relevant idiomatic package managers.</p>"},{"location":"specification/5-new-language-intake/#compliance-tests","title":"Compliance Tests","text":"<p> Estimated Duration: 6 weeks</p> <p>The full standard compliance suite must be implemented for the new language. Leveraging the new code generator, host runtime library and compilation logic, the tests demonstrate that the new library behaves consistently with all other language bindings.</p> <p>While it is possible to declare developer preview on a new language before all the tests pass, full compliance is a pre-requisite to declaring general availability of the new language.</p>"},{"location":"specification/5-new-language-intake/#documentation","title":"Documentation","text":"<p> Estimated Duration: 1 week</p> <p>The necessary documentation needs to be provided to support customers who want to onboard the new language. This also includes updating [<code>jsii-config</code>] with support for the new languages' configuration block.</p>"},{"location":"specification/5-new-language-intake/#developer-preview","title":"Developer Preview","text":"<p> Recommended Duration: 4 to 8 weeks</p> <p>It is possible to declare Developer Preview for a new language support as soon as the code generation and host runtime library are mature enough to be useful, and cover the majority of use-cases. While certain edge-cases may still be uncovered at the beginning of Developer Preview, a clear plan should exist that ensures a path exists to address any known gaps. It is required to have implemented most of the standard compliance suite prior to declaring Developer Preview.</p> <p>During the Developer Preview phase, user experience studies should be conducted to validate assumptions made during the code generator's design. If any significant change is dictated by the results of the user experience studies, fluback studies should be performed in order to confirm that the desired impact has been achieved.</p> <p>Unimplemented</p> <p>A standard set of user experience study tasks will be developed, ensuring the learnings from previous experiences is factored into subsequent studies conducted.</p> <p>Finally, it is essential to give time to the community to use and vet the new language support prior to considering General Availability. A minimum of a full month without a major bug reported is advised. During this period, intentional hands-on usage of the product msut be performed by engineers familiar with the new language as well as engineers unfamilar with it. This ensures the new experience is considered holistically, in a manner unbiased by knowledge of the implementation.</p>"},{"location":"specification/5-new-language-intake/#general-availability","title":"General Availability","text":"<p>Once the new language support has been Developer Preview for long enough and the engineers involved have gained confidence that the API is stable, covers all known use-cases reliably, and behaves consistently with other Generally Available languages, the new support can be considered for General Availability.</p>"},{"location":"specification/6-compliance-report/","title":"Compliance Report","text":""},{"location":"specification/6-compliance-report/#compliance-report","title":"Compliance Report","text":"<p>This section details the current state of each language binding with respect to our standard compliance suite.</p> number test java (97.56%) golang (78.86%) Dotnet Python 1 asyncOverrides_overrideCallsSuper \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 2 arrayReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 3 unionProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 4 syncOverrides \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 5 useEnumFromScopedModule \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 6 createObjectAndCtorOverloads \ud83d\udfe2 \u26aa \u2b55 \u2b55 7 fail_syncOverrides_callsDoubleAsync_method \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 8 collectionOfInterfaces_MapOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 9 asyncOverrides_overrideAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 10 statics \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 11 structs_returnedLiteralEqualsNativeBuilt \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 12 classesCanSelfReferenceDuringClassInitialization \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 13 canObtainStructReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 14 callbacksCorrectlyDeserializeArguments \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 15 canUseInterfaceSetters \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 16 propertyOverrides_interfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 17 syncOverrides_callsSuper \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 18 testJsiiAgent \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 19 doNotOverridePrivates_method_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 20 pureInterfacesCanBeUsedTransparently \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 21 nullShouldBeTreatedAsUndefined \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 22 primitiveTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 23 reservedKeywordsAreSlugifiedInClassProperties \ud83d\udfe2 \u26aa \u2b55 \u2b55 24 objectIdDoesNotGetReallocatedWhenTheConstructorPassesThisOut \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 25 interfaceBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 26 unionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 27 arrays \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 28 staticMapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 29 consts \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 30 pureInterfacesCanBeUsedTransparently_WhenTransitivelyImplementing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 31 reservedKeywordsAreSlugifiedInMethodNames \ud83d\udfe2 \u26aa \u2b55 \u2b55 32 exceptions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 33 testLiteralInterface \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 34 structs_nonOptionalhashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 35 propertyOverrides_set_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 36 canLeverageIndirectInterfacePolymorphism \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 37 fluentApi \ud83d\udfe2 \u26aa \u2b55 \u2b55 38 staticListInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 39 mapReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 40 receiveInstanceOfPrivateClass \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 41 staticMapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 42 testNativeObjectsWithInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 43 doNotOverridePrivates_property_getter_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 44 equalsIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 45 listInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 46 useNestedStruct \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 47 testFluentApiWithDerivedClasses \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 48 interfacesCanBeUsedTransparently_WhenAddedToJsiiType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 49 canOverrideProtectedGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 50 getAndSetEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 51 structs_nonOptionalequals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 52 testInterfaceParameter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 53 liftedKwargWithSameNameAsPositionalArg \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 54 creationOfNativeObjectsFromJavaScriptObjects \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 55 canOverrideProtectedMethod \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 56 canLoadEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 57 eraseUnsetDataValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 58 maps \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 59 structs_containsNullChecks \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 60 canOverrideProtectedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 61 asyncOverrides_callAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 62 nodeStandardLibrary \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 63 dates \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 64 collectionOfInterfaces_ListOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 65 objRefsAreLabelledUsingWithTheMostCorrectType \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 66 unionPropertiesWithBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 67 doNotOverridePrivates_property_getter_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 68 structs_withDiamondInheritance_correctlyDedupeProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 69 abstractMembersAreCorrectlyHandled \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 70 doNotOverridePrivates_property_by_name_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 71 testNullIsAValidOptionalMap \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 72 mapReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 73 structs_multiplePropertiesEquals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 74 mapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 75 staticListInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 76 collectionOfInterfaces_MapOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 77 asyncOverrides_overrideThrows \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 78 callMethods \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 79 returnAbstract \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 80 dynamicTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 81 hashCodeIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \u26aa \u2b55 \u2b55 82 returnSubclassThatImplementsInterface976 \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 83 structs_optionalEquals \ud83d\udfe2 \u26aa \u2b55 \u2b55 84 propertyOverrides_get_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 85 unmarshallIntoAbstractType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 86 structs_multiplePropertiesHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 87 fail_syncOverrides_callsDoubleAsync_propertyGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 88 propertyOverrides_get_set \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 89 variadicMethodCanBeInvoked \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 90 collectionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 91 asyncOverrides_overrideAsyncMethodByParentClass \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 92 structs_optionalHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 93 testStructsCanBeDowncastedToParentType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 94 propertyOverrides_get_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 95 getSetPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 96 getAndSetNonPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 97 reservedKeywordsAreSlugifiedInStructProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 98 fail_syncOverrides_callsDoubleAsync_propertySetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 99 doNotOverridePrivates_method_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 100 testNullIsAValidOptionalList \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 101 mapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 102 doNotOverridePrivates_property_by_name_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 103 asyncOverrides_twoOverrides \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 104 propertyOverrides_set_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 105 iso8601DoesNotDeserializeToDate \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 106 collectionOfInterfaces_ListOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 107 undefinedAndNull \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 108 structs_serializeToJsii \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 109 structsAreUndecoratedOntheWayToKernel \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 110 canObtainReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 111 testJSObjectLiteralToNative \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 112 structs_stepBuilders \ud83d\udfe2 \u26aa \u2b55 \u2b55 113 classWithPrivateConstructorAndAutomaticProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 114 arrayReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 115 correctlyDeserializesStructUnions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 116 subclassing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 117 testInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 118 callbackParameterIsInterface \u2b55 \ud83d\udfe2 \u2b55 \u2b55 119 classCanBeUsedWhenNotExpressedlyLoaded \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 120 downcasting \u2b55 \ud83d\udfe2 \u2b55 \u2b55 121 strippedDeprecatedMemberCanBeReceived \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 122 exceptionMessage \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 123 voidReturningAsync \u2b55 \u2b55 \u2b55 \u2b55"},{"location":"user-guides/","title":"Introduction","text":"<p>This section of the jsii reference contains user-guides for different audiences. The below sections provide an overview of each section.</p>"},{"location":"user-guides/#library-author-guide","title":"Library author guide","text":"<p>The library author guide provides information to developers who want to use the jsii toolchain to author libraries that will be usable from all supported programming languages.</p> <p>It contains important information on TypeScript restrictions, as well as the language binding configuration reference.</p>"},{"location":"user-guides/#library-consumer-guide","title":"Library consumer guide","text":"<p>The library consumer guide provides specific information intended for developers leveraging libraries generated by the jsii toolchain. In particular, it provides guidance for how to correctly use those libraries, in cases where the generated bindings are somewhat non-idiomatic.</p>"},{"location":"user-guides/#language-implementation-guide","title":"Language implementation guide","text":"<p>The language implementation guide provides information to developers who are interested in contributing support for a new language in the jsii toolchain.</p>"},{"location":"user-guides/language-support/","title":"Language Implementation","text":"<p>This handbook provides an overview of the process that should be followed when looking to implement support for a new programming language in jsii. It attempts to provide a step-by-step procedure, while drawing the reader's attention on points that have been found to cause problems in the past.</p>"},{"location":"user-guides/language-support/#foreword","title":"Foreword","text":"<p>Implementing a new language in jsii is not just a matter of implementing code generation. Mapping the jsii type system to a new programming language means finding how to represent an API originally designed in TypeScript to a form that is as idiomatic as possible in the new language. This is a craft that often requires trial and error, and the best (if not only) way to validate a proposal is to put it in front of users and seek feedback. As a consequence, this endeavor should be expected to span months, not weeks.</p>"},{"location":"user-guides/language-support/#scoping-planning","title":"Scoping &amp; Planning","text":"<p>The first step of most successful projects is to start by scoping work out and establishing a baseline plan to execute on. For contributors not yet familiar with jsii, the specification document is a great place to start. In particular, the New Language Intake document provides a high-level view of the recommended process for implementing new language support.</p> <p>The work of implementing support for a new language involves many different components:</p> <ul> <li>The [<code>jsii</code>] compiler emits warnings when a language's reserved words are used to name types, methods or properties;   as this will later require slugification or escaping in the generated code - usually resulting in a degraded developer   experience.</li> <li>The [<code>jsii-pacmak</code>] tool includes code generators for all supported languages, and a new implementation must be   provided for the new language.</li> <li>Code generation usually requires specific configuration to be provided in order to be able to generate valid packages   (for example, the Java code generator requires a base java package to generate into, as well as a Maven group and   artifact ID for the package). The [<code>jsii-config</code>] tool needs to be updated with support generating a configuration   block with the required entries for the new code generator.</li> <li>[<code>jsii-rosetta</code>] tool translates TypeScript example code found in the original documentation into the new target   language. A new translation implementation needs to be added for the new language.</li> <li>Building and publishing infrastructure elements are provided by [<code>aws-delivlib</code>] to make it easier for jsii users to   publish their libraries to all supported package registries.</li> </ul>"},{"location":"user-guides/language-support/#language-proposition-rfc","title":"Language Proposition RFC","text":"<p>The recommended way to formalize the initial plan is to write it into an RFC hosted in the CDK RFC repository. Enough time has to be spent considering the requirements in order to get the work scoped and planned well, ensuring smooth execution.</p> <p>An additional benefit of following the RFC process is that it makes it easier to track learnings accumulated through the implementation process, as those will be tracked as comments or iterations on the RFC document.</p> <p>It is possible (and sometimes desirable) to start prototyping code-generation for the new language, as this can highlight implementation challenges that need to be discussed in the RFC document. In any case, examples of the API signatures that are expected to be rendered allow early feedback to be provided by possible future users, and still helps identify challenges.</p> <p>The following questions should be answered as early as possible in the process, to avoid surprises later on that result in significant re-engineering effort:</p> <ul> <li>What do the generated APIs look like, for the typical API idioms?</li> <li>Classes (constructors, properties, methods, inheritance strategy, abstract members, ...)<ul> <li>The AWS CDK (one of the main consumers of jsii) uses specific patterns to offer a better experience in many   programming languages. For example, constructor signatures where the last argument is a jsii struct allows for   keyword argument lifting in Python, and convenient <code>Builder</code> APIs in Java.</li> </ul> </li> <li>Enums</li> <li>Interfaces and Structs (properties, methods, inheritance strategy, implementation, ...). In particular, how are     new optional properties handled (those are not considered breaking change within the jsii type system).</li> <li>Structs (properties, inheritance strategy, implementation, ...)</li> <li>What information is needed in order for the code-generator to produce artifacts? What should the configuration block   look like?</li> <li>What is the standard way to publish packages for the new language?</li> <li>Are there any requirements (code signature, special metadata, ...) that need to be implemented in order to publish     valid packages?</li> <li>How are dependencies modeled? If semantic versioning is not the norm, what is the strategy to correctly represent     semantic version ranges?</li> <li>What are the toolchain and platform requirements?</li> <li>For example, Java requires an OpenJDK 8 distribution and <code>maven</code>, Python requires <code>python</code> 3.7 or above,     etc...</li> </ul>"},{"location":"user-guides/language-support/#code-generation","title":"Code Generation","text":"<p>First, implement a first version of the code generation for the new language before getting too far into the host library implementation. This top-down approach ensures the requirements for the lower level parts of the implementation are well-defined before they are implemented (reducing the chances that significant re-work has to be done), and enables using the Standard Compliance Suite to ensure the overall implementation is correct according to the specification (since the code necessary to implement the test cases will be available right from the start).</p> <p>This work happens within the [<code>jsii-pacmak</code>] package.</p> <p>Focus initially on the API signatures before getting into their implementation. The first version may even throw a not implemented exception when called.</p> <p>The [<code>jsii-calc</code>] package, can be used as a sample consuming library which uses jsii to generate code in all target languages. Start by making sure a decent API is generated from this package and its dependencies, and use those to implement the tests from the Standard Compliance Suite. You'll also get a feeling for whether the generated code achieves a good developer experience or not.</p>"},{"location":"user-guides/language-support/#host-library","title":"Host Library","text":"<p>Now that we are generating \"empty shell\" APIs that represent the necessary entities to back the Standard Compliance Suite tests, start implementing the host library and update the code generator until all the tests pass. It is possible to publish artifacts even when tests in the suite are failing. As soon as basic features are working, work on Building and Packaging can start, so early feedback can be gathered.</p> <p>Unimplemented</p> <p>A standard architecture for the host library has not been documented yet. Upcoming language implementations should contribute to this process by documenting a general architecture that should be implementable in any programming languages (and thus, abstracting away language specificities).</p>"},{"location":"user-guides/language-support/#building-packaging","title":"Building &amp; Packaging","text":"<p>The necessary toolchains should be added to he [<code>jsii/superchain</code>] Docker image, so that the [<code>jsii-pacmak</code>] generation can be changed to support building ready to publish artifacts instead of just code.</p> <p>Before publishing any artifacts, ensure all packages (the host library as well as generated artifacts) are designated as experimental (e.g: Python packages were annotated with the <code>Development Status :: 4 - Beta</code> trove classifier on PyPI, and NuGet packages were published with a pre-release version such as <code>1.2.3-pre</code>).</p> <p>Additionally, [<code>aws-delivlib</code>] needs to be augmented to support publishing artifacts to the language's package repository.</p> <p>Unimplemented</p> <p>The package publishing is being extracted from [<code>aws-delivlib</code>] into a standalone library, currently hosted at <code>eladb/jsii-release</code>.</p>"},{"location":"user-guides/language-support/#documentation","title":"Documentation","text":"<p>Before releasing the new language support to Developer Preview, basic documentation needs to be produced to explain how to configure a jsii project to support the new language, and any peculiarities in working with libraries generated by [<code>jsii-pacmak</code>] for this language.</p> <p>Support for example code translation should also be built into [<code>jsii-rosetta</code>].</p>"},{"location":"user-guides/language-support/#developer-preview","title":"Developer Preview","text":"<p>Once the full Standard Compliance Suite passes (possibly with the exception of certain fringy features), and the documentation covering all aspects of using the language bindings have been produced, the new language can be released to Developer Preview.</p> <p>It is recommended that new languages stay in Developer Preview for a minimum of 4 weeks, ideally until they have received sufficient usage to have built confidence that there are no major usability concerns: once out of Developer Preview, it will no longer be possible to introduce breaking changes to the generated code in order to address usability issues or bugs.</p> <p>In order to improve the chances of catching usability issues, focused user experience studies will be conducted with an audience composed of developers with varied degrees of experience with the new language.</p> <p>Unimplemented</p> <p>A user experience template will be provided to ensure coverage of critical aspects of the experience. Any critical user experience issue (for example, issues that required breaking changes to the generated code) discovered but not covered in the template should be added to the template so that subsequent language implementations do not fall to the same problem.</p>"},{"location":"user-guides/language-support/#general-availability","title":"General Availability","text":"<p>Once the new language has been in Developer Preview without any significant usability issues or bugs for a sufficient amount of time and is used in real-world use-cases such as for AWS CDK applications, it becomes a candidate to be declared Generally Available. At this point, breaking changes are no longer possible on the generated code.</p>"},{"location":"user-guides/language-support/assembly/","title":"<code>.jsii</code> Assemblies","text":"<p>This document describes the contents of the <code>.jsii</code> assembly documents generated by the <code>jsii</code> compiler, and explains the semantics behind the various entities it represents. This serves as a reference for front-end language implementors.</p>"},{"location":"user-guides/language-support/assembly/#schema","title":"Schema","text":"<p><code>.jsii</code> assemblies are JSON-formatted documents. The specification is hosted under the <code>jsii-spec</code> package. Refer to the inline documentation in the <code>spec.ts</code> file for more information about the general content of the assembly documents.</p> <p>The most important part of the assembly documentation, which is described in detail in this document, is the <code>types</code> map, which contains the descriptions of all types declared by the <code>.jsii</code> assembly. It is a map from <code>jsii</code> fully- qualified type names to a type specification.</p> <p>All <code>boolean</code> attributes in the document specification are optional, and are left out (<code>undefined</code>) when <code>false</code>.</p>"},{"location":"user-guides/language-support/assembly/#common-attributes","title":"Common Attributes","text":"<p>Certain optional attributes are shared by API entities (types and members):</p> <ul> <li><code>docs</code> - documentation attached to the API entity</li> <li><code>deprecated</code> - contains a message explaining why an API was deprecated and/or how users should migrate away</li> <li><code>stability</code> - the stability level of the API entity. The ultimate meaning of the stability level is up to the     package maintainer, but a baseline interpretation of the valid values follows:<ul> <li><code>experimental</code> denotes an API that is actively worked on and are not subject to semantic versioning gurantees   (they may receive breaking change on a minor version release)</li> <li><code>stable</code> denotes an API that is safe to use in production systems and are subject ot semantic versioning   guarantees (they may not receive breaking changes without a major version bump)</li> <li><code>deprecated</code> denotes an API that should no longer be used. The <code>deprecated</code> entry in the <code>docs</code> object should   contain a message explaining how users should migrate away</li> <li><code>external</code> denotes an API that is not owned by the package's maintainer and may change in unexpected ways. Such   APIs are usually derived from external artifacts, which the package maintainers do not have control over.</li> </ul> </li> <li>additional entries represent user-defined <code>JSDoc</code> tags with meaning defined by convention and/or the package     maintainer</li> <li><code>locationInModule</code> - coordinates of the declaration in the source</li> <li><code>fileName</code> - the path to the source file, relative to the package root</li> <li><code>line</code> - the line number on which the entity is declared (or the first line when a declaration spans multiple lines)</li> </ul>"},{"location":"user-guides/language-support/assembly/#types","title":"Types","text":""},{"location":"user-guides/language-support/assembly/#classes","title":"Classes","text":"Attribute Type Description <code>kind</code> <code>'class'</code> Discriminator to identify classes <code>abstract</code> <code>boolean</code> Whether this class is abstract <code>assembly</code> <code>string</code> The name of the assembly this class is a part of <code>base</code> <code>string</code> The fully-qualified name of the parent class of this class <code>fqn</code> <code>string</code> The fully-qualified name of the class <code>initializer</code> <code>Constructor</code> The class' constructor <code>interfaces</code> <code>string[]</code> The fully-qualified names of interfaces implemented by this class <code>methods</code> <code>Method[]</code> The methods declared by this class <code>name</code> <code>string</code> The simple name of the class <code>properties</code> <code>Property[]</code> The properties declared by this class"},{"location":"user-guides/language-support/assembly/#interfaces","title":"Interfaces","text":"<p><code>jsii</code> interfaces are declarations of type signatures that can be implemented by classes. Interface names must be prefixed with an <code>I</code> (e.g: <code>IFoo</code>).</p> Attribute Type Description <code>kind</code> <code>'interface'</code> Discriminator to identify interfaces <code>assembly</code> <code>string</code> The name of the assembly this interface is a part of <code>fqn</code> <code>string</code> The fully-qualified name of the interface <code>interfaces</code> <code>string[]</code> The fully-qualified names of interfaces extended by this interface <code>methods</code> <code>Method[]</code> The methods declared by this interface <code>name</code> <code>string</code> The simple name of the interface <code>properties</code> <code>Property[]</code> The properties declared by this interface"},{"location":"user-guides/language-support/assembly/#structs-aka-data-types","title":"Structs (a.k.a. Data Types)","text":"<p>Structs (or Data Types) are immutable, data-only interfaces:</p> <ul> <li>They declare no methods</li> <li>All properties they declare are <code>readonly</code></li> <li>They can only implement other structs</li> <li>They cannot be extended by interfaces that are not structs</li> <li>They cannot be implemented by classes</li> </ul> <p>Unlike regular interfaces, <code>jsii</code> struct names are not required to have any particular prefix.</p> <p>Since those are immutable, pure data objects, the <code>jsii-runtime</code> exchanges instances of those by value, instead of by reference, allowing to save cross-language communication overhead when working with the data.</p> Attribute Type Description <code>kind</code> <code>'interface'</code> Discriminator to identify interfaces <code>datatype</code> <code>true</code> Indicates a struct / data type declaration <code>assembly</code> <code>string</code> The name of the assembly this struct is a part of <code>fqn</code> <code>string</code> The fully-qualified name of the struct <code>interfaces</code> <code>string[]</code> The fully-qualified names of struct extended by this struct <code>name</code> <code>string</code> The simple name of the struct <code>properties</code> <code>Property[]</code> The properties declared by this struct (all <code>readonly</code>)"},{"location":"user-guides/language-support/assembly/#enums","title":"Enums","text":"Attribute Type Description <code>kind</code> <code>'enum'</code> Discriminator to identify enums <code>assembly</code> <code>string</code> The name of the assembly this enum is a part of <code>fqn</code> <code>string</code> The fully-qualified name of the enum <code>members</code> <code>EnumMember[]</code> The enum members declared by this enum <code>name</code> <code>string</code> The simple name of the enum"},{"location":"user-guides/language-support/assembly/#members","title":"Members","text":""},{"location":"user-guides/language-support/assembly/#constructors","title":"Constructors","text":"Attribute Type Description <code>overrides</code> <code>string</code> The fully-qualified name of the class/interface that declares the overridden constructor <code>parameters</code> <code>Parameter[]</code> Parameters of this constructor <code>protected</code> <code>boolean</code> Whether this constructor is protected <code>variadic</code> <code>boolean</code> Whether the last parameter is <code>variadic</code>"},{"location":"user-guides/language-support/assembly/#enum-members","title":"Enum Members","text":"Attribute Type Description <code>name</code> <code>string</code> The name of the enum member. Must be <code>UPPER_SNAKE_CASED</code>"},{"location":"user-guides/language-support/assembly/#methods","title":"Methods","text":"Attribute Type Description <code>abstract</code> <code>boolean</code> Whether this method is <code>abstract</code> <code>async</code> <code>boolean</code> Whether this method is asynchronous <code>name</code> <code>string</code> The name of the method <code>overrides</code> <code>string</code> The fully-qualified name of the class/interface that declares the overridden method <code>parameters</code> <code>Parameter[]</code> Parameters of this method <code>protected</code> <code>boolean</code> Whether this method is protected <code>returns</code> <code>OptionalValue</code> The return type of the method <code>static</code> <code>boolean</code> Whether this method is <code>static</code> <code>variadic</code> <code>boolean</code> Whether the last parameter is <code>variadic</code> <p>Methods with the <code>abstract</code> feature may only be members of <code>abstract</code> classes or interfaces, and all methods that are members of interfaces must be <code>abstract</code>.</p> <p>Methods that are <code>static</code> cannot feature the <code>overrides</code> attribute, as <code>static</code> members are not inherited.</p>"},{"location":"user-guides/language-support/assembly/#properties","title":"Properties","text":"Attribute Type Description <code>abstract</code> <code>boolean</code> Whether this property is <code>abstract</code> <code>const</code> <code>boolean</code> Whether this property is a constant (implies <code>static</code> and <code>immutable</code>) <code>immutable</code> <code>boolean</code> Whether this property is immutable <code>name</code> <code>string</code> The name of the property <code>optional</code> <code>boolean</code> Whether this property is optional <code>overrides</code> <code>string</code> The fully-qualified name of the class/interface that declares the overridden property <code>protected</code> <code>boolean</code> Whether this constructor is protected <code>static</code> <code>boolean</code> Whether this property is <code>static</code> <code>type</code> <code>TypeReference</code> The type of the property <p>Properties that are <code>const</code> must have a <code>name</code> that is <code>UPPER_SNAKE_CASED</code>. They represent constants similar to Enum Members, which can be proactively resolved by the <code>jsii</code> runtimes.</p> <p>Danger</p> <p>Properties and methods that are <code>static</code> can feature the <code>overrides</code> attribute, as <code>static</code> members are inherited with the prototype in JavaScript (as part of the ES6 specification). Not all target languages have this capability (most, like C# and Java, only support hiding static declarations), and consequently code generators may ignore this (or explicitly hide parent declarations) instead.</p>"},{"location":"user-guides/language-support/callbacks/","title":"Callbacks and Overrides","text":"<p>This document provides a high-level overview of the mechanisms used by jsii to allow foreign code to override JavaScript methods. It details the responsibilities of the jsii kernel and of the foreign library, and provides implementation guidelines.</p>"},{"location":"user-guides/language-support/callbacks/#identifying-overrides","title":"Identifying Overrides","text":"<p>The jsii kernel allows foreign code to register overrides for the following use-cases:</p> <ul> <li>Overriding a class' non-static member</li> <li>Implementing an abstract member (including interface members)</li> </ul> <p>Info</p> <p>It is possible for foreign code to override a class' constructor, but those cannot be registered in the jsii kernel as it cannot trigger instantiation of a foreign class directly. Foreign constructors always delegate to the JavaScript constructor, which is happens via the <code>create</code> operation, during which overrides are registered.</p> <p>All cases where foreign code should be executed in lieu of JavaScript code must be identified and declared properly, as the jsii kernel otherwise has no way to determine a foreign implementation exists.</p> <p>Where possible, the jsii runtime library for the foreign language will use reflection APIs to transparently discover which API elements are overridden or implemented. In cases where reflection is expensive, the jsii runtime library will try to cache findings as appropriate in order to avoid duplication of this effort.</p> <p>In case the foreign language does not have direct support for overriding (e.g: Go), or lacks the necessary reflection tools to allow automatic identification of overrides, the jsii runtime library may expose APIs allowing users to register implementation overrides manually.</p>"},{"location":"user-guides/language-support/callbacks/#declaring-overrides","title":"Declaring Overrides","text":"<p>The foreign library is responsible for declaring overrides to the jsii kernel. Those are declared for every object instance using the <code>overrides</code> property of the <code>kernel.create</code> request. Each entry in the <code>overrides</code> list declares an overriden property or method.</p> <p>Each override declaration may optionally include a <code>cookie</code>: this string will not be interpreted by the jsii kernel in any way, and will simply be passed back passed back with any request to invoke the overridden member's foreign implementation.</p> <p>Info</p> <p>It is possible to register overrides to members that do not formally exist on a type. Since the jsii kernel has no type information available for those, it will handle them as follows:</p> <ul> <li>Method overrides are assumed to have the following signature:   <pre><code>overridden(...args: any[]): any\n</code></pre></li> <li>Property overrides are assumed to be <code>any</code>-valued and mutable</li> </ul> <p>Danger</p> <p>This should generally be avoided as it can result in incoherent data serialization happening when the jsii kernel receives and returns values.</p>"},{"location":"user-guides/language-support/callbacks/#invoking-overrides","title":"Invoking Overrides","text":"<p>Once object instances have been created in the jsii kernel with overrides, execution of JavaScript code may require executing foreign code. The jsii kernel signals this to the jsii runtime library by responding with a <code>callback</code> request instead of the typical response type for the original request (i.e: <code>InvokeResponse</code>, <code>GetResponse</code> or <code>SetResponse</code>). Several such callbacks may be necessary in order to complete the original request. When the original request is finally able to complete, its response is returned.</p> <p>The jsii runtime library must respond to each <code>callback</code> request with a <code>complete</code> response, allowing the jsii kernel to resume fulfilling the original request. In order to do this, the jsii runtime library obtains the foreign object corresponding to the <code>callback</code> request's receiver, then invokes the corresponding implementation (for example, using reflection).</p> <p>When needed, the original JavaScript implementation can be delegated to (many languages refer to this as <code>super(...)</code> or some similar idiom).</p>"},{"location":"user-guides/language-support/callbacks/#example","title":"Example","text":"<p>Assuming we have the following TypeScript types defined:</p> <pre><code>export abstract class FooClass {\nprotected abstract baz: string;\n\npublic bar(): string {\nreturn this.reverse() ? Array.from(this.baz).reverse().join('') : this.baz;\n}\n\nprotected reverse(): boolean {\nreturn false;\n}\n}\n</code></pre> <p>And we have the following Foreign application (assuming Java):</p> <pre><code>public final class Main extends FooClass {\npublic static final void main(final String[] args) {\nfinal FooClass self = new Main();\nSystem.out.println(self.bar());\n}\n\n@Override\npublic String getBaz() {\nreturn \"baz\";\n}\n\n@Override\npublic boolean reverse() {\nreturn true;\n}\n}\n</code></pre> <p>The schematized exchange between the jsii runtime library and the jsii kernel is the following:</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513                                                  \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503  Kernel   \u2503                                                  \u2503Runtime Library\u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u251b                                                  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u25c0\u2500\u2524  Create(FQN: \"FooClass\", Overrides=[\"baz\", \"reverse\"])   \u251c\u2500\u2500\u2503\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u2500\u2500\u2524                     OK(ObjID: \"Foo\")                     \u251c\u2500\u25b6\u2503\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u25c0\u2500\u2524        InvokeRequest(ObjID: \"Foo\", Method: \"bar\")        \u251c\u2500\u2500\u2503\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u2500\u2500\u2524 CallbackRequest(ID: 1, ObjID: \"Foo\", Invoke: \"reverse\")  \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503    \u2502call\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503    \u2502obj(\"Foo\").reverse()\n      \u2503\u25c0\u2500\u2524            Complete(CallbackID: 1, OK: true)             \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u2500\u2500\u2524     CallbackRequest(ID: 2, ObjID: \"Foo\", Get: \"baz\")     \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503    \u2502get\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503    \u2502obj(\"Foo\").baz\n      \u2503\u25c0\u2500\u2524            Complete(CallbackID: 2, OK: \"baz\")            \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2503\n      \u2503\u2500\u2500\u2524                InvokeResponse(OK: \"zab\")                 \u251c\u2500\u25b6\u2503\n      \u2503  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2503\n      \u2503                                                                \u2503\n</code></pre>"},{"location":"user-guides/language-support/callbacks/#see-also","title":"See Also","text":"<ul> <li>The jsii runtime architecture</li> <li>The jsii kernel API</li> </ul>"},{"location":"user-guides/lib-author/","title":"Prerequisites","text":""},{"location":"user-guides/lib-author/#common-runtime","title":"Common Runtime","text":"<p>Whether you are developing jsii modules or consuming them (see Runtime Architecture), a compatible <code>node</code> runtime must be available. Current <code>node</code> runtime versions support status is as follows:</p> <p>The following node releases are part of our test matrix:</p> Release Status End-of-Life <code>^14.6.0</code>  Supported <code>2023-04-30</code> <code>^16.3.0</code>  Supported <code>2024-04-30</code> <code>^18.0.0</code>  Supported <code>2025-04-30</code> Status Definitions <ul> <li> Supported: Long Term Support (LTS) releases  (those with an even major version) are   supported and bugs specific to those releases are addressed with the highest priority. Every <code>jsii</code> release is   automatically tested against those releases.</li> <li> Best effort: Development releases (those with an odd major version) are supported on a   best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors   that we may not be able to fix.</li> </ul> <p>Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the  Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release.</p> <p>The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each).</p>"},{"location":"user-guides/lib-author/#other-languages","title":"Other Languages","text":"<p>When developing jsii modules, the SDK for each desired target language must be available for <code>jsii-pacmak</code> to be able to produce releasable artifacts.</p> Language/Platform SDK Requirement .NET .NET \u2265 6.0 Go Go \u2265 1.18 Java JDK \u2265 8 and Maven \u2265 3.6 Python Python \u2265 3.7"},{"location":"user-guides/lib-author/#download-locations","title":"Download Locations","text":"<p>This table provides typical download locations for the prerequisites mentioned in this document. Most of these tools can also be installed using traditional package managers (standard for the operating system and platform).</p> Tool Description Location .NET Official Microsoft .NET SDK distribution Download Amazon Corretto Amazon's free OpenJDK distribution Download Go Official Go distribution Download OpenJDK Oracle OpenJDK distribution Download Maven Official Maven distribution Download Node Official NodeJS distribution Download"},{"location":"user-guides/lib-author/hints/","title":"Type system hints","text":"<p>The <code>jsii</code> compiler interprets some documentation tags as hints that influence the type system represented in the <code>.jsii</code> assembly files.</p>"},{"location":"user-guides/lib-author/hints/#forcing-an-interface-to-be-considered-a-struct","title":"Forcing an interface to be considered a struct","text":"<p>Using the <code>@struct</code> tag, an interface will be interpreted as a struct even if its name starts with a capital <code>I</code>, followed by another capital letter (which normally would make them be treated as behavioral interfaces):</p> <pre><code>/**\n * @struct\n */\nexport interface IPRange {\nreadonly cidr: string:\n}\n</code></pre> <p>Important</p> <p>The <code>@struct</code> hint can only be used on interface declarations. Attempting to use them on any other declaration will result in a compilation error.</p>"},{"location":"user-guides/lib-author/typescript-restrictions/","title":"TypeScript Restrictions","text":"<p>Since the API exported by jsii modules will be represented in a variety of other languages, certain restrictions are enforced by the <code>jsii</code> compiler.</p> <p>Info</p> <p>Since those restrictions are solely intended to ensure the exported API can be represented in other languages, they do not apply to any internal declarations such as <code>private</code> members and declarations annotated with the <code>/** @internal */</code> tag.</p>"},{"location":"user-guides/lib-author/typescript-restrictions/#dependencies","title":"Dependencies","text":"<p>A jsii module can declare dependencies on any other jsii module by adding entries in the <code>dependencies</code> key in the <code>package.json</code> file. Since most other platforms do not support multiple different versions of the same library to coexist in the same closure, it is recommended to also declare all such dependencies as <code>peerDependencies</code>.</p> <p>Occasionally, a dependency on a non-jsii module is useful. Since such dependencies do not have generated bindings in all the supported languages, they must be bundled with the jsii module that depends on them, by adding the library into the <code>bundleDependencies</code> array in <code>package.json</code>. The API of the jsii module can not expose any type from bundled dependencies, since those types would not be available in other languages.</p> <p>Info</p> <p>For more information on <code>package.json</code> file contents, refer to the npm documentation.</p>"},{"location":"user-guides/lib-author/typescript-restrictions/#naming","title":"Naming","text":""},{"location":"user-guides/lib-author/typescript-restrictions/#class-members","title":"Class Members","text":"<p>Members of classes cannot share the same PascalCased representation as the declaring class itself, as this results in invalid C# code:</p> <pre><code>export class Foo {\n// \ud83d\udca5 Illegal property name\npublic foo: string;\n}\n\nexport class Bar {\n// \ud83d\udca5 Illegal method name\npublic bar(): void { /* ... */ }\n}\n</code></pre> <p>Danger</p> <p>Due to existing usage, this restriction is only enforced when <code>jsii</code> is invoked with the <code>--strict</code> option. The generated C# class name will receive a <code>_</code> suffix if any of it's members conflict, which is a breaking change to existing .NET consumers when a conflicting member is introduced after the initial release.</p>"},{"location":"user-guides/lib-author/typescript-restrictions/#interfaces","title":"Interfaces","text":"<p>The <code>jsii</code> type model distinguishes two kinds of interfaces:</p> <ul> <li>Behavioral interfaces, which can declare methods and properties</li> <li>Structs, which are immutable pure data entities, and can consequently only declare <code>readonly</code> properties</li> </ul> <p>A name convention is used to distinguish between these two: behavioral interfaces must have a name that starts with a <code>I</code> prefix, while structs must not have such a prefix.</p> <p>Info</p> <p>The <code>/** @struct */</code> type system hint can be used to force an interface with a name starting with the <code>I</code> prefix to be handled as a struct instead of a behavioral interface.</p> <pre><code>/**\n * Since there is no `I` prefix, Foo is considered to be a struct.\n */\nexport interface Foo {\n// \ud83d\udca5 Structs are not allowed to declare methods\nfoo(): void;\n// \ud83d\udca5 Structs are not allowed to declare mutable properties\nmutableProperty: number;\n// \u2705 Structs can declare immutable properties\nreadonly immutableProperty: string;\n}\n\n/**\n * Since there is an `I` prefix, IFoo is considered to be a behavioral interface.\n */\nexport interface IFoo {\n// \u2705 Behavioral interfaces can declare methods\nfoo(): void;\n// \u2705 Behavioral interfaces can declare mutable properties\nmutableProperty: number;\n// \u2705 Behavioral interfaces can declare immutable properties\nreadonly immutableProperty: string;\n}\n</code></pre>"},{"location":"user-guides/lib-author/typescript-restrictions/#inheritance","title":"Inheritance","text":""},{"location":"user-guides/lib-author/typescript-restrictions/#structs","title":"Structs","text":"<p>As structs are pure data entities, they can only be extended by other structs:</p> <pre><code>export interface Struct { /* ...readonly properties... */ }\n\n// \ud83d\udca5 Structs cannot be extended by behavioral interfaces\nexport interface IBehavioralInterface extends Struct { /* ... */ }\n// \ud83d\udca5 Structs cannot be implemented by classes\nexport class ConcreteType implements Struct { /* ... */ }\n// \u2705 Structs can extend other structs\nexport interface SuperStruct extends Struct { /* ...readonly properties */ }\n</code></pre>"},{"location":"user-guides/lib-author/typescript-restrictions/#member-visibility","title":"Member Visibility","text":"<p>The C# language does not allow overriding members to change the visibility of the overridden declaration, even if the updated visibility is more permissive. As a consequence, overridden members are required to retain the same visibility as their parents.</p> <p>Danger</p> <p>This makes changing the visibility of a <code>protected</code> member to <code>public</code> is a breaking change in <code>jsii</code> libraries!</p> <pre><code>export class Base {\nprotected method(): void { /* ... */ }\n}\n\nexport class Subclass extends Base {\n// \ud83d\udca5 Illegal change of visibility from protected to public\npublic method(): void { /* ... */ }\n}\n</code></pre>"},{"location":"user-guides/lib-author/typescript-restrictions/#covariant-overrides-parameter-list-changes","title":"Covariant Overrides &amp; Parameter List Changes","text":"<p>In TypeScript, overriding members can have a signature that differs from the overridden member as long as the new signature is compatible with the parent. This is however not supported as:</p> <ul> <li>Java and C# do not support omitting parameters when overriding or implementing a member</li> <li>C# does not support overriding or implementing a member using covariant parameter or return types</li> </ul> <p>Note</p> <p>C# 9 introduces support for covariant return types, which would allow relaxing this restriction, however <code>jsii</code> must build code targetting the <code>.NET Core 3.1</code> runtime, which only supports C# 8. Once <code>.NET Core 3.1</code> becimes end-of-life, this may change.</p> <pre><code>export class Base {\npublic method(param: any): any { /* ... */ }\n}\n\nexport class Child extends Base {\n// \ud83d\udca5 Parameter signatures do not match\npublic method(): any { /* ... */ }\n// \ud83d\udca5 Parameter types do not match, even though they are covariant\npublic method(param: string): any { /* ... */ }\n// \ud83d\udca5 Return type does not match, even though it is covariant\npublic method(param: any): string { /* ... */ }\n}\n</code></pre>"},{"location":"user-guides/lib-author/typescript-restrictions/#parameterized-types-aka-generics","title":"Parameterized Types (aka: Generics)","text":"<p>Parameterized types are not consistently supported in all supported target languages. Go does not currently support generics, and the differences in generic semantics between TypeScript, C# and Java make it difficult to correctly represent such types in all those languages. As a consequence, <code>jsii</code> does not support declaring parameterized types.</p> <p>Only certain built-in parameterized types can be used in <code>jsii</code> modules:</p> <ul> <li><code>Array&lt;T&gt;</code>, which is equivalent to <code>T[]</code></li> <li><code>Record&lt;string, T&gt;</code>, which is equivalent to <code>{ [key: string]: T }</code></li> <li><code>Promise&lt;T&gt;</code>, which is the return type of any asynchronous method</li> </ul> <pre><code>// \ud83d\udca5 Parameterized types cannot be introduced\nexport interface Parameterized&lt;T&gt; {\nreadonly value: T;\n}\nexport interface IAsyncFooMaker {\n// \u2705 Asynchronous methods must return promises\nmakeFoo(): Promise&lt;Foo&gt;;\n// \u2705 Arrays are supported\nmakeFoos(count: number): Array&lt;Promise&lt;Foo&gt;&gt;;\n}\n</code></pre>"},{"location":"user-guides/lib-author/typescript-restrictions/#soft-reserved-words","title":"Soft-Reserved Words","text":"<p>In order to guarantee a consistent developer experience across all supported languages, <code>jsii</code> emits warnings whenever a declaration is named after any target language's reserved words, as those will need renaming in target languages:</p> C# Java Python Go <code>abstract</code> <code>abstract</code> <code>False</code> <code>break</code> <code>base</code> <code>assert</code> <code>None</code> <code>case</code> <code>bool</code> <code>boolean</code> <code>True</code> <code>chan</code> <code>byte</code> <code>byte</code> <code>and</code> <code>const</code> <code>char</code> <code>char</code> <code>assert</code> <code>continue</code> <code>checked</code> <code>double</code> <code>def</code> <code>default</code> <code>decimal</code> <code>final</code> <code>del</code> <code>defer</code> <code>delegate</code> <code>float</code> <code>elif</code> <code>else</code> <code>double</code> <code>goto</code> <code>except</code> <code>fallthrough</code> <code>event</code> <code>int</code> <code>from</code> <code>for</code> <code>explicit</code> <code>long</code> <code>global</code> <code>func</code> <code>extern</code> <code>native</code> <code>is</code> <code>go</code> <code>fixed</code> <code>short</code> <code>lambda</code> <code>goto</code> <code>float</code> <code>strictfp</code> <code>nonlocal</code> <code>if</code> <code>foreach</code> <code>synchronized</code> <code>not</code> <code>import</code> <code>goto</code> <code>throws</code> <code>or</code> <code>interface</code> <code>implicit</code> <code>transient</code> <code>pass</code> <code>map</code> <code>int</code> <code>volatile</code> <code>raise</code> <code>package</code> <code>internal</code> <code>range</code> <code>is</code> <code>return</code> <code>lock</code> <code>select</code> <code>long</code> <code>struct</code> <code>namespace</code> <code>switch</code> <code>object</code> <code>type</code> <code>operator</code> <code>var</code> <code>out</code> <code>override</code> <code>params</code> <code>readonly</code> <code>ref</code> <code>sbyte</code> <code>sealed</code> <code>short</code> <code>sizeof</code> <code>stackalloc</code> <code>string</code> <code>struct</code> <code>uint</code> <code>ulong</code> <code>unchecked</code> <code>unsafe</code> <code>ushort</code> <code>using</code> <code>virtual</code> <code>volatile</code> <p>Info</p> <p>The list of reserved words is derived from <code>jsii/lib/reserved-words.ts</code>.</p>"},{"location":"user-guides/lib-author/configuration/","title":"Overview","text":"<p>The configuration for <code>jsii</code> is recorded in the <code>package.json</code> file, which is the standard package manifest for NPM packages. This document describes the constraints and extensions <code>jsii</code> adds to the package.json schema.</p>"},{"location":"user-guides/lib-author/configuration/#jsii-config","title":"jsii-config","text":"<p>Use jsii-config to aid in configuring a new jsii module.</p>"},{"location":"user-guides/lib-author/configuration/#additional-requirements-extensions","title":"Additional Requirements &amp; Extensions","text":"<p>In order to be able to generate valid packages for all the supported target package managers, certain fields that are optional in the standard package.json schema are required by <code>jsii</code>.</p> <p>For example, Maven Central requires packages to carry sufficient metadata, such as developer information and license, in order to be valid for publishing.</p> Field Required Extensions <code>author</code> <code>author.organization</code> <code>license</code> <code>main</code> <code>repository</code> <code>stability</code> The field itself is an extension <code>types</code>"},{"location":"user-guides/lib-author/configuration/#attribution-licensing","title":"Attribution &amp; Licensing","text":"<ul> <li>The <code>author</code> field must be set. Although the string form   (<code>\"The Octocat &lt;octocat@github.com&gt; (https://github.com/octocat)\"</code>) works, it is recommended to set the value using   the <code>object</code> format:   <pre><code>{\n// ...\n\"author\": {\n\"name\": \"The Octocat\",                // Required\n\"email\": \"octocat@github.com\",        // Optional\n\"url\": \"https://github.com/octocat\",  // Optional\n\"organization\": false                 // Optional (defaults to false)\n},\n// ...\n}\n</code></pre>   The <code>organization</code> field is an extension from the package.json schema that can be used to signal the <code>author</code> field   refers to an <code>organization</code> and not and individual person.</li> <li>The <code>license</code> field must be set to a valid SPDX license id. If you do not intend to release your   package for third-party consumption, <code>UNLICENSED</code> (not to be confused with <code>Unlicense</code>) is a valid option.</li> </ul>"},{"location":"user-guides/lib-author/configuration/#important-license-information","title":"Important License Information","text":"<p>You are free to decide which license you want to distribute your code under. The bindings generated by <code>jsii-pacmak</code> will use the exact same license as the source TypeScript library they were based on. You are responsible for correctly applying your chosen license to your work (most licenses have documentations outlining how to correctly apply the license), and for complying with the terms of the licenses of packages your work depends on (this is particularly important when dependencies are bundled, as discussed later in this section).</p> <p>In addition to the <code>license</code> field present in the <code>package.json</code> file, we strongly recommend adding a <code>LICENSE</code> file in the package's root directory which contains the standardized text for the license (those can be found on the SPDX website).</p> <p>Danger</p> <p>Unless you know exactly what you are doing, you should copy the license text verbatim in the <code>LICENSE</code> file. Many organizations have license scanners that will only recognize the standard license text, and editing that may cause undesired friction before users in those organizations can use your library, and may void your license choice.</p> <p>A <code>NOTICE</code> file is often desirable. In particular, if you are developing the library as part of your employment, you should ask your employer's legal team (or equivalent) for specific instructions.</p> <p>Danger</p> <p>If your library includes bundled dependencies (via the <code>bundledDependencies</code>/<code>bundleDependencies</code> key in the <code>package.json</code> file), you are required to comply with those dependencies' licenses provisions pertaining to re-distribution. This often means providing attribution to these in your <code>NOTICE</code> file, among other requirements.</p> <p>The <code>LICENSE</code> and <code>NOTICE</code> files, when present, will be copied into generated binding's source code. If no <code>LICENSE</code> file exists in the source package, the standard SPDX license text will be produced into a <code>LICENSE</code> file in generated bindings whenever possible.</p>"},{"location":"user-guides/lib-author/configuration/#source-control-information","title":"Source Control Information","text":"<p>The <code>repository</code> field must be set to the URL of the source-control system (such as a <code>git</code> repository) for the package. The recommended way to provide the value is using the <code>object</code> representation:</p> <pre><code>{\n\"repository\": {\n\"url\": \"https://github.com/aws/jsii.git\", // Required\n\"type\": \"git\",                            // Recommended\n\"directory\": \"/path\"                      // Optional\n}\n}\n</code></pre>"},{"location":"user-guides/lib-author/configuration/#library-entry-point","title":"Library Entry Point","text":"<p>Both the <code>main</code> field must be set to the <code>.js</code> file that acts as the entry point of your library (what node's <code>require('library-name')</code> will load). Additionally, <code>TypeScript</code>'s <code>types</code> field must be set to the <code>.d.ts</code> file corresponding to the <code>main</code> file. The assembly emitted by <code>jsii</code> will only represent types that are exported from the <code>types</code> file.</p>"},{"location":"user-guides/lib-author/configuration/#package-level-api-stability","title":"Package-level API Stability","text":"<p>The <code>.jsii</code> assembly document allows representing API stability levels on individual API elements. The default value set for API elements for which a stability declaration is not found can be configured using the <code>stability</code> field of the <code>package.json</code> file. It can be set to one of the following values: <code>experimental</code>, <code>stable</code>, <code>deprecated</code> and <code>external</code>. While the exact semantic value of those fields is defined by the package maintainer, the generic interpretation for those on packages is:</p> <ul> <li><code>experimental</code> - the package is not yet ready for production usage, as it is still in the early stages of its   development.</li> <li><code>stable</code> - the package is ready for production and its APIs should be expected to adhere to semantic versioning.</li> <li><code>deprecated</code> - the package should no longer be used and may no longer be maintained. It is a good practice to set the   <code>deprecated</code> field in <code>package.json</code> with an explanation of how consumers of the package should update their   dependencies.</li> <li><code>external</code> - the package includes APIs that are derived from external artifacts, and the owners of those artifacts   control their stability.</li> </ul>"},{"location":"user-guides/lib-author/configuration/#the-jsii-section","title":"The <code>jsii</code> section","text":"<p>In order to configure the behavior of <code>jsii</code>, the <code>package.json</code> file must include a <code>jsii</code> section that can contain the following entries:</p> Field Type Required Default <code>excludeTypescript</code> <code>string[]</code> none <code>metadata</code> <code>object</code> none <code>projectReferences</code> <code>boolean</code> <code>true</code> <code>targets</code> <code>object</code> <code>tsc</code> <code>object</code> <code>{ outDir: '.', rootDir: '.' }</code> <code>versionFormat</code> <code>'short' | 'full'</code> <code>'full'</code>"},{"location":"user-guides/lib-author/configuration/#excludetypescript","title":"<code>excludeTypescript</code>","text":"<p>By default, <code>jsii</code> will include all <code>*.ts</code> files (except <code>.d.ts</code> files) in the <code>TypeScript</code> compiler input. This can be problematic for example when the package's build or test procedure generates <code>.ts</code> files that cannot be compiled with <code>jsii</code>'s compiler settings.</p> <p>The <code>excludeTypescript</code> configuration accepts a list of glob patterns. Files matching any of those patterns will be excluded from the <code>TypeScript</code> compiler input.</p>"},{"location":"user-guides/lib-author/configuration/#metadata","title":"<code>metadata</code>","text":"<p>The <code>metadata</code> section can be used to record additional metadata as key-value pairs that will be recorded as-is into the <code>.jsii</code> assembly file. That metadata can later be inspected using <code>jsii-reflect</code> utilities, for example.</p>"},{"location":"user-guides/lib-author/configuration/#targets","title":"<code>targets</code>","text":"<p>The <code>targets</code> section is where <code>jsii</code> packages define which target languages they support. This provides the package generators with the additional information they require in order to name generated artifacts. Configuration is provided as a mapping from target name to a configuration object.</p> <p>The specific configuration accepted for each supported language is presented in dedicated pages:</p> <ul> <li> .NET Target</li> <li> Go Target</li> <li> Java Target</li> <li> Python Target</li> </ul>"},{"location":"user-guides/lib-author/configuration/#tsc","title":"<code>tsc</code>","text":"<p>In order to the generated <code>javascript</code> can be properly loaded by the <code>jsii</code> runtimes, <code>jsii</code> generates a [<code>tsconfig.json</code>] file with fixed settings at the beginning of the compilation pass. Certain configuration options can however be set by the maintainers in order to better suit their development workflow or processes. Those configuration are set in the <code>jsii.tsc</code> section of the <code>package.json</code> file, but use the same name as [<code>tsconfig.json</code>]:</p> <ul> <li><code>outDir</code> - path to the directory when artifacts generated by the <code>TypeScript</code> compiler will be placed.</li> <li>This influences the location of <code>.d.ts</code> and <code>.js</code> files, but will not affect the location of the <code>.jsii</code> file, which     will always be placed at the package's root.</li> <li><code>rootDir</code> - specifies the root directory that contains all of the <code>.ts</code> source files. This is used in conjunction with   <code>outDir</code>, to control the directory structure that gets generated.</li> <li><code>forceConsistentCasingInFileNames</code> - if <code>true</code>, will make the <code>TypeScript</code> compiler care about the casing of files    specified in <code>import</code> statements. This is helpful if you're developing on a filesystem that is case-insensitive    (Mac/Win), but building/deploying on a filesystem that is case-sensitive (Linux).</li> <li><code>declarationMap</code>, <code>inlineSourceMap</code>, <code>inlineSources</code>, and <code>sourceMap</code> allow confifuring the source map generation.   This option can be useful to finely control your local development experience (for example, by enabling   <code>declarationMap</code>), or to optimize the emitted code size (by disabling source maps entirely).</li> <li>if any of these options is specified, the source map configuration will exactly match what is being provided here</li> <li>If none are specified, the default settings will be used: <code>{ inlineSourceMap: true, inlineSources: true }</code></li> <li><code>types</code> allows limiting which visible type libraries get loaded in the global scope by the typescript compiler. By   default, all visible <code>@types/*</code> packages will be loaded, which can be undesirable (in particular in monorepos, where   some type libraries are not compatible with the TypeScript compiler version that <code>jsii</code> uses). The value specified   here will be forwarded as-is to the TypeScript compiler.</li> <li><code>baseUrl</code> and <code>paths</code> can be used to configure TypeScript path mappings, and are copied verbatim to <code>tsconfig.json</code>.</li> </ul> <p>Refer to the TypeScript compiler options reference for more information about those options.</p>"},{"location":"user-guides/lib-author/configuration/#versionformat","title":"<code>versionFormat</code>","text":"<p>Determines the format of the <code>jsii</code> toolchain version string that will be included in the <code>.jsii</code> assembly file's <code>jsiiVersion</code> attribute.</p> <ul> <li><code>full</code> (the default) - a version number including a commit hash will be used</li> <li>For example: <code>0.14.3 (build 1b1062d)</code></li> <li><code>short</code> - only the version number of <code>jsii</code> will be used</li> <li>For example: <code>0.14.3</code></li> </ul> <p>This option is primarily useful for developing regression tests when developing <code>jsii</code> itself, as using the <code>short</code> format reduces volatility in the assemblies generated by development versions of <code>jsii</code>. Users of <code>jsii</code> are advised to leave the default setting, as having full version information can be essential when trying to troubleshoot assembly generation problems.</p>"},{"location":"user-guides/lib-author/configuration/#diagnostics","title":"Diagnostics","text":"<p>JSII produces a number of diagnostic information. These have been categorized into \"error\", \"warning\", \"suggestion\" and \"message\", by default. Diagnostics categorized as \"error\" will fail the jsii compiler and the rest will be printed to console.</p> <p>These can be re-configured to a different category under the <code>diagnostics</code> key as so -</p> <pre><code>\"jsii\": {\n// ...\n\"diagnostics\": {\n\"documentation/non-existent-parameter\": \"error\",\n\"code-style/submodule-name-casing\": \"suggestion\",\n\"JSII9998\": \"error\",\n\"JSII9001\": \"warning\"\n}\n}\n</code></pre> <p>As noted in the example above, the diagnostic code can be the human readable string, or the numeric code prefixed with <code>JSII</code>.</p> <p>The full list of diagnostic codes can be found in <code>jsii-diagnostic.ts</code>.</p>"},{"location":"user-guides/lib-author/configuration/#dependency-considerations","title":"Dependency considerations","text":"<p>Like any node library, <code>jsii</code> packages can declare runtime dependencies using the <code>dependencies</code> section of <code>package.json</code>.</p>"},{"location":"user-guides/lib-author/configuration/#dependencies-that-are-jsii-modules","title":"Dependencies that are <code>jsii</code> modules","text":"<p>Node modules are conventionally versioned using semantic versioning, but that is not true of all package managers that <code>jsii</code> is able to target. Additionally, only one version of the <code>jsii</code> runtime and kernel can be used within a given application. In order to avoid version resolution surprises at run-time, <code>jsii</code> requires duplicating <code>jsii</code> modules declarations from <code>dependencies</code> into the <code>peerDependencies</code> section.</p>"},{"location":"user-guides/lib-author/configuration/#dependencies-that-are-not-jsii-modules","title":"Dependencies that are not <code>jsii</code> modules","text":"<p>The <code>jsii</code> runtimes in non-javascript languages do not use <code>npm install</code>, and as a consequence cannot rely on <code>npm install</code> bringing in a package's dependencies. As a consequence, dependencies that are not themselves <code>jsii</code> modules, must also be referenced in the <code>bundledDependencies</code> section, so that they are bundled within the NPM package.</p>"},{"location":"user-guides/lib-author/configuration/targets/dotnet/","title":".NET","text":"<p>The <code>dotnet</code> target requires the following configuration:</p> <ul> <li><code>namespace</code> - the root namespace under which types will be declared.</li> <li><code>packageId</code> - the identified of the package in the NuGet registry.</li> <li><code>iconUrl</code> - the URL of the icon to be shown in the NuGet Gallery. It should be at least 64x64 pixels and a   transparent background is recommended. See the .NET documentation for more information.</li> <li><code>versionSuffix</code> - an optional suffix that will be appended at the end of the NuGet package's <code>version</code> field. The   suffix must start with a <code>-</code>.</li> </ul> <p>Example:</p> <pre><code>{\n\"jsii\": {\n\"dotnet\": {\n\"namespace\": \"Acme.HelloJsii\",              // Required\n\"packageId\": \"Acme.HelloJsii\",              // Required\n\"iconUrl\": \"https://cdn.acme.com/icon.png\", // Optional\n\"versionSuffix\": \"-preview\"                 // Optional\n},\n// ...\n},\n// ...\n}\n</code></pre> <p>The resulting artifact is a NuGet package that can be published to NuGet using the standard <code>nuget push</code> command.</p>"},{"location":"user-guides/lib-author/configuration/targets/go/","title":"Go","text":"<p>To enable go package generation, add the <code>go</code> key to the jsii targets configuration:</p> <ul> <li><code>packageName</code> (optional) - The name of the Go package name. If not specified,   package name will be derived from the JavaScript module name by removing   non-alphanumeric characters (e.g. <code>@aws-cdk/aws-s3</code> will be <code>awscdkawss3</code>). If   this is set on a submodule config file (<code>.jsiirc.json</code>), it refers to the   submodule package name.</li> <li><code>moduleName</code> (required) - The name of the target repository in which this   module will be published (e.g. <code>github.com/foo/bar</code>). The module itself will   always be published under a subdirectory named according to the Go package   name of the module (e.g. <code>github.com/foo/bar/awscdk</code>).</li> <li><code>versionSuffix</code> (optional) - Can be provided that will be appended at the end   of the module version.</li> </ul> <p>This will add generated go package code to your specified <code>outDir</code> under <code>go/PACKAGE_NAME</code> (e.g. <code>dist/go/awscdklib</code>).</p> <pre><code>{\n\"jsii\": {\n\"targets\": {\n\"go\": {\n\"moduleName\": \"github.com/foo/bar\",  // REQUIRED\n\"packageName\": \"hello\",              // OPTIONAL\n\"versionSuffix\": \"-devprefix\"        // OPTIONAL\n},\n// ...\n},\n// ...\n},\n// ...\n}\n</code></pre>"},{"location":"user-guides/lib-author/configuration/targets/java/","title":"Java","text":"<p>The <code>java</code> target requires the following configuration:</p> <ul> <li><code>maven</code> - the <code>groupId</code> and <code>artifactId</code> for the Maven package.</li> <li>Optionally a <code>versionSuffix</code> can be provided that will be appended at the end of the Maven package's <code>version</code>     field. The suffix must start with a <code>.</code> or a <code>-</code>.</li> <li><code>package</code> - the root Java package name under which the types will be declared.</li> </ul> <p>Example:</p> <pre><code>{\n\"jsii\": {\n\"java\": {\n\"package\": \"acme.jsii.hello\",   // Required\n\"maven\": {\n\"groupId\": \"acme\",            // Required\n\"artifactId\": \"jsii-hello\",   // Required\n\"versionSuffix\": \".PREVIEW\"   // Optional\n}\n},\n// ...\n},\n// ...\n}\n</code></pre> <p>The resulting artifact is a Maven package that can be deployed to Maven Central using the <code>deploy-staged-repository</code> command of the nexus-staging-maven-plugin.</p>"},{"location":"user-guides/lib-author/configuration/targets/python/","title":"Python","text":"<p>The <code>python</code> target requires two configuration entries:</p> <ul> <li><code>module</code> - the name of the generated Python module, which will be used by users in <code>import</code> directives.</li> <li><code>distName</code> - the PyPI distribution name for the package.</li> <li><code>classifiers</code> - a list of trove classifiers to declare on the package. It is the user's responsibility to specify   valid values (the authoritative list of valid trove classifiers is defined in the pypa/trove-classifiers   package).</li> <li>Some classifiers are automatically included (and should not be added to the <code>classifiers</code> property) based on     relevant configuration from the <code>package.json</code> file:<ul> <li><code>Development Status ::</code> is determined based on the package's <code>stability</code></li> <li><code>License ::</code> is determined based on the package's <code>license</code></li> <li><code>Operating System :: OS Independent</code> is always set</li> <li><code>Typing :: Typed</code> is always set</li> </ul> </li> <li>Additionally, the following <code>Programming Language ::</code> classifiers are already set (more could be added by the user     if relevant):<ul> <li><code>Programming Language :: Python :: 3 :: Only</code></li> <li><code>Programming Language :: Python :: 3.7</code></li> <li><code>Programming Language :: Python :: 3.8</code></li> <li><code>Programming Language :: Python :: 3.9</code></li> <li><code>Programming Language :: Python :: 3.10</code></li> <li><code>Programming Language :: Python :: 3.11</code></li> </ul> </li> </ul> <p>Example:</p> <pre><code>{\n\"jsii\": {\n\"targets\": {\n\"python\": {\n\"module\": \"hello_jsii\",   // Required\n\"distName\": \"hello-jsii\", // Required\n\"classifiers\": [          // Optional\n\"Framework :: AWS CDK\",\n\"Framework :: AWS CDK :: 1\"\n]\n},\n// ...\n}\n// ...\n},\n// ...\n}\n</code></pre> <p>The resulting package can be published to PyPI.</p>"},{"location":"user-guides/lib-author/configuration/targets/python/#prerelease-versions","title":"Prerelease Versions","text":"<p>The original <code>npm</code> package may feature a version number that includes a SemVer 2.0-compliant prerelease identifer (e.g: <code>1.2.3-pre.4</code>). Python packages distributed to PyPI must however use a different format to express prerelease versions, as specified in PEP-440. In order to generate valid packages, only certain prerelease identifiers are accepted by <code>jsii-pacmak</code>, and are translated according to the following table:</p> Source Version (<code>npm</code>) Python Version (PEP-440) Notes <code>X.Y.Z-dev.N</code> <code>X.Y.Z.devN</code> Development, iteration <code>N</code>. <code>X.Y.Z-pre.N</code> <code>X.Y.Z.devN</code> Development, iteration <code>N</code> <code>X.Y.Z-alpha.N</code> <code>X.Y.Z.aN</code> Alpha release, iteration <code>N</code> <code>X.Y.Z-beta.N</code> <code>X.Y.Z.bN</code> Beta release, iteration <code>N</code> <code>X.Y.Z-rc.N</code> <code>X.Y.Z.rcN</code> Release candidate, iteration <code>N</code>"},{"location":"user-guides/lib-author/quick-start/set-up/","title":"Set Up","text":""},{"location":"user-guides/lib-author/quick-start/set-up/#creating-a-new-npm-package","title":"Creating a new npm package","text":"<p>Start by creating a new empty npm package:</p> <pre><code># mkdir project-name\n# cd project-name\n# npm init -y\nWrote to /Users/rmuller/Downloads/project-name/package.json:\n\n{\n  \"name\": \"project-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n</code></pre>"},{"location":"user-guides/lib-author/quick-start/set-up/#adding-mandatory-metadata","title":"Adding mandatory metadata","text":"<p>Then, add the mandatory information to the new <code>package.json</code> file that was created. Specifically, jsii modules must have an <code>author</code> and <code>repository</code> setting (those are necessary to generate valid libraries for certain distribution points, such as Maven Central):</p> <pre><code>{\n\"name\": \"project-name\",\n\"version\": \"1.0.0\",\n\"description\": \"A demonstration jsii library\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [],\n\"author\": {\n\"name\": \"John Doe\",\n\"email\": \"john.doe@acme.com\"\n},\n\"repository\": {\n\"url\": \"https://github.com/acme/project-name.git\"\n},\n\"license\": \"ISC\"\n}\n</code></pre> <p>Important</p> <p>Before publishing your work, be sure to review the Important License Information documentation.</p>"},{"location":"user-guides/lib-author/quick-start/set-up/#setting-up-the-jsii-configuration","title":"Setting up the jsii configuration","text":"<p>Finish up the configuration by running <code>jsii-config</code>, and letting the assistant guide you through the process:</p> <pre><code># npx jsii-config\n? Target Languages (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)\n\u276f\u25ef java\n \u25ef python\n \u25ef dotnet\n...\nSuccess!\n</code></pre>"},{"location":"user-guides/lib-author/quick-start/set-up/#install-dependencies","title":"Install Dependencies","text":"<p>Now, you're ready to install the basic tools into the packages' dependency closure. The exact instructions depend on the JavaScript package manager you want to be using:</p> yarn <pre><code># yarn add -D jsii jsii-pacmak\nyarn add v1.22.10\ninfo No lockfile found.\n[1/4] \ud83d\udd0d  Resolving packages...\n[2/4] \ud83d\ude9a  Fetching packages...\n[3/4] \ud83d\udd17  Linking dependencies...\n[4/4] \ud83d\udd28  Building fresh packages...\nsuccess Saved lockfile.\nsuccess Saved 66 new dependencies.\n...\n</code></pre> npm <pre><code># npm install --save-dev jsii jsii-pacmak\n\nadded 107 packages, and audited 107 packages in 4s\n\n39 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n</code></pre>"},{"location":"user-guides/lib-author/quick-start/set-up/#set-up-essential-scripts","title":"Set up essential scripts","text":"<p>Finally, you might want to configure convenience scripts in your <code>package.json</code> file in order to facilitate working with your project:</p> <pre><code>{\n\"name\": \"project-name\",\n\"version\": \"1.0.0\",\n\"description\": \"A demonstration jsii library\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"build\": \"jsii\",\n\"build:watch\": \"jsii --watch\",\n\"package\": \"jsii-pacmak\"\n},\n\"keywords\": []\n// ...\n}\n</code></pre> <p>Those scripts have the following effect:</p> Script Description <code>build</code> Compiles the project <code>build:watch</code> Watches for file changes and recompiles as needed <code>package</code> Generates libraries for all languages"},{"location":"user-guides/lib-author/quick-start/write-code/","title":"Write Code","text":""},{"location":"user-guides/lib-author/quick-start/write-code/#the-indexts-content","title":"The <code>index.ts</code> content","text":"<p>Create a new <code>index.ts</code> file with your initial code:</p> <pre><code>export interface GreeterProps {\nreadonly greetee: string;\n}\n\nexport class Greeter {\nprivate readonly greetee: string;\n\npublic constructor(props: GreeterProps) {\nthis.greetee = props.greetee;\n}\n\npublic greet(): string {\nreturn `Hello, ${this.greetee}!`\n}\n}\n</code></pre>"},{"location":"user-guides/lib-author/quick-start/write-code/#iterate","title":"Iterate","text":"<p>Either run the <code>build</code> or <code>build:watch</code> script from the Set Up step in order to compile the project. The necessary <code>tsconfig.json</code> is automatically created so the TypeScript compiler produces the correct output.</p>"},{"location":"user-guides/lib-author/quick-start/write-code/#generate-targets","title":"Generate Targets","text":"<p>Once you are satisfied with the library, bindings in all supported languages can be generated by running <code>jsii-pacmak</code>, typically by using the <code>package</code> script from the Set Up step. Publishable artifacts will be generated and placed in per-language sub-directories of the <code>dist</code> folder:</p> <pre><code>$ tree dist\ndist\n\u251c\u2500\u2500 dotnet\n\u2502   \u251c\u2500\u2500 Acme.ProjectName.1.0.0.nupkg\n\u2502   \u2514\u2500\u2500 Acme.ProjectName.1.0.0.snupkg\n\u251c\u2500\u2500 java\n\u2502   \u2514\u2500\u2500 com\n\u2502       \u2514\u2500\u2500 acme\n\u2502           \u2514\u2500\u2500 sample\n\u2502               \u2514\u2500\u2500 project-name\n\u2502                   \u251c\u2500\u2500 1.0.0\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.md5\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.sha1\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-sources.jar\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-sources.jar.md5\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0-sources.jar.sha1\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0.jar\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0.jar.md5\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0.jar.sha1\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0.pom\n\u2502                   \u2502   \u251c\u2500\u2500 project-name-1.0.0.pom.md5\n\u2502                   \u2502   \u2514\u2500\u2500 project-name-1.0.0.pom.sha1\n\u2502                   \u251c\u2500\u2500 maven-metadata.xml\n\u2502                   \u251c\u2500\u2500 maven-metadata.xml.md5\n\u2502                   \u2514\u2500\u2500 maven-metadata.xml.sha1\n\u251c\u2500\u2500 js\n\u2502   \u2514\u2500\u2500 project-name@1.0.0.jsii.tgz\n\u2514\u2500\u2500 python\n    \u251c\u2500\u2500 project-name-1.0.0.tar.gz\n    \u2514\u2500\u2500 project_name-1.0.0-py3-none-any.whl\n\n9 directories, 20 files\n</code></pre>"},{"location":"user-guides/lib-author/toolchain/jsii/","title":"jsii","text":"<p>The <code>jsii</code> tool wraps the standard TypeScript compiler, applies the TypeScript restrictions, producing additional diagnostic messages as necessary.</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#options","title":"Options","text":"<p>Info</p> <p>This section discusses the main options of <code>jsii</code> only. There may be additional options not mentioned on this page, which can learn about using <code>jsii --help</code>.</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#-watch","title":"<code>--watch</code>","text":"<p>The <code>--watch</code> option behaves similar to that of the standard TypeScript compiler. It will make <code>jsii</code> listen to file changes within the project, and recompile whenever a source file has changed (including producing diagnostic messages, and a new <code>.jsii</code> assembly file as needed).</p> <p>This option is useful when iterating on your code, as it provides a faster feedback loop than periodically manually re-compiling.</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#-project-references","title":"<code>--project-references</code>","text":"<p>When <code>--project-references</code> is specified, <code>jsii</code> will generate a <code>tsconfig.json</code> file that includes <code>references</code> to any other local <code>jsii</code> project present in the dependency closure of the current one.</p> <p>This option is recommended for any project that is part of a mono-repository, where multiple <code>jsii</code> packages are being maintained. It can result in improved build times, and a better IDE experience.</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#-fail-on-warnings","title":"<code>--fail-on-warnings</code>","text":"<p>The <code>--fail-on-warnings</code> option causes compilation top fail if any <code>warning</code> diagnostic is emitted. This setting is recommended for users who want to ensure the best possible experience for developers using their library in all supported languages, as it will prevent inadvertent use of one of those languages' reserved words in an identifier.</p> <p>Warning</p> <p>Setting this option might occasionally cause compilation to fail when performing a minor version upgrade to <code>jsii</code>; in particular when support for a new language is introduced (as this may introduce additional reserved words, too).</p> <p>This situation will be improved in the future, as <code>jsii</code> will offer an option to only warn about reserved words of languages that are configured for the current project.</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#experimental-features","title":"Experimental Features","text":"<p>Danger</p> <p>The features discussed in this section are experimental. Their behavior may change as bugs are addressed, and requirements are clarified through early adopters. Use at your own risk, and don't forget to report bugs you encounter while doing so!</p>"},{"location":"user-guides/lib-author/toolchain/jsii/#-strip-deprecated","title":"<code>--strip-deprecated</code>","text":"<p>The <code>--strip-deprecated</code> option modifies the compilation flow such that all declarations (types, members) documented with the <code>@deprecated</code> tag will be erased from the visible API of the module:</p> <ul> <li>They will be removed from the TypeScript declarations (<code>.d.ts</code>) files</li> <li>They will be removed from the <code>.jsii</code> assembly file</li> <li>Inheritance chains of non-<code>@deprecated</code> types will have their <code>@deprecated</code>   bases transitively replaced with non-<code>@deprecated</code> bases thereof (or if there   are no such parents, the inheritance relationship will simply be erased)</li> <li>Errors will be reported for each remaining use of a <code>@deprecated</code> type in the   API (this includes property types, method parameter types, and method return   types)</li> </ul> <p>However, in order to ensure the underlying code continues to work as designed, the implementation of such declarations will remain in the JavaScript (<code>.js</code>) files produced by the compilation. This is, in fact, similar to marking all <code>@deprecated</code> members <code>@internal</code>.</p> <p>Additionally, a file name can be passed to the <code>--strip-deprecated</code> option to limit the above behavior to a specific set of allow-listed fully-qualified names. Each line in the file should contain a single fully-qualified name of a declaration that should be stripped. All <code>@deprecated</code> elements not present in the allow list will be retained. An example allowlist file might look like:</p> <pre><code>testpkg.IDeprecated\ntestpkg.DeprecatedOne\ntestpkg.DeprecatedTwo#deprecatedProperty\ntestpkg.DeprecatedTwo#deprecatedMethod\n</code></pre>"},{"location":"user-guides/lib-author/toolchain/jsii/#-add-deprecated-warnings","title":"<code>--add-deprecated-warnings</code>","text":"<p>The <code>--add-deprecated-warnings</code> flag modifies the implementation of all declarations (types, members) documented with the <code>@deprecated</code> flag such that, when the deprecated declaration is used by a dependent, a warning is printed to the console at runtime.</p> <p>This is specifically useful to notify users of a jsii module that they are using deprecated elements and code updates are required.</p> <p>Additionally, the environment variable <code>JSII_DEPRECATED</code> can be set to <code>error</code> or <code>quiet</code> to either fail at runtime or silence these warnings, respectively. By default, this is set to <code>warn</code>.</p> <p>The <code>JSII_DEPRECATED</code> environment variable is respected only on modules compiled with the <code>--add-deprecated-warnings</code> flag.</p>"},{"location":"user-guides/lib-user/","title":"Prerequisites","text":""},{"location":"user-guides/lib-user/#common-runtime","title":"Common Runtime","text":"<p>Regardless of which language or platform your application is developed in, using jsii modules requires a compatible <code>node</code> runtime to be available in <code>$PATH</code>(see Runtime Architecture). Current <code>node</code> runtime versions support status is as follows:</p> <p>The following node releases are part of our test matrix:</p> Release Status End-of-Life <code>^14.6.0</code>  Supported <code>2023-04-30</code> <code>^16.3.0</code>  Supported <code>2024-04-30</code> <code>^18.0.0</code>  Supported <code>2025-04-30</code> Status Definitions <ul> <li> Supported: Long Term Support (LTS) releases  (those with an even major version) are   supported and bugs specific to those releases are addressed with the highest priority. Every <code>jsii</code> release is   automatically tested against those releases.</li> <li> Best effort: Development releases (those with an odd major version) are supported on a   best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors   that we may not be able to fix.</li> </ul> <p>Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the  Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release.</p> <p>The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each).</p>"},{"location":"user-guides/lib-user/language-specific/go/","title":"Go","text":"<p>Go is not a common object-oriented language: the language currently only supports composition, not extension. On the other hand, the jsii type system includes classes and interfaces, which are typically associated with extension-based programming models.</p> <p>In rare circumstances, Go developers may find themselves in a situation where they must implement an abstract base class, extend some class in order to override a method or property, or implement a jsii interface.</p>"},{"location":"user-guides/lib-user/language-specific/go/#implementing-jsii-interfaces","title":"Implementing jsii interfaces","text":"<p>Implementing jsii interfaces leverages the idiomatic go way to implement interfaces: define all the necessary methods on the implementing go struct, and the value can be used naturally.</p> <p>There is a single restriction: all such implementation methods must be defined using a pointer receiver, or a runtime error may occur:</p> <p>Assuming you are consuming a jsii module that defines the following:</p> <pre><code>package jsiimodule\n\nimport (\n\"fmt\"\n)\n\ntype IGreeter interface {\nGreet(greetee string)\n}\n\n// ...\nfunc NewMajestyGreeter(greeter IGreeter) MajestyGreeter {\n// Omitted for brevity\n}\n\n// Does something with the IGreeter that was provided at construction time\nfunc (m MajestyGreeter) Announce(who string) {\nm.greeter.Greet(fmt.Sprintf(\"Your Royal Highness %s\", who))\n}\n</code></pre> <p>You can implement this interface natively in go as:</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\n\"example/jsiimodule\"\n)\n\ntype greeter struct {\n_ byte // padding\n}\n\n// IMPORTANT - this function has a pointer receiver!\nfunc (g *greeter) Greet(greetee string) {\nfmt.Printf(\"Hello, %s!\\n\", greetee)\n}\n\nfunc main() {\ng := &amp;greeter{}\n\n// Simply pass the instance though, it \"just works\".\nmg := jsiimodule.NewMajestyGreeter(g)\n\nmg.Announce(\"Elizabeth II\")\n}\n</code></pre>"},{"location":"user-guides/lib-user/language-specific/go/#extending-and-overriding-classes","title":"Extending and overriding classes","text":"<p>Important</p> <p>Leveraging extension and override goes against the design principles of the go programming language. We advise you avoid using this mechanism unless you have determined that there is no way to achieve the desired result with composition.</p> <p>In particular, if the only element you need to override on a class is it's constructor, you should simply decorate this constructor instead of using the extension and overrides mechanism. For example you can declare an AWS CDK construct (that does not declare new properties or methods) in the following way:</p> <pre><code>package cdkapp\n\nimport (\n\"github.com/aws/aws-cdk-go\"\n\"github.com/aws/aws-cdk-go/aws-s3\"\n)\n\n// Optional: alias the type for clarity\ntype CustomBucket s3.Bucket\n\n// Imagine this builds an S3 bucket with \"special\" defaults. It does not\n// accept s3.BucketProps, instead those are hard-coded in the constructor\n// itself. It could also accept a different properties object, to allow for\n// user settings?\nfunc NewCustomBucket(scope core.Construct, id string) CustomBucket {\nreturn s3.NewBucket(scope, id, s3.BucketProps{\n// ... customized properties\n})\n}\n</code></pre> <p>Classes that are open for extension (including abstract base classes) have a special overriding constructor that can be used when building sub-classes. This override constructor is expected to be called from within the child class constructor that you are writing. This constructor is named using the following convention: <code>New&lt;ClassName&gt;_Override</code>, and receives the overriding struct instance as the first parameter.</p> <p>The go <code>struct</code> that extends the base jsii class must anonymously embed the jsii class' go interface. All overridden method must be defined using a pointer receiver.</p> <p>Assuming the following abstract base class:</p> <pre><code>package jsiimodule\n\ntype AbstractBaseClass interface {\n// Those members have implementations provided, you *may* override them\nConcreteMethod() bool\nConcreteProperty() string\nSetConcreteProperty(v string)\n\n\n// Those members do not have implementations, you *must* implement them\nAbstractMethod() string\nAbstractReadonlyProperty() float64\n}\n\n// NewAbstractBaseClass_Override initializes an overridden AbstractBaseClass\n// instance. The inst parameter receives the go struct that declares the\n// overrides, while the someString and someNumber are parameters to the abstract\n// base class' constructor.\nfunc NewAbstractBaseClass_Override(inst AbstractBaseClass, someString string, someNumber float64) {\n// Omitted for brevity\n}\n</code></pre> <p>You can implement that abstract base class in go in the following way:</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\"strings\"\n\n\"example/jsiimodule\"\n)\n\ntype childClass struct {\n// Anonymous embed of the \"base class\".\njsiimodule.AbstractBaseClass\n\n// Our own storage\nstringValue string\n}\n\n// Provide your own constructor, which delegates to the base class' overriding\n// constructor.\nfunc NewChildClass(stringValue string, someString string, someNumber float64) jsiimodule.AbstractBaseClass {\nc := &amp;childClass{stringValue: stringValue}\n\n// This will take care of setting childClass.AbstractBaseClass!\njsiimodule.NewAbstractBaseClass_Override(c, someString, someNumber)\n\nreturn c\n}\n\n// Then implement the necessary members\nfunc (c *childClass) AbstractMethod() string {\nfmt.Println(\"childClass.AbstractMethod invoked!\")\nreturn c.stringValue\n}\n\nfunc (c *childClass) AbstractReadonlyProperty() float64 {\nfmt.Println(\"childClass.ConcreteProperty read!\")\nreturn 1337\n}\n\n// And overrides those we decided to replace\nfunc (c *childClass) SetConcreteProperty(v string) {\n// We'll just up-case before delegating to the \"super\" implementation.\nc.AbstractBaseClass.SetConcreteProperty(strings.ToUpper(v))\n}\n</code></pre>"},{"location":"user-guides/lib-user/language-specific/go/#unchecked-conversions-using-unsafecast","title":"Unchecked conversions using <code>UnsafeCast</code>","text":"<p>Developers may occasionally need to down-cast a value in order to leverage some other interface it implements. This happens in cases where the runtime is unable to determine the complete dynamic type of a value returned by a function, which happens for example when the TypeScript version of that function returns <code>any</code>, <code>unknown</code>, or a union of several types (which cannot be represented in go).</p> <p>In such cases, traditional go type assertions may not always produce the expected result. Instead, the library that exposes these functions should also expose type-checking utilities (e.g: <code>Stack.isStack(thing: any): boolean</code>) that developers can use to guard an unchecked conversion, which in Go is performed using <code>UnsafeCast</code>.</p> <p>The <code>UnsafeCast</code> function expects two arguments the original value, and a pointer to a variable of the desired interface type.</p> <p>Warning</p> <p>The <code>UnsafeCast</code> function may panic if:</p> <ul> <li>the provided original value was not obtained through a function exported   from a jsii package.</li> <li>the provided pointer is not to a value typed as an interface exported from   a jsii package.</li> </ul> <p>If the original value does, in fact, not implement the target interface type, undefined behavior will occur as a result of using functions of that interface.</p> <p>An example use of the <code>UnsafeCast</code> feature is when using AWS CDK escape hatches:</p> <pre><code>package main\n\nimport (\n\"github.com/aws/aws-cdk-go/awscdk/v2\"\n\"github.com/aws/aws-cdk-go/awscdk/v2/awssns\"\n\"github.com/aws/jsii-runtime-go\"\n)\n\nfunc main() {\napp := awscdk.NewApp(nil)\nstack := awscdk.NewStack(app, jsii.String(\"TestStack\"), nil)\n\ntopic := awssns.NewTopic(stack, jsii.String(\"MyTopic\"), nil)\n\n// We know that topic.Node().DefaultChild() is a awssns.CfnTopic\nvar cfn_topic awssns.CfnTopic\n// We perform the conversion into cfn_topic\njsii.UnsafeCast(topic.Node().DefaultChild(), &amp;cfn_topic)\n// Then we use the conversion result\ncfn_topic.SetDisplayName(jsii.String(\"Overridden Display Name\"))\napp.Synth(nil)\n}\n</code></pre>"},{"location":"user-guides/lib-user/language-specific/python/","title":"Python","text":"<p>Due to the use of a custom metaclass as part of the jsii runtime for Python, certain Python idioms require unusual syntax when jsii modules are involved.</p> <p>Info</p> <p>Our intention is to make working with jsii modules from Python as idiomatic as possible. Removing the custom metaclass usage without breaking existing code is a challenging task, and the situation may consequently remain sub-optional for the near future at least.</p>"},{"location":"user-guides/lib-user/language-specific/python/#implementing-interfaces","title":"Implementing Interfaces","text":"<p>Traditionally, Python developers expect to be able to either implicitly implement an interface by declaring all required members, or explicitly implement interfaces by simply adding the interface to their class' or interface's inheritance chain (and implementing all required members):</p> <p>Incorrect Use</p> <pre><code>from jsii_dependency import IJsiiInterface\n\nclass MyNewClass(IJsiiInterface):\n\"\"\" Traditional implementation of an interface in Python.\n\n    This will not work with interfaces defined by jsii modules, as this will\n    likely cause a metaclass conflict that the user cannot solve.\n    \"\"\"\n\n    # Member implementations...\n\n    ...\n</code></pre> <p>The jsii type system however does not support structural typing, and interfaces must always be explicitly implemented. In order to correctly declare implementation of an interface from a jsii module, the following syntax is used:</p> <pre><code>import jsii\nfrom jsii_dependency import IJsiiInterface\n\n@jsii.implements(IJsiiInterface)\nclass MyNewClass():\n\"\"\" A jsii-supported implementation of the `IJsiiInterface` interface\n\n    This will correctly register the explicit interface implementation on the\n    type's metadata, and ensure instances get correctly serialized to and from\n    the jsii kernel.\n    \"\"\"\n\n    # Member implementations...\n\n    ...\n</code></pre>"},{"location":"user-guides/lib-user/language-specific/python/#property-overrides","title":"Property Overrides","text":"<p>When extending or implementing types provided by jsii modules, properties must always be implemented using a dynamic accessor, ensuring the jsii runtime for Python is able to correctly process access to those by the jsii kernel. This leverages Python's standard <code>@property</code> decorator:</p> <pre><code>from jsii_greeter import Greeter\n\nclass Shouter(Greeter):\n\"\"\" Shouter extends Greeter up-cases the greetee's name.\n\n    The replacement is implemented using a dynamic @property implementation so\n    it works properly with the jsii kernel.\n    \"\"\"\n\n@property\ndef greetee(self) -&gt; str:\n        return super().greetee.upper()\n\n@greetee.setter\ndef greetee(self, value):\n        super().greetee = value\n\n    ...\n</code></pre>"}]}