{"version":3,"file":"name-tree.js","sourceRoot":"","sources":["../src/name-tree.ts"],"names":[],"mappings":";;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,MAAa,QAAQ;IAYnB,2CAA2C;IAC3C;QAJQ,cAAS,GAAiC,EAAE,CAAC;IAI9B,CAAC;IAZjB,MAAM,CAAC,EAAE,CAAC,IAAmB;;QAClC,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;QAChC,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,MAAM,OAAC,IAAI,CAAC,KAAK,mCAAI,EAAE,CAAC,EAAE;YAClD,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SAC7B;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAQD,0CAA0C;IAC1C,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,0EAA0E;IAC1E,IAAW,GAAG;QACZ,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED;;;;;OAKG;IACK,QAAQ,CAAC,GAAW,EAAE,OAAiB,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC;QAC3D,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;SACjB;aAAM;YACL,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC;YAC7B,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;gBACzB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,CAAC;aACvC;YACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SAC3C;QACD,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AA3CD,4BA2CC","sourcesContent":["import * as spec from './assembly';\n\n/**\n * A tree of all names in a module. A node represent a type (terminal)\n * and may represent another node in the namespace (at the same time).\n * Therefore, a key of '_' represents a terminal and references the fqn\n * of the type.\n *\n * For example, say we have the following types:\n *   - aws.ec2.Host\n *   - aws.ec2.Instance\n *   - aws.ec2.Instance.Subtype\n *\n * the the name tree will look like this:\n *\n * module: {\n *   children: {\n *     aws: {\n *       children {\n *         ec2: {\n *           children: {\n *             Host: {\n *               fqn: 'aws.ec2.Host',\n *               children: {}\n *             },\n *             Instance: {\n *               fqn: 'aws.ec2.Host',\n *               children: {\n *                 Subtype: {\n *                   fqn: 'aws.ec2.Host.Subtype',\n *                   children: {}\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * }\n */\nexport class NameTree {\n  public static of(assm: spec.Assembly): NameTree {\n    const nameTree = new NameTree();\n    for (const type of Object.values(assm.types ?? {})) {\n      nameTree.register(type.fqn);\n    }\n    return nameTree;\n  }\n\n  private _children: { [name: string]: NameTree } = {};\n  private _fqn?: string;\n\n  /* NameTree.of(assembly) should be used. */\n  private constructor() {}\n\n  /** The children of this node, by name. */\n  public get children(): { readonly [name: string]: NameTree } {\n    return this._children;\n  }\n\n  /** The fully qualified name of the type at this node, if there is one. */\n  public get fqn(): string | undefined {\n    return this._fqn;\n  }\n\n  /**\n   * Adds a type to this ``NameTree``.\n   *\n   * @param type the type to be added.\n   * @param path the path at which to add the node under this tree.\n   */\n  private register(fqn: string, path: string[] = fqn.split('.')): this {\n    if (path.length === 0) {\n      this._fqn = fqn;\n    } else {\n      const [head, ...rest] = path;\n      if (!this._children[head]) {\n        this._children[head] = new NameTree();\n      }\n      this._children[head]!.register(fqn, rest);\n    }\n    return this;\n  }\n}\n"]}