{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"path\"","webpack:///external \"fs\"","webpack:////Users/valinm/dev/jsii/node_modules/graceful-fs/graceful-fs.js","webpack:////Users/valinm/dev/jsii/node_modules/universalify/index.js","webpack:///../kernel/node_modules/fs-extra/lib/mkdirs/index.js","webpack:///../kernel/node_modules/fs-extra/lib/path-exists/index.js","webpack:////Users/valinm/dev/jsii/node_modules/jsonschema/lib/helpers.js","webpack:///external \"assert\"","webpack:///../kernel/node_modules/tar/lib/high-level-opt.js","webpack:///../kernel/node_modules/minipass/index.js","webpack:///external \"events\"","webpack:///../kernel/node_modules/tar/lib/header.js","webpack:///../kernel/node_modules/fs-minipass/index.js","webpack:///../kernel/lib/api.ts","webpack:///../kernel/node_modules/fs-extra/lib/fs/index.js","webpack:///../kernel/node_modules/fs-extra/lib/util/stat.js","webpack:///../kernel/node_modules/fs-extra/lib/remove/index.js","webpack:///../kernel/node_modules/tar/lib/read-entry.js","webpack:///../kernel/node_modules/tar/lib/types.js","webpack:///../kernel/node_modules/tar/lib/parse.js","webpack:///external \"util\"","webpack:///../kernel/node_modules/jsonfile/utils.js","webpack:///../kernel/node_modules/fs-extra/lib/output/index.js","webpack:///../spec/lib/index.ts","webpack:///external \"url\"","webpack:////Users/valinm/dev/jsii/node_modules/jsonschema/lib/scan.js","webpack:///../kernel/node_modules/tar/lib/pack.js","webpack:///../kernel/node_modules/yallist/yallist.js","webpack:///../kernel/node_modules/tar/lib/pax.js","webpack:///../kernel/node_modules/tar/lib/warn-mixin.js","webpack:///../kernel/node_modules/tar/lib/list.js","webpack:///../kernel/lib/index.ts","webpack:///external \"stream\"","webpack:///../kernel/node_modules/fs-extra/lib/copy-sync/index.js","webpack:////Users/valinm/dev/jsii/node_modules/at-least-node/index.js","webpack:///../kernel/node_modules/fs-extra/lib/util/utimes.js","webpack:///../kernel/node_modules/fs-extra/lib/copy/index.js","webpack:///../kernel/node_modules/minizlib/index.js","webpack:///external \"zlib\"","webpack:///../kernel/node_modules/tar/lib/write-entry.js","webpack:///../kernel/node_modules/tar/lib/winchars.js","webpack:///../kernel/node_modules/tar/lib/replace.js","webpack:///../kernel/node_modules/tar/lib/unpack.js","webpack:///../kernel/node_modules/mkdirp/lib/mkdirp-manual.js","webpack:///../kernel/lib/objects.ts","webpack:///../kernel/lib/serialization.ts","webpack:///./lib/program.ts","webpack:///./lib/host.ts","webpack:///../kernel/lib/kernel.ts","webpack:///(webpack)/buildin/module.js","webpack:///../kernel/node_modules/fs-extra/lib/index.js","webpack:////Users/valinm/dev/jsii/node_modules/graceful-fs/polyfills.js","webpack:///external \"constants\"","webpack:////Users/valinm/dev/jsii/node_modules/graceful-fs/legacy-streams.js","webpack:////Users/valinm/dev/jsii/node_modules/graceful-fs/clone.js","webpack:///../kernel/node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack:///../kernel/node_modules/fs-extra/lib/mkdirs/make-dir.js","webpack:///../kernel/node_modules/fs-extra/lib/copy/copy.js","webpack:///../kernel/node_modules/fs-extra/lib/empty/index.js","webpack:///../kernel/node_modules/fs-extra/lib/remove/rimraf.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/index.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/file.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/link.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/symlink.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack:///../kernel/node_modules/fs-extra/lib/ensure/symlink-type.js","webpack:///../kernel/node_modules/fs-extra/lib/json/index.js","webpack:///../kernel/node_modules/fs-extra/lib/json/jsonfile.js","webpack:///../kernel/node_modules/jsonfile/index.js","webpack:///../kernel/node_modules/fs-extra/lib/json/output-json.js","webpack:///../kernel/node_modules/fs-extra/lib/json/output-json-sync.js","webpack:///../kernel/node_modules/fs-extra/lib/move-sync/index.js","webpack:///../kernel/node_modules/fs-extra/lib/move-sync/move-sync.js","webpack:///../kernel/node_modules/fs-extra/lib/move/index.js","webpack:///../kernel/node_modules/fs-extra/lib/move/move.js","webpack:///../spec/lib/assembly.ts","webpack:///../spec/lib/name-tree.ts","webpack:///../spec/lib/validate-assembly.ts","webpack:////Users/valinm/dev/jsii/node_modules/jsonschema/lib/index.js","webpack:////Users/valinm/dev/jsii/node_modules/jsonschema/lib/validator.js","webpack:////Users/valinm/dev/jsii/node_modules/jsonschema/lib/attribute.js","webpack:///external \"os\"","webpack:///../kernel/node_modules/tar/index.js","webpack:///../kernel/node_modules/tar/lib/create.js","webpack:///../kernel/node_modules/yallist/iterator.js","webpack:///external \"string_decoder\"","webpack:///external \"buffer\"","webpack:///../kernel/node_modules/minizlib/constants.js","webpack:///../kernel/node_modules/tar/lib/large-numbers.js","webpack:///../kernel/node_modules/tar/lib/mode-fix.js","webpack:///../kernel/node_modules/tar/lib/update.js","webpack:///../kernel/node_modules/tar/lib/extract.js","webpack:///../kernel/node_modules/tar/lib/mkdir.js","webpack:///../kernel/node_modules/mkdirp/index.js","webpack:///../kernel/node_modules/mkdirp/lib/opts-arg.js","webpack:///../kernel/node_modules/mkdirp/lib/path-arg.js","webpack:///../kernel/node_modules/mkdirp/lib/mkdirp-native.js","webpack:///../kernel/node_modules/mkdirp/lib/find-made.js","webpack:///../kernel/node_modules/mkdirp/lib/use-native.js","webpack:///../kernel/node_modules/chownr/chownr.js","webpack:///../kernel/node_modules/tar/lib/path-reservations.js","webpack:///external \"crypto\"","webpack:///../kernel/node_modules/tar/lib/get-write-flag.js","webpack:///external \"vm\"","webpack:///external \"module\"","webpack:///./lib/in-out.ts","webpack:///./lib/sync-stdio.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,iC;;;;;;ACAA,+B;;;;;;ACAA,SAAS,mBAAO,CAAC,CAAI;AACrB,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,aAAa,mBAAO,CAAC,EAAqB;AAC1C,YAAY,mBAAO,CAAC,EAAY;;AAEhC,WAAW,mBAAO,CAAC,EAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM,mBAAO,CAAC,CAAQ;AACtB,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjWY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,WAAW,iBAAiB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,WAAW,iBAAiB;AAC/B;;;;;;;;ACtBY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,OAAO,iCAAiC,GAAG,mBAAO,CAAC,EAAY;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbY;AACZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,EAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACXa;;AAEb,UAAU,mBAAO,CAAC,EAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D;AAC3D;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;AAClB,WAAW;AACX,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,EAAE,WAAW,EAAE,QAAQ,EAAE;AAC7C,eAAe,EAAE,WAAW,EAAE,QAAQ,EAAE;AACxC;;AAEA,iDAAiD,IAAI,yCAAyC,IAAI,iDAAiD,KAAK,kDAAkD,KAAK,iCAAiC,IAAI,sBAAsB,EAAE,WAAW,IAAI;AAC3R,iEAAiE,EAAE;AACnE,8BAA8B,IAAI,GAAG,EAAE,aAAa,IAAI,mBAAmB,IAAI,GAAG,EAAE,cAAc,IAAI,yEAAyE,EAAE,oBAAoB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,2EAA2E,EAAE,oBAAoB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,2EAA2E,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,qBAAqB,IAAI,GAAG,EAAE,gBAAgB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE,yBAAyB,IAAI,EAAE,IAAI,iBAAiB,IAAI,EAAE,IAAI,yEAAyE,EAAE;AACjjC;;AAEA,6BAA6B,EAAE,EAAE,IAAI;;AAErC;AACA,qBAAqB,MAAM,kCAAkC,KAAK,kDAAkD,KAAK;AACzH,sBAAsB,MAAM,kCAAkC,KAAK,kDAAkD,KAAK;;AAE1H;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,4BAA4B,IAAI;AAChC,2BAA2B,KAAK;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACnUA,mC;;;;;;;ACAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5BY;AACZ,WAAW,mBAAO,CAAC,EAAQ;AAC3B,eAAe,mBAAO,CAAC,EAAQ;AAC/B,gBAAgB,mBAAO,CAAC,EAAS;AACjC,WAAW,mBAAO,CAAC,EAAgB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;;AAE1D;AACA,gCAAgC,aAAa;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChiBA,mC;;;;;;;ACAY;AACZ;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,EAAY;AAClC,mBAAmB,mBAAO,CAAC,CAAM;AACjC,cAAc,mBAAO,CAAC,EAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/RY;AACZ,iBAAiB,mBAAO,CAAC,CAAU;AACnC,WAAW,mBAAO,CAAC,EAAQ;AAC3B,WAAW,mBAAO,CAAC,CAAI;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb,eAAe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAa;AACb,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AAC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A;AACA;;;;;;;;AC/HY;;AAEZ,WAAW,mBAAO,CAAC,EAAO;AAC1B,aAAa,mBAAO,CAAC,CAAM;AAC3B,aAAa,mBAAO,CAAC,EAAM;AAC3B,oBAAoB,mBAAO,CAAC,EAAe;;AAE3C;AACA,2DAA2D,eAAe;AAC1E,mEAAmE,eAAe;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC,oBAAoB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,GAAG;AACH;;AAEA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS,IAAI,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1IY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,eAAe,mBAAO,CAAC,EAAU;;AAEjC;AACA;AACA;AACA;;;;;;;;ACRY;AACZ,cAAc,mBAAO,CAAC,EAAY;AAClC,iBAAiB,mBAAO,CAAC,CAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjGY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC3CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAiB;AACxC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAa;AACpC,WAAW,mBAAO,CAAC,EAAQ;AAC3B,gBAAgB,mBAAO,CAAC,EAAS;AACjC;AACA,cAAc,mBAAO,CAAC,EAAiB;AACvC,YAAY,mBAAO,CAAC,EAAU;AAC9B,aAAa,mBAAO,CAAC,EAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA,gEAAgE,OAAO;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,KAAK,eAAe,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACleD,iC;;;;;;ACAA,qCAAqC;AACrC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;ACdN;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,CAAW;AACjC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvCA,+CAA2B;AAC3B,+CAAgC;AAChC,+CAA4B;AAC5B,+CAAoC;;;;;;;ACHpC,gC;;;;;;;ACCA,aAAa,mBAAO,CAAC,EAAK;AAC1B,cAAc,mBAAO,CAAC,CAAW;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,CAAU;AACnC,aAAa,mBAAO,CAAC,EAAU;AAC/B,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,mBAAmB,mBAAO,CAAC,EAAkB;AAC7C;AACA;AACA,gBAAgB,mBAAO,CAAC,EAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,EAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;;;;;;;AClZY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,8BAA8B;AACnE;AACA;;AAEA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,EAAE,mBAAO,CAAC,EAAe;AACzB,CAAC;;;;;;;;ACzaW;AACZ,eAAe,mBAAO,CAAC,EAAa;AACpC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChJY;AACZ;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,oDAAoD,KAAK,IAAI,QAAQ;AACrE;AACA;;;;;;;;ACpBY;;AAEZ;AACA;;AAEA;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,eAAe,mBAAO,CAAC,EAAY;AACnC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AC/HA,+CAAyB;AAEzB,oCAA6B;AACpB,kBAAG;;;;;;;ACHZ,mC;;;;;;;ACAY;;AAEZ;AACA,YAAY,mBAAO,CAAC,EAAa;AACjC;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;ACJY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACzBY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B;;;;;;;;ACLY;;AAEZ,eAAe,mBAAO,CAAC,CAAQ;AAC/B,eAAe,mBAAO,CAAC,EAAQ;AAC/B,iBAAiB,mBAAO,CAAC,EAAM;;AAE/B,sCAAsC,mBAAO,CAAC,EAAgB;AAC9D,iBAAiB,mBAAO,CAAC,CAAU;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,0BAA0B;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3VA,iC;;;;;;;ACAY;AACZ,iBAAiB,mBAAO,CAAC,CAAU;AACnC,YAAY,mBAAO,CAAC,EAAU;AAC9B,eAAe,mBAAO,CAAC,EAAa;AACpC,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;;AAE3B,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,EAAiB;AACxC,iBAAiB,mBAAO,CAAC,EAAe;;AAExC,gBAAgB,mBAAO,CAAC,EAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,yBAAyB,GAAG;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,+CAA+C,SAAS;AACxD;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnbY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtBY;;AAEZ;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,aAAa,mBAAO,CAAC,EAAW;AAChC,cAAc,mBAAO,CAAC,EAAY;AAClC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,UAAU,mBAAO,CAAC,EAAW;AAC7B,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAa;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,oBAAoB;AACpD,qCAAqC,cAAc;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;AC1NY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,CAAQ;AAC/B,WAAW,mBAAO,CAAC,EAAQ;AAC3B,eAAe,mBAAO,CAAC,EAAY;AACnC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA,WAAW,mBAAO,CAAC,EAAe;AAClC,yBAAyB,mBAAO,CAAC,GAAwB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,GAAQ;AAC/B,gBAAgB,mBAAO,CAAC,GAAqB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW,IAAI,MAAM;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;A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A;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACrVA,sC;;;;;;ACAA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrHY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;AClBY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,mBAAmB,mBAAO,CAAC,CAAW;AACtC,yBAAyB,mBAAO,CAAC,EAAgB;AACjD,aAAa,mBAAO,CAAC,EAAc;;AAEnC;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA,SAAS,oBAAoB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK,oBAAoB,IAAI;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,kCAAkC,aAAa;AACjG;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,UAAU,YAAY;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACY;AACZ,WAAW,mBAAO,CAAC,EAAO;AAC1B,aAAa,mBAAO,CAAC,CAAM;AAC3B,oBAAoB,mBAAO,CAAC,EAAe;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mEAAmE,IAAI;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,8CAA8C;AAC9C,UAAU;AACV;;AAEA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC5IY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,CAAW;AAClC,mBAAmB,mBAAO,CAAC,CAAgB;AAC3C,qBAAqB,mBAAO,CAAC,EAAgB;AAC7C,aAAa,mBAAO,CAAC,EAAc;;AAEnC;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,4BAA4B,KAAK;AACjC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2DAA2D,KAAK,oBAAoB,IAAI;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACvOY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,cAAc,mBAAO,CAAC,CAAW;AACjC,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,CAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC7SY;;AAEZ,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,gBAAgB,mBAAO,CAAC,EAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpEY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,cAAc,mBAAO,CAAC,CAAW;AACjC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC5DY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,gBAAgB,mBAAO,CAAC,CAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,EAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,EAAgB;AAC7C;AACA;;AAEA,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9DY;;AAEZ,aAAa,mBAAO,CAAC,CAAM;AAC3B,WAAW,mBAAO,CAAC,CAAa;AAChC,mBAAmB,mBAAO,CAAC,CAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,CAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9BY;;AAEZ,UAAU,mBAAO,CAAC,CAAc;AAChC,iBAAiB,mBAAO,CAAC,EAAY;;AAErC,wBAAwB,mBAAO,CAAC,EAAe;AAC/C,0BAA0B,mBAAO,CAAC,EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACfY;;AAEZ,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC;AACA;AACA;AACA;A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,CAAC,CAAW;AACpD,iCAAiC,mBAAO,CAAC,CAAW;AACpD,6BAA6B,mBAAO,CAAC,CAAW;AAChD,kCAAkC,mBAAO,CAAC,EAAQ;AAClD,sBAAsB,mBAAO,CAAC,EAAQ;;AAEtC;AACA;AACA;AACA;;;;;;;;ACba;;AAEb,aAAa,mBAAO,CAAC,EAAK;;AAE1B,gBAAgB,mBAAO,CAAC,EAAa;AACrC,cAAc,mBAAO,CAAC,CAAW;AACjC,iBAAiB,mBAAO,CAAC,EAAQ;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/Ta;;AAEb,cAAc,mBAAO,CAAC,CAAW;;AAEjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAqD;AACxE;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;ACnzBA,+B;;;;;;;ACAY;;AAEZ;AACA,6BAA6B,mBAAO,CAAC,EAAiB;AACtD,8BAA8B,mBAAO,CAAC,EAAkB;AACxD,2BAA2B,mBAAO,CAAC,EAAe;AAClD,6BAA6B,mBAAO,CAAC,EAAiB;AACtD,8BAA8B,mBAAO,CAAC,EAAkB;;AAExD;AACA,eAAe,mBAAO,CAAC,EAAe;AACtC,iBAAiB,mBAAO,CAAC,EAAiB;AAC1C,gBAAgB,mBAAO,CAAC,EAAgB;AACxC,oBAAoB,mBAAO,CAAC,EAAqB;AACjD,qBAAqB,mBAAO,CAAC,EAAsB;AACnD,iBAAiB,mBAAO,CAAC,EAAiB;AAC1C,cAAc,mBAAO,CAAC,EAAc;AACpC,gBAAgB,mBAAO,CAAC,EAAgB;;;;;;;;ACjB5B;;AAEZ;AACA,YAAY,mBAAO,CAAC,CAAqB;;AAEzC,aAAa,mBAAO,CAAC,EAAW;AAChC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,UAAU,mBAAO,CAAC,EAAW;AAC7B,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACxGY;AACZ;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;;;;;;ACPA,2C;;;;;;ACAA,mC;;;;;;ACAA;AACA;AACA;AACA;AACA,0BAA0B,mBAAO,CAAC,EAAM;AACxC,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;AClHW;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AChGY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBY;;AAEZ;;AAEA,YAAY,mBAAO,CAAC,CAAqB;AACzC,UAAU,mBAAO,CAAC,EAAc;AAChC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACnCY;;AAEZ;AACA,YAAY,mBAAO,CAAC,CAAqB;AACzC,eAAe,mBAAO,CAAC,EAAa;AACpC,WAAW,mBAAO,CAAC,CAAI;AACvB,YAAY,mBAAO,CAAC,EAAa;AACjC,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/GY;AACZ;;AAEA;AACA;;AAEA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;AAC3B,eAAe,mBAAO,CAAC,GAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,wBAAwB,KAAK;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;;;;;AC7MA,gBAAgB,mBAAO,CAAC,EAAmB;AAC3C,gBAAgB,mBAAO,CAAC,EAAmB;;AAE3C,OAAO,+BAA+B,GAAG,mBAAO,CAAC,EAAwB;AACzE,OAAO,+BAA+B,GAAG,mBAAO,CAAC,EAAwB;AACzE,OAAO,yBAAyB,GAAG,mBAAO,CAAC,GAAqB;;;AAGhE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9BA,OAAO,YAAY,GAAG,mBAAO,CAAC,EAAM;AACpC,WAAW,mBAAO,CAAC,CAAI;AACvB;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA,OAAO,iBAAiB,GAAG,mBAAO,CAAC,CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;AC5BA,OAAO,QAAQ,GAAG,mBAAO,CAAC,CAAM;AAChC,OAAO,uBAAuB,GAAG,mBAAO,CAAC,GAAgB;AACzD,OAAO,+BAA+B,GAAG,mBAAO,CAAC,EAAoB;;AAErE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;ACtClB,OAAO,QAAQ,GAAG,mBAAO,CAAC,CAAM;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;AC5BlB,WAAW,mBAAO,CAAC,CAAI;;AAEvB;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;;ACTN;AACZ,WAAW,mBAAO,CAAC,CAAI;AACvB,aAAa,mBAAO,CAAC,CAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,CAAQ;;AAE/B;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA,SAAS,OAAO,GAAG,mBAAO,CAAC,CAAM;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;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","file":"jsii-runtime.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 46);\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nfunction publishQueue(context, queue) {\n  Object.defineProperty(context, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!fs[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = global[gracefulQueue] || []\n  publishQueue(fs, queue)\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(fs[gracefulQueue])\n      require('assert').equal(fs[gracefulQueue].length, 0)\n    })\n  }\n}\n\nif (!global[gracefulQueue]) {\n  publishQueue(global, fs[gracefulQueue]);\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  fs[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = fs[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.apply(\n          this,\n          args.concat([(err, res) => err ? reject(err) : resolve(res)])\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict';\n\nvar uri = require('url');\n\nvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {\n  if (propertyPath) {\n    this.property = propertyPath;\n  }\n  if (message) {\n    this.message = message;\n  }\n  if (schema) {\n    if (schema.id) {\n      this.schema = schema.id;\n    } else {\n      this.schema = schema;\n    }\n  }\n  if (instance) {\n    this.instance = instance;\n  }\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);\n  }\n\n  if (this.throwError) {\n    throw err;\n  }\n  this.errors.push(err);\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || (res && res.validatorType)) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer (v,i){\n  return i+': '+v.toString()+'\\n';\n}\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n  return !this.errors.length;\n} });\n\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\nvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype,\n  { constructor: {value: SchemaError, enumerable: false}\n  , name: {value: 'SchemaError', enumerable: false}\n  });\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  this.propertyPath = propertyPath;\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve (target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);\n  var base = uri.resolve(this.base, schema.id||'');\n  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));\n  if(schema.id && !ctx.schemas[base]){\n    ctx.schemas[base] = schema;\n  }\n  return ctx;\n}\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/\n};\n\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat (input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats &&\n      typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n  key = key.toString();\n  // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict (a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n  return a === b;\n};\n\nfunction deepMerger (target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e)\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e)\n    }\n  }\n}\n\nfunction copyist (src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge (target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  }\n  else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key])\n    }\n  }\n}\n\nfunction deepMerge (target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n};\n\nmodule.exports.deepMerge = deepMerge;\n\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n  while (typeof (k=parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n  return o;\n};\n\nfunction pathEncoder (v) {\n  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\nexports.encodePath = function encodePointer(a){\n\t// ~ must be encoded explicitly because hacks\n\t// the slash is encoded by encodeURIComponent\n\treturn a.map(pathEncoder).join('');\n};\n\n\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};\n\n","module.exports = require(\"assert\");","'use strict'\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow']\n])\n\nconst parse = module.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k]\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n","'use strict'\nconst EE = require('events')\nconst Stream = require('stream')\nconst Yallist = require('yallist')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    if (this.flowing) {\n      // if we somehow have something in the buffer, but we think we're\n      // flowing, then we need to flush all that out first, or we get\n      // chunks coming in out of order.  Can't emit 'drain' here though,\n      // because we're mid-write, so that'd be bad.\n      if (this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n      this.emit('data', chunk)\n    } else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      cb()\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n","module.exports = require(\"events\");","'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n    : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8 : 0o7777777\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n   string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n","'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n","export const TOKEN_REF = '$jsii.byref';\nexport const TOKEN_INTERFACES = '$jsii.interfaces';\nexport const TOKEN_DATE = '$jsii.date';\nexport const TOKEN_ENUM = '$jsii.enum';\nexport const TOKEN_MAP = '$jsii.map';\nexport const TOKEN_STRUCT = '$jsii.struct';\n\nexport interface ObjRef {\n  readonly [TOKEN_REF]: string;\n}\n\nexport interface AnnotatedObjRef extends ObjRef {\n  [TOKEN_INTERFACES]?: readonly string[];\n}\n\nexport function isObjRef(value: any): value is ObjRef {\n  return typeof value === 'object' && value !== null && TOKEN_REF in value;\n}\n\nexport interface WireDate {\n  readonly [TOKEN_DATE]: string;\n}\n\nexport function isWireDate(value: any): value is WireDate {\n  return typeof value === 'object' && value !== null && TOKEN_DATE in value;\n}\n\nexport interface WireEnum {\n  readonly [TOKEN_ENUM]: string;\n}\n\nexport function isWireEnum(value: any): value is WireEnum {\n  return typeof value === 'object' && value !== null && TOKEN_ENUM in value;\n}\n\nexport interface WireMap {\n  readonly [TOKEN_MAP]: { readonly [key: string]: any };\n}\n\nexport function isWireMap(value: any): value is WireMap {\n  return typeof value === 'object' && value !== null && TOKEN_MAP in value;\n}\n\nexport interface WireStruct {\n  readonly [TOKEN_STRUCT]: {\n    readonly fqn: string;\n    readonly data: { [key: string]: any };\n  };\n}\n\nexport function isWireStruct(value: any): value is WireStruct {\n  return typeof value === 'object' && value !== null && TOKEN_STRUCT in value;\n}\n\nexport type Override = MethodOverride | PropertyOverride;\n\nexport interface MethodOverride {\n  readonly method: string;\n  readonly cookie?: string;\n}\n\nexport function isMethodOverride(value: Override): value is MethodOverride {\n  return (value as any).method != null; // Python passes \"null\"\n}\n\nexport interface PropertyOverride {\n  readonly property: string;\n  readonly cookie?: string;\n}\n\nexport function isPropertyOverride(value: Override): value is PropertyOverride {\n  return (value as any).property != null; // Python passes \"null\"\n}\n\nexport interface Callback {\n  readonly cbid: string;\n  readonly cookie: string | undefined;\n  readonly invoke?: InvokeRequest;\n  readonly get?: GetRequest;\n  readonly set?: SetRequest;\n}\n\nexport interface HelloResponse {\n  readonly hello: string;\n}\n\nexport interface LoadRequest {\n  /** The name of the assembly */\n  readonly name: string;\n\n  /** Assembly version */\n  readonly version: string;\n\n  /** The tarball of the package */\n  readonly tarball: string;\n}\n\nexport interface LoadResponse {\n  readonly assembly: string;\n  readonly types: number;\n}\n\nexport interface CreateRequest {\n  /**\n   * The FQN of the class of which an instance is requested (or \"Object\")\n   */\n  readonly fqn: string;\n\n  /**\n   * The FQNs of interfaces the instance implements, if any. Declaring\n   * interfaces that the class denoted by `fqn` implements is not necessary.\n   * This means that memebers of interfaces found in this property should\n   * declare members that are found in the `overrides` property.\n   */\n  readonly interfaces?: string[];\n\n  /**\n   * Arguments to pass to the constructor of `fqn`. (\"Object\" accepts none)\n   */\n  readonly args?: any[];\n\n  /**\n   * Declarations of method overrides that should trigger callbacks\n   */\n  readonly overrides?: Override[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CreateResponse extends AnnotatedObjRef {}\n\nexport interface DelRequest {\n  readonly objref: ObjRef;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface DelResponse {}\n\nexport interface GetRequest {\n  readonly objref: ObjRef;\n  readonly property: string;\n}\n\nexport interface StaticGetRequest {\n  readonly fqn: string;\n  readonly property: string;\n}\n\nexport interface GetResponse {\n  readonly value: any;\n}\n\nexport interface StaticSetRequest {\n  readonly fqn: string;\n  readonly property: string;\n  readonly value: any;\n}\n\nexport interface SetRequest {\n  readonly objref: ObjRef;\n  readonly property: string;\n  readonly value: any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface SetResponse {}\n\nexport interface StaticInvokeRequest {\n  readonly fqn: string;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface InvokeRequest {\n  readonly objref: ObjRef;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface InvokeResponse {\n  readonly result: any;\n}\n\nexport interface BeginRequest {\n  readonly objref: ObjRef;\n  readonly method: string;\n  readonly args?: any[];\n}\n\nexport interface BeginResponse {\n  readonly promiseid: string;\n}\n\nexport interface EndRequest {\n  readonly promiseid: string;\n}\n\nexport interface EndResponse {\n  readonly result: any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CallbacksRequest {}\n\nexport interface CallbacksResponse {\n  readonly callbacks: Callback[];\n}\n\nexport interface CompleteRequest {\n  readonly cbid: string;\n  readonly err?: string;\n  readonly result?: any;\n}\n\nexport interface CompleteResponse {\n  readonly cbid: string;\n}\n\nexport interface NamingRequest {\n  readonly assembly: string;\n}\n\nexport interface NamingResponse {\n  readonly naming: {\n    readonly [language: string]: { readonly [key: string]: any } | undefined;\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface StatsRequest {}\n\nexport interface StatsResponse {\n  readonly objectCount: number;\n}\n\nexport type KernelRequest =\n  | LoadRequest\n  | CreateRequest\n  | DelRequest\n  | GetRequest\n  | SetRequest\n  | InvokeRequest\n  | BeginRequest\n  | EndRequest\n  | CallbacksRequest\n  | CompleteRequest\n  | NamingRequest\n  | StatsRequest;\n\nexport type KernelResponse =\n  | HelloResponse\n  | LoadResponse\n  | CreateResponse\n  | DelResponse\n  | GetResponse\n  | SetResponse\n  | InvokeResponse\n  | BeginResponse\n  | EndResponse\n  | CallbacksResponse\n  | CompleteResponse\n  | NamingResponse\n  | StatsResponse;\n\nexport interface OkayResponse {\n  readonly ok: any;\n}\n\nexport interface ErrorResponse {\n  readonly error: string;\n  readonly stack?: string;\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.opendir was added in Node.js v12.12.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.writev only available in Node v12.9.0+\nif (typeof fs.writev === 'function') {\n  // Function signature is\n  // s.writev(fd, buffers[, position], callback)\n  // We need to handle the optional arg, so we use ...args\n  exports.writev = function (fd, buffers, ...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      return fs.writev(fd, buffers, ...args)\n    }\n\n    return new Promise((resolve, reject) => {\n      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n        if (err) return reject(err)\n        resolve({ bytesWritten, buffers })\n      })\n    })\n  }\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n","'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\nconst atLeastNode = require('at-least-node')\n\nconst nodeSupportsBigInt = atLeastNode('10.5.0')\nconst stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)\nconst statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)\n\nfunction getStats (src, dest) {\n  return Promise.all([\n    stat(src),\n    stat(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest) {\n  let destStat\n  const srcStat = statSync(src)\n  try {\n    destStat = statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  const callback = (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  }\n  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)\n  else fs.stat(destParent, callback)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = statSync(destParent)\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true\n    }\n    // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n    if (destStat.size === srcStat.size &&\n        destStat.mode === srcStat.mode &&\n        destStat.nlink === srcStat.nlink &&\n        destStat.atimeMs === srcStat.atimeMs &&\n        destStat.mtimeMs === srcStat.mtimeMs &&\n        destStat.ctimeMs === srcStat.ctimeMs &&\n        destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true\n    }\n  }\n  return false\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","'use strict'\nconst types = require('./types.js')\nconst MiniPass = require('minipass')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = header.path\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = header.linkpath\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) this[SLURP](ex)\n    if (gex) this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n}\n","'use strict'\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader']\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n","'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst path = require('path')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null)\n      this[SAW_VALID_ENTRY] = false\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin')\n          this[STATE] = 'header'\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid)\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})\n      else if (!header.path)\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})\n      else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})\n        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})\n        else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid)\n                  this[SAW_VALID_ENTRY] = true\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain)\n                this[STATE] = 'body'\n              else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else\n                this[QUEUE].push(entry)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, {entry})\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING])\n      this[BUFFERCONCAT](chunk)\n    else if (!chunk && !this[BUFFER])\n      this[MAYBEEND]()\n    else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n","module.exports = require(\"util\");","function stringify (obj, options = {}) {\n  const EOL = options.EOL || '\\n'\n\n  const str = JSON.stringify(obj, options ? options.replacer : null, options.spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  return content.replace(/^\\uFEFF/, '')\n}\n\nmodule.exports = { stringify, stripBom }\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","export * from './assembly';\nexport * from './configuration';\nexport * from './name-tree';\nexport * from './validate-assembly';\n","module.exports = require(\"url\");","\nvar urilib = require('url');\nvar helpers = require('./helpers');\n\nmodule.exports.SchemaScanResult = SchemaScanResult;\nfunction SchemaScanResult(found, ref){\n  this.id = found;\n  this.ref = ref;\n}\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param string uri\n * @param object schema\n * @return {Object}\n */\nmodule.exports.scan = function scan(base, schema){\n  function scanSchema(baseuri, schema){\n    if(!schema || typeof schema!='object') return;\n    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n    if(schema.$ref){\n      var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;\n      return;\n    }\n    var ourBase = schema.id ? urilib.resolve(baseuri, schema.id) : baseuri;\n    if (ourBase) {\n      // If there's no fragment, append an empty one\n      if(ourBase.indexOf('#')<0) ourBase += '#';\n      if(found[ourBase]){\n        if(!helpers.deepCompareStrict(found[ourBase], schema)){\n          throw new Error('Schema <'+schema+'> already exists with different definition');\n        }\n        return found[ourBase];\n      }\n      found[ourBase] = schema;\n      // strip trailing fragment\n      if(ourBase[ourBase.length-1]=='#'){\n        found[ourBase.substring(0, ourBase.length-1)] = schema;\n      }\n    }\n    scanArray(ourBase+'/items', (Array.isArray(schema.items)?schema.items:[schema.items]));\n    scanArray(ourBase+'/extends', (Array.isArray(schema.extends)?schema.extends:[schema.extends]));\n    scanSchema(ourBase+'/additionalItems', schema.additionalItems);\n    scanObject(ourBase+'/properties', schema.properties);\n    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);\n    scanObject(ourBase+'/definitions', schema.definitions);\n    scanObject(ourBase+'/patternProperties', schema.patternProperties);\n    scanObject(ourBase+'/dependencies', schema.dependencies);\n    scanArray(ourBase+'/disallow', schema.disallow);\n    scanArray(ourBase+'/allOf', schema.allOf);\n    scanArray(ourBase+'/anyOf', schema.anyOf);\n    scanArray(ourBase+'/oneOf', schema.oneOf);\n    scanSchema(ourBase+'/not', schema.not);\n  }\n  function scanArray(baseuri, schemas){\n    if(!Array.isArray(schemas)) return;\n    for(var i=0; i<schemas.length; i++){\n      scanSchema(baseuri+'/'+i, schemas[i]);\n    }\n  }\n  function scanObject(baseuri, schemas){\n    if(!schemas || typeof schemas!='object') return;\n    for(var p in schemas){\n      scanSchema(baseuri+'/'+p, schemas[p]);\n    }\n  }\n\n  var found = {};\n  var ref = {};\n  var schemaUri = base;\n  scanSchema(base, schema);\n  return new SchemaScanResult(found, ref);\n}\n","'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      if (this.portable)\n        opt.gzip.portable = true\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p.path)\n    if (this.prefix)\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\n\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p)\n    if (this.prefix)\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\n\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","'use strict'\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n       ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ?  new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n","'use strict'\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file)\n      data.file = this.file\n    if (this.cwd)\n      data.cwd = this.cwd\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n  }\n}\n","'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n","export * from './kernel';\n\nimport * as api from './api';\nexport { api };\n","module.exports = require(\"stream\");","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","module.exports = r => {\n  const n = process.versions.node.split('.').map(x => parseInt(x, 10))\n  r = r.split('.').map(x => parseInt(x, 10))\n  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis,\n  utimesMillisSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n","module.exports = require(\"zlib\");","'use strict'\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst ReadEntry = require('./read-entry.js')\nconst fs = require('fs')\nconst path = require('path')\n\nconst types = require('./types.js')\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.path = p.substr(parsed.root.length)\n      pathWarn = parsed.root\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath.replace(/\\\\/g, '/')\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/')\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](fd, () => this.emit('error', er))\n      }\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead ++\n        remain ++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw)\n        try { this[CLOSE](fd, () => {}) } catch (er) {}\n    }\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.closeSync(fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      pathWarn = parsed.root\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n","'use strict'\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':'\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n}\n","'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst Parse = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return reject(er)\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n","'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst EE = require('events').EventEmitter\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst mkdirSync = mkdir.sync\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\n\n/* istanbul ignore next */\nconst neverCalled = () => {\n  throw new Error('sync function called cb somehow?!?')\n}\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32')\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32')\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = path.resolve(opt.cwd || process.cwd())\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')\n      data.recoverable = false\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/)\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/)\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p)\n        entry.path = p.substr(parsed.root.length)\n        const r = parsed.root\n        this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path)\n      entry.path = parsed.root === '' ? wc.encode(entry.path)\n        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = entry.path\n    else\n      entry.absolute = path.resolve(this.cwd, entry.path)\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn('TAR_ENTRY_ERROR', er, {entry})\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => this[ONERROR](er, entry))\n\n    let actions = 1\n    const done = er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, {entry})\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      process.platform !== 'win32'\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n  [CHECKFS2] (entry, done) {\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er) {\n        done()\n        return this[ONERROR](er, entry)\n      }\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n        } else if (er || this[ISREUSABLE](entry, st)) {\n          this[MAKEFS](null, entry, done)\n        }\n        else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!entry.mode || (st.mode & 0o7777) === entry.mode)\n              this[MAKEFS](null, entry, done)\n            else\n              fs.chmod(entry.absolute, entry.mode,\n                er => this[MAKEFS](er, entry, done))\n          } else\n            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done))\n        } else\n          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done))\n      })\n    })\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nclass UnpackSync extends Unpack {\n  constructor (opt) {\n    super(opt)\n  }\n\n  [CHECKFS] (entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled)\n    if (er)\n      return this[ONERROR](er, entry)\n    try {\n      const st = fs.lstatSync(entry.absolute)\n      if (this.keep || this.newer && st.mtime > entry.mtime)\n        return this[SKIP](entry)\n      else if (this[ISREUSABLE](entry, st))\n        return this[MAKEFS](null, entry, neverCalled)\n      else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (entry.mode && (st.mode & 0o7777) !== entry.mode)\n                fs.chmodSync(entry.absolute, entry.mode)\n            } else\n              fs.rmdirSync(entry.absolute)\n          } else\n            unlinkFileSync(entry.absolute)\n          return this[MAKEFS](null, entry, neverCalled)\n        } catch (er) {\n          return this[ONERROR](er, entry)\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry, neverCalled)\n    }\n  }\n\n  [FILE] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er)\n      return this[ONERROR](er, entry)\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, _) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n","const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n","import * as spec from '@jsii/spec';\nimport * as api from './api';\nimport { EMPTY_OBJECT_FQN } from './serialization';\n\n/**\n * Symbol under which we store the { type -> objid } map on object instances\n */\nconst OBJID_SYMBOL = Symbol.for('$__jsii__objid__$');\n\n/**\n * Symbol under which we store the interfaces implemented by instances\n */\nconst IFACES_SYMBOL = Symbol.for('$__jsii__interfaces__$');\n\n/**\n * Symbol we use to tag the constructor of a JSII class\n */\nconst JSII_SYMBOL = Symbol.for('__jsii__');\n\n/**\n * Get the JSII fqn for an object (if available)\n *\n * This will return something if the object was constructed from a JSII-enabled\n * class/constructor, or if a literal object was annotated with type\n * information.\n */\nexport function jsiiTypeFqn(obj: any): string | undefined {\n  return obj.constructor[JSII_SYMBOL]?.fqn;\n}\n\n/**\n * If this object was previously serialized under a given reference, return the same reference\n *\n * This is to retain object identity across invocations.\n */\nexport function objectReference(obj: unknown): api.AnnotatedObjRef | undefined {\n  // If this object as already returned\n  if ((obj as any)[OBJID_SYMBOL]) {\n    return {\n      [api.TOKEN_REF]: (obj as ManagedObject)[OBJID_SYMBOL],\n      [api.TOKEN_INTERFACES]: (obj as ManagedObject)[IFACES_SYMBOL],\n    };\n  }\n\n  return undefined;\n}\n\ntype ManagedObject = {\n  [OBJID_SYMBOL]: string;\n  [IFACES_SYMBOL]?: string[];\n};\n\nfunction tagObject(obj: unknown, objid: string, interfaces?: string[]) {\n  const managed = obj as ManagedObject;\n  managed[OBJID_SYMBOL] = objid;\n  managed[IFACES_SYMBOL] = interfaces;\n}\n\n/**\n * Set the JSII FQN for classes produced by a given constructor\n */\nexport function tagJsiiConstructor(constructor: any, fqn: string) {\n  Object.defineProperty(constructor, JSII_SYMBOL, {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: { fqn },\n  });\n}\n\n/**\n * Table of JSII objects\n *\n * There can be multiple references to the same object, each under a different requested\n * type.\n */\nexport class ObjectTable {\n  private objects: { [objid: string]: RegisteredObject } = {};\n  private nextid = 10000;\n\n  public constructor(\n    private readonly resolveType: (fqn: string) => spec.Type,\n  ) {}\n\n  /**\n   * Register the given object with the given type\n   *\n   * Return the existing registration if available.\n   */\n  public registerObject(\n    obj: unknown,\n    fqn: string,\n    interfaces?: string[],\n  ): api.AnnotatedObjRef {\n    if (fqn === undefined) {\n      throw new Error('FQN cannot be undefined');\n    }\n\n    const existingRef = objectReference(obj);\n    if (existingRef) {\n      if (interfaces) {\n        const allIfaces = new Set(interfaces);\n        for (const iface of existingRef[api.TOKEN_INTERFACES] ?? []) {\n          allIfaces.add(iface);\n        }\n        this.objects[existingRef[api.TOKEN_REF]].interfaces = (obj as any)[\n          IFACES_SYMBOL\n        ] = existingRef[\n          api.TOKEN_INTERFACES\n        ] = interfaces = this.removeRedundant(Array.from(allIfaces), fqn);\n      }\n      return existingRef;\n    }\n\n    interfaces = this.removeRedundant(interfaces, fqn);\n\n    const objid = this.makeId(fqn);\n    this.objects[objid] = { instance: obj, fqn, interfaces };\n    tagObject(obj, objid, interfaces);\n\n    return { [api.TOKEN_REF]: objid, [api.TOKEN_INTERFACES]: interfaces };\n  }\n\n  /**\n   * Find the object and registered type for the given ObjRef\n   */\n  public findObject(objref: api.ObjRef): RegisteredObject {\n    if (typeof objref !== 'object' || !(api.TOKEN_REF in objref)) {\n      throw new Error(`Malformed object reference: ${JSON.stringify(objref)}`);\n    }\n\n    const objid = objref[api.TOKEN_REF];\n    const obj = this.objects[objid];\n    if (!obj) {\n      throw new Error(`Object ${objid} not found`);\n    }\n    return obj;\n  }\n\n  /**\n   * Delete the registration with the given objref\n   */\n  public deleteObject(objref: api.ObjRef) {\n    this.findObject(objref); // make sure object exists\n    delete this.objects[objref[api.TOKEN_REF]];\n  }\n\n  public get count(): number {\n    return Object.keys(this.objects).length;\n  }\n\n  private makeId(fqn: string) {\n    return `${fqn}@${this.nextid++}`;\n  }\n\n  private removeRedundant(\n    interfaces: string[] | undefined,\n    fqn: string,\n  ): string[] | undefined {\n    if (!interfaces || interfaces.length === 0) {\n      return undefined;\n    }\n\n    const result = new Set(interfaces);\n    const builtIn = new InterfaceCollection(this.resolveType);\n\n    if (fqn !== EMPTY_OBJECT_FQN) {\n      builtIn.addFromClass(fqn);\n    }\n    interfaces.forEach(builtIn.addFromInterface.bind(builtIn));\n\n    for (const iface of builtIn) {\n      result.delete(iface);\n    }\n\n    return result.size > 0 ? Array.from(result).sort() : undefined;\n  }\n}\n\nexport interface RegisteredObject {\n  instance: any;\n  fqn: string;\n  interfaces?: string[];\n}\n\nclass InterfaceCollection implements Iterable<string> {\n  private readonly interfaces = new Set<string>();\n\n  public constructor(\n    private readonly resolveType: (fqn: string) => spec.Type,\n  ) {}\n\n  public addFromClass(fqn: string): void {\n    const ti = this.resolveType(fqn);\n    if (!spec.isClassType(ti)) {\n      throw new Error(\n        `Expected a class, but received ${spec.describeTypeReference(ti)}`,\n      );\n    }\n    if (ti.base) {\n      this.addFromClass(ti.base);\n    }\n    if (ti.interfaces) {\n      for (const iface of ti.interfaces) {\n        if (this.interfaces.has(iface)) {\n          continue;\n        }\n        this.interfaces.add(iface);\n        this.addFromInterface(iface);\n      }\n    }\n  }\n\n  public addFromInterface(fqn: string): void {\n    const ti = this.resolveType(fqn);\n    if (!spec.isInterfaceType(ti)) {\n      throw new Error(\n        `Expected an interface, but received ${spec.describeTypeReference(ti)}`,\n      );\n    }\n    if (!ti.interfaces) {\n      return;\n    }\n    for (const iface of ti.interfaces) {\n      if (this.interfaces.has(iface)) {\n        continue;\n      }\n      this.interfaces.add(iface);\n      this.addFromInterface(iface);\n    }\n  }\n\n  public [Symbol.iterator]() {\n    return this.interfaces[Symbol.iterator]();\n  }\n}\n","/**\n * Handling of types in JSII\n *\n * Types will be serialized according to the following table:\n *\n *                         \n *                          JAVASCRIPT TYPE                                                                               \n *                         \n *                          undefined/null    date     scalar (*)      array      JSII-class object  literal object  \n * \n *  DECLARED  void        undefined       undefined  undefined   undefined      undefined          undefined       \n *  TYPE      date        undefined()    { date }   -           -              -                  -               \n *            scalar (*)  undefined()    -          value       -              -                  -               \n *            json        undefined       string     value       array/R(json)  -                  byvalue/R(json) \n *            enum        undefined()    -          { enum }    -              -                  -               \n *            array of T  undefined()    -          -           array/R(T)     -                  -               \n *            map of T    undefined()    -          -           -              -                  byvalue/R(T)    \n *            interface   undefined()    -          -           -              { ref }            { ref: proxy }  \n *            struct      undefined()    -          -           -              -                  byvalue/R(T[k]) \n *            class       undefined()    -          -           -              { ref }            { ref: proxy }  \n *            any         undefined       { date }   value       array/R(any)   { ref }            byvalue/R(any)  \n * \n *\n *  - (*) scalar means 'string | number | boolean'\n *  - () throw if not nullable\n *  - /R(t) recurse with declared type t\n */\n\nimport * as spec from '@jsii/spec';\nimport {\n  isObjRef,\n  isWireDate,\n  isWireEnum,\n  isWireMap,\n  ObjRef,\n  TOKEN_DATE,\n  TOKEN_ENUM,\n  TOKEN_MAP,\n  WireDate,\n  WireEnum,\n  isWireStruct,\n  TOKEN_STRUCT,\n} from './api';\nimport { jsiiTypeFqn, objectReference, ObjectTable } from './objects';\nimport { api } from '.';\n\n/**\n * A specific singleton type to be explicit about a Void type\n *\n * In the spec, 'void' is represented as 'undefined'(*), but allowing the\n * value 'undefined' in function calls has lead to consumers failing to pass\n * type information that they had, just because they didn't \"have to\" (the\n * parameter was optional).\n *\n * (*) As in, declaration of a method looks like { returns?: TypeReference }\n * and the absence of a type means it returns 'void'.\n */\nexport type Void = 'void';\n\n/**\n * A type instance, or Void\n */\nexport type OptionalValueOrVoid = spec.OptionalValue | Void;\n\n/**\n * A special FQN that can be used to create empty javascript objects.\n */\nexport const EMPTY_OBJECT_FQN = 'Object';\n\nexport const SYMBOL_WIRE_TYPE = Symbol.for('$jsii$wireType$');\n\n/**\n * The type kind, that controls how it will be serialized according to the above table\n */\nexport const enum SerializationClass {\n  Void = 'Void',\n  Date = 'Date',\n  Scalar = 'Scalar',\n  Json = 'Json',\n  Enum = 'Enum',\n  Array = 'Array',\n  Map = 'Map',\n  Struct = 'Struct',\n  ReferenceType = 'RefType',\n  Any = 'Any',\n}\n\ntype TypeLookup = (fqn: spec.FQN) => spec.Type;\ntype SymbolLookup = (fqn: spec.FQN) => any;\n\nexport interface SerializerHost {\n  readonly objects: ObjectTable;\n  debug(...args: any[]): void;\n  lookupType(fqn: string): spec.Type;\n  recurse(x: any, type: OptionalValueOrVoid): any;\n  findSymbol(fqn: spec.FQN): any;\n}\n\ninterface Serializer {\n  serialize(\n    value: unknown,\n    type: OptionalValueOrVoid,\n    host: SerializerHost,\n  ): any;\n  deserialize(\n    value: unknown,\n    type: OptionalValueOrVoid,\n    host: SerializerHost,\n  ): any;\n}\n\nexport const SERIALIZERS: { [k: string]: Serializer } = {\n  // ----------------------------------------------------------------------\n  [SerializationClass.Void]: {\n    serialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n\n    deserialize(value, _type, host) {\n      if (value != null) {\n        host.debug('Expected void, got', value);\n      }\n      return undefined;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Date]: {\n    serialize(value, optionalValue): WireDate | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (!isDate(value)) {\n        throw new Error(`Expected Date, got ${JSON.stringify(value)}`);\n      }\n      return serializeDate(value);\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      if (!isWireDate(value)) {\n        throw new Error(`Expected Date, got ${JSON.stringify(value)}`);\n      }\n      return deserializeDate(value);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Scalar]: {\n    serialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new Error(\n          `Expected ${spec.describeTypeReference(\n            optionalValue.type,\n          )}, got ${JSON.stringify(value)}`,\n        );\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new Error(\n          `Expected a ${spec.describeTypeReference(\n            optionalValue.type,\n          )}, got ${JSON.stringify(value)} (${typeof value})`,\n        );\n      }\n      return value;\n    },\n\n    deserialize(value, optionalValue) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      const primitiveType = optionalValue.type as spec.PrimitiveTypeReference;\n\n      if (!isScalar(value)) {\n        throw new Error(\n          `Expected a ${spec.describeTypeReference(\n            optionalValue.type,\n          )}, got ${JSON.stringify(value)}`,\n        );\n      }\n      if (typeof value !== primitiveType.primitive) {\n        throw new Error(\n          `Expected a ${spec.describeTypeReference(\n            optionalValue.type,\n          )}, got ${JSON.stringify(value)} (${typeof value})`,\n        );\n      }\n\n      return value;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Json]: {\n    serialize(value) {\n      // Just whatever. Dates will automatically serialize themselves to strings.\n      return value;\n    },\n    deserialize(value, optionalValue, host) {\n      // /!\\ Top-level \"null\" will turn to undefined, but any null nested in the value is valid JSON, so it'll stay!\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      // A mapping object can arrive though here. This would be the case if anything that is valid into a Map<string, ?>\n      // is passed into a JSON transfer point. Indeed, those are also valid JSON! For example, Python \"dicts\" will be\n      // serialized (by the Python runtime) as a $jsii.map (the mapping object). We need to de-serialize that as a\n      // Map<string, JSON> in order to obtain the correct output behavior here!\n      if (isWireMap(value)) {\n        return SERIALIZERS[SerializationClass.Map].deserialize(\n          value,\n          {\n            optional: false,\n            type: {\n              collection: {\n                kind: spec.CollectionKind.Map,\n                elementtype: { primitive: spec.PrimitiveType.Json },\n              },\n            },\n          },\n          host,\n        );\n      }\n\n      if (typeof value !== 'object') {\n        return value;\n      }\n\n      if (Array.isArray(value)) {\n        return value.map(mapJsonValue);\n      }\n\n      return mapValues(value, mapJsonValue);\n\n      function mapJsonValue(toMap: any) {\n        if (toMap == null) {\n          return toMap;\n        }\n        return host.recurse(toMap, {\n          type: { primitive: spec.PrimitiveType.Json },\n        });\n      }\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Enum]: {\n    serialize(value, optionalValue, host): WireEnum | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (typeof value !== 'string' && typeof value !== 'number') {\n        throw new Error(`Expected enum value, got ${JSON.stringify(value)}`);\n      }\n\n      host.debug('Serializing enum');\n\n      const enumType = optionalValue.type as spec.NamedTypeReference;\n      const enumMap = host.findSymbol(enumType.fqn);\n      const enumEntry = Object.entries(enumMap).find(([, v]) => v === value);\n      if (!enumEntry) {\n        throw new Error(`No entry in ${enumType.fqn} has value ${value}`);\n      }\n      return { [TOKEN_ENUM]: `${enumType.fqn}/${enumEntry[0]}` };\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n\n      if (!isWireEnum(value)) {\n        throw new Error(`Expected enum value, got ${JSON.stringify(value)}`);\n      }\n\n      return deserializeEnum(value, host.findSymbol);\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Array]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array type, got ${JSON.stringify(value)}`);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map((x) =>\n        host.recurse(x, { type: arrayType.collection.elementtype }),\n      );\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array type, got ${JSON.stringify(value)}`);\n      }\n\n      const arrayType = optionalValue.type as spec.CollectionTypeReference;\n\n      return value.map((x) =>\n        host.recurse(x, { type: arrayType.collection.elementtype }),\n      );\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Map]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      return {\n        [TOKEN_MAP]: mapValues(value, (v) =>\n          host.recurse(v, { type: mapType.collection.elementtype }),\n        ),\n      };\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      const mapType = optionalValue.type as spec.CollectionTypeReference;\n      if (!isWireMap(value)) {\n        // Compatibility mode with older versions that didn't wrap in [TOKEN_MAP]\n        return mapValues(value, (v) =>\n          host.recurse(v, { type: mapType.collection.elementtype }),\n        );\n      }\n      const result = mapValues(value[TOKEN_MAP], (v) =>\n        host.recurse(v, { type: mapType.collection.elementtype }),\n      );\n      Object.defineProperty(result, SYMBOL_WIRE_TYPE, {\n        configurable: false,\n        enumerable: false,\n        value: TOKEN_MAP,\n        writable: false,\n      });\n      return result;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Struct]: {\n    serialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(`Expected object, got ${JSON.stringify(value)}`);\n      }\n\n      /*\n        This is what we'd like to do, but we can't because at least the Java client\n        does not understand by-value serialized interface types, so we'll have to\n        serialize by-reference. Additionally, serializing known properties would\n        cause problems when the return type of a method is a UNION of structs.\n        See: https://github.com/aws/jsii/issues/400\n\n      const props = propertiesOf(namedType);\n\n      return mapValues(value, (v, key) => {\n        if (!props[key]) { return undefined; } // Don't map if unknown property\n        return host.recurse(v, props[key].type);\n      });\n      */\n\n      host.debug('Returning value type by reference');\n      return host.objects.registerObject(value, 'Object', [\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      ]);\n    },\n    deserialize(value, optionalValue, host) {\n      if (typeof value === 'object' && Object.keys(value ?? {}).length === 0) {\n        // Treat empty structs as `undefined` (see https://github.com/aws/jsii/issues/411)\n        value = undefined;\n      }\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(\n          `Expected object reference, got ${JSON.stringify(value)}`,\n        );\n      }\n\n      const namedType = host.lookupType(\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      );\n      const props = propertiesOf(namedType, host.lookupType);\n\n      if (Array.isArray(value)) {\n        throw new Error(\n          `Got an array where a ${namedType.fqn} was expected. Did you mean to pass a variable number of arguments?`,\n        );\n      }\n\n      // Similarly to serialization, we might be getting a reference type where we're\n      // expecting a value type. Accept this for now (but also validate that object\n      // for presence of the right properties).\n      if (isObjRef(value)) {\n        host.debug(\n          'Expected value type but got reference type, accepting for now (awslabs/jsii#400)',\n        );\n\n        // Return same INSTANCE (shouldn't matter but we don't know for sure that it doesn't)\n        return validateRequiredProps(\n          host.objects.findObject(value).instance,\n          namedType.fqn,\n          props,\n        );\n      }\n\n      if (api.isWireStruct(value)) {\n        const { fqn, data } = value[api.TOKEN_STRUCT];\n        if (!isAssignable(fqn, namedType, host.lookupType)) {\n          throw new Error(\n            `Wire struct type '${fqn}' does not match expected '${namedType.fqn}'`,\n          );\n        }\n        value = data;\n      }\n\n      // Python, for example, allows using plain mapping objects instead of Structs (dyanmic typing, YOLO!)\n      if (api.isWireMap(value)) {\n        value = value[api.TOKEN_MAP];\n      }\n\n      value = validateRequiredProps(value as any, namedType.fqn, props);\n\n      // Return a dict COPY, we have by-value semantics anyway.\n      return mapValues(value, (v, key) => {\n        if (!props[key]) {\n          return undefined;\n        } // Don't map if unknown property\n        return host.recurse(v, props[key]);\n      });\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.ReferenceType]: {\n    serialize(value, optionalValue, host): ObjRef | undefined {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(\n          `Expected object reference, got ${JSON.stringify(value)}`,\n        );\n      }\n\n      const expectedType = host.lookupType(\n        (optionalValue.type as spec.NamedTypeReference).fqn,\n      );\n      const interfaces = spec.isInterfaceType(expectedType)\n        ? [expectedType.fqn]\n        : undefined;\n      const jsiiType =\n        jsiiTypeFqn(value) ||\n        (spec.isClassType(expectedType) ? expectedType.fqn : 'Object');\n\n      return host.objects.registerObject(value, jsiiType, interfaces);\n    },\n    deserialize(value, optionalValue, host) {\n      if (nullAndOk(value, optionalValue)) {\n        return undefined;\n      }\n      if (optionalValue === 'void') {\n        throw new Error('Encountered unexpected `void` type');\n      }\n\n      // The only way to pass a by-ref object is to have created it\n      // previously inside JSII kernel, so it must have an objref already.\n\n      if (!isObjRef(value)) {\n        throw new Error(\n          `Expected object reference, got ${JSON.stringify(value)}`,\n        );\n      }\n\n      const { instance, fqn } = host.objects.findObject(value);\n\n      const namedTypeRef = optionalValue.type as spec.NamedTypeReference;\n      if (namedTypeRef.fqn !== EMPTY_OBJECT_FQN) {\n        const namedType = host.lookupType(namedTypeRef.fqn);\n\n        // Check that the object we got is of the right type\n        // We only do this for classes, not interfaces, since Java might pass us objects that\n        // privately implement some interface and we can't prove they don't.\n        // https://github.com/aws/jsii/issues/399\n        const declaredType = optionalValue.type as spec.NamedTypeReference;\n        if (\n          spec.isClassType(namedType) &&\n          !isAssignable(fqn, declaredType, host.lookupType)\n        ) {\n          throw new Error(\n            `Object of type ${fqn} is not convertible to ${declaredType.fqn}`,\n          );\n        }\n      }\n\n      return instance;\n    },\n  },\n\n  // ----------------------------------------------------------------------\n  [SerializationClass.Any]: {\n    serialize(value, _type, host) {\n      if (value == null) {\n        return undefined;\n      }\n\n      if (isDate(value)) {\n        return serializeDate(value);\n      }\n      if (isScalar(value)) {\n        return value;\n      }\n      if (Array.isArray(value)) {\n        return value.map((e) => host.recurse(e, { type: spec.CANONICAL_ANY }));\n      }\n\n      // Note: no case for \"ENUM\" here, without type declaration we can't tell the difference\n      // between an enum member and a scalar.\n\n      if (typeof value === 'function') {\n        throw new Error(\n          'JSII Kernel is unable to serialize `function`. An instance with methods might have been returned by an `any` method?',\n        );\n      }\n\n      if (typeof value !== 'object' || value == null) {\n        throw new Error(\n          `JSII kernel assumption violated, ${JSON.stringify(\n            value,\n          )} is not an object`,\n        );\n      }\n\n      if (\n        SYMBOL_WIRE_TYPE in value &&\n        (value as any)[SYMBOL_WIRE_TYPE] === TOKEN_MAP\n      ) {\n        return SERIALIZERS[SerializationClass.Map].serialize(\n          value,\n          {\n            type: {\n              collection: {\n                kind: spec.CollectionKind.Map,\n                elementtype: spec.CANONICAL_ANY,\n              },\n            },\n          },\n          host,\n        );\n      }\n\n      // To make sure people aren't going to try and return Map<> or Set<> out, test for\n      // those and throw a descriptive error message. We can't detect these cases any other\n      // way, and the by-value serialized object will be quite useless.\n      if (value instanceof Set || value instanceof Map) {\n        throw new Error(\"Can't return objects of type Set or Map\");\n      }\n\n      // Use a previous reference to maintain object identity. NOTE: this may cause us to return\n      // a different type than requested! This is just how it is right now.\n      // https://github.com/aws/jsii/issues/399\n      const prevRef = objectReference(value);\n      if (prevRef) {\n        return prevRef;\n      }\n\n      // If this is or should be a reference type, pass or make the reference\n      // (Like regular reftype serialization, but without the type derivation to an interface)\n      const jsiiType =\n        jsiiTypeFqn(value) ??\n        (isByReferenceOnly(value) ? EMPTY_OBJECT_FQN : undefined);\n      if (jsiiType) {\n        return host.objects.registerObject(value, jsiiType);\n      }\n\n      // At this point we have an object that is not of an exported type. Either an object\n      // literal, or an instance of a fully private class (cannot distinguish those cases).\n\n      // We will serialize by-value, but recurse for serialization so that if\n      // the object contains reference objects, they will be serialized appropriately.\n      // (Basically, serialize anything else as a map of 'any').\n      return mapValues(value, (v) =>\n        host.recurse(v, { type: spec.CANONICAL_ANY }),\n      );\n    },\n\n    deserialize(value, _type, host) {\n      if (value == null) {\n        return undefined;\n      }\n\n      if (isWireDate(value)) {\n        host.debug('ANY is a Date');\n        return deserializeDate(value);\n      }\n      if (isScalar(value)) {\n        host.debug('ANY is a Scalar');\n        return value;\n      }\n      if (Array.isArray(value)) {\n        host.debug('ANY is an Array');\n        return value.map((e) => host.recurse(e, { type: spec.CANONICAL_ANY }));\n      }\n\n      if (isWireEnum(value)) {\n        host.debug('ANY is an Enum');\n        return deserializeEnum(value, host.findSymbol);\n      }\n      if (isWireMap(value)) {\n        host.debug('ANY is a Map');\n        const mapOfAny: spec.CollectionTypeReference = {\n          collection: {\n            kind: spec.CollectionKind.Map,\n            elementtype: spec.CANONICAL_ANY,\n          },\n        };\n        return SERIALIZERS[SerializationClass.Map].deserialize(\n          value,\n          { type: mapOfAny },\n          host,\n        );\n      }\n      if (isObjRef(value)) {\n        host.debug('ANY is a Ref');\n        return host.objects.findObject(value).instance;\n      }\n\n      // if the value has a struct token, it was serialized by a typed jsii\n      // struct, but since the deserialization target is ANY, all we can do is\n      // strip the data from $jsii.struct and continue to deserialize as ANY.\n      if (isWireStruct(value)) {\n        const { fqn, data } = value[TOKEN_STRUCT];\n        host.debug(`ANY is a struct of type ${fqn}`);\n        return SERIALIZERS[SerializationClass.Struct].deserialize(\n          data,\n          { type: { fqn } },\n          host,\n        );\n      }\n\n      // At this point again, deserialize by-value.\n      host.debug('ANY is a Map');\n      return mapValues(value, (v) =>\n        host.recurse(v, { type: spec.CANONICAL_ANY }),\n      );\n    },\n  },\n};\n\nfunction serializeDate(value: Date): WireDate {\n  return { [TOKEN_DATE]: value.toISOString() };\n}\n\nfunction deserializeDate(value: WireDate): Date {\n  return new Date(value[TOKEN_DATE]);\n}\n\nfunction deserializeEnum(value: WireEnum, lookup: SymbolLookup) {\n  const enumLocator = value[TOKEN_ENUM];\n  const sep = enumLocator.lastIndexOf('/');\n  if (sep === -1) {\n    throw new Error(`Malformed enum value: ${JSON.stringify(value)}`);\n  }\n\n  const typeName = enumLocator.substr(0, sep);\n  const valueName = enumLocator.substr(sep + 1);\n\n  const enumValue = lookup(typeName)[valueName];\n  if (enumValue === undefined) {\n    throw new Error(`No enum member named ${valueName} in ${typeName}`);\n  }\n  return enumValue;\n}\n\nexport interface TypeSerialization {\n  serializationClass: SerializationClass;\n  typeRef: OptionalValueOrVoid;\n}\n\n/**\n * From a type reference, return the possible serialization types\n *\n * There can be multiple, because the type can be a type union.\n */\nexport function serializationType(\n  typeRef: OptionalValueOrVoid,\n  lookup: TypeLookup,\n): TypeSerialization[] {\n  if (typeRef == null) {\n    throw new Error(\"Kernel error: expected type information, got 'undefined'\");\n  }\n  if (typeRef === 'void') {\n    return [{ serializationClass: SerializationClass.Void, typeRef }];\n  }\n  if (spec.isPrimitiveTypeReference(typeRef.type)) {\n    switch (typeRef.type.primitive) {\n      case spec.PrimitiveType.Any:\n        return [{ serializationClass: SerializationClass.Any, typeRef }];\n      case spec.PrimitiveType.Date:\n        return [{ serializationClass: SerializationClass.Date, typeRef }];\n      case spec.PrimitiveType.Json:\n        return [{ serializationClass: SerializationClass.Json, typeRef }];\n      case spec.PrimitiveType.Boolean:\n      case spec.PrimitiveType.Number:\n      case spec.PrimitiveType.String:\n        return [{ serializationClass: SerializationClass.Scalar, typeRef }];\n    }\n\n    throw new Error('Unknown primitive type');\n  }\n  if (spec.isCollectionTypeReference(typeRef.type)) {\n    return [\n      {\n        serializationClass:\n          typeRef.type.collection.kind === spec.CollectionKind.Array\n            ? SerializationClass.Array\n            : SerializationClass.Map,\n        typeRef,\n      },\n    ];\n  }\n  if (spec.isUnionTypeReference(typeRef.type)) {\n    const compoundTypes = flatMap(typeRef.type.union.types, (t) =>\n      serializationType({ type: t }, lookup),\n    );\n    // Propagate the top-level 'optional' field to each individual subtype\n    for (const t of compoundTypes) {\n      if (t.typeRef !== 'void') {\n        t.typeRef.optional = typeRef.optional;\n      }\n    }\n    return compoundTypes.sort((l, r) =>\n      compareSerializationClasses(l.serializationClass, r.serializationClass),\n    );\n  }\n\n  // The next part of the conversion is lookup-dependent\n  const type = lookup(typeRef.type.fqn);\n\n  if (spec.isEnumType(type)) {\n    return [{ serializationClass: SerializationClass.Enum, typeRef }];\n  }\n\n  if (spec.isInterfaceType(type) && type.datatype) {\n    return [{ serializationClass: SerializationClass.Struct, typeRef }];\n  }\n\n  return [{ serializationClass: SerializationClass.ReferenceType, typeRef }];\n}\n\nfunction nullAndOk(x: unknown, type: OptionalValueOrVoid): boolean {\n  if (x != null) {\n    return false;\n  }\n\n  if (type !== 'void' && !type.optional) {\n    throw new Error(\n      `Got 'undefined' for non-optional instance of ${JSON.stringify(type)}`,\n    );\n  }\n\n  return true;\n}\n\nfunction isDate(x: unknown): x is Date {\n  return (\n    typeof x === 'object' &&\n    Object.prototype.toString.call(x) === '[object Date]'\n  );\n}\n\nfunction isScalar(x: unknown): x is string | number | boolean {\n  return (\n    typeof x === 'string' || typeof x === 'number' || typeof x === 'boolean'\n  );\n}\n\nfunction flatMap<T, U>(xs: T[], fn: (x: T) => U[]): U[] {\n  const ret = new Array<U>();\n  for (const x of xs) {\n    ret.push(...fn(x));\n  }\n  return ret;\n}\n\n/**\n * Map an object's values, skipping 'undefined' values'\n */\nfunction mapValues(\n  value: unknown,\n  fn: (value: any, field: string) => any,\n): { [key: string]: any } {\n  if (typeof value !== 'object' || value == null) {\n    throw new Error(`Expected object type, got ${JSON.stringify(value)}`);\n  }\n\n  const out: { [key: string]: any } = {};\n  for (const [k, v] of Object.entries(value)) {\n    const wireValue = fn(v, k);\n    if (wireValue === undefined) {\n      continue;\n    }\n    out[k] = wireValue;\n  }\n  return out;\n}\n\nfunction propertiesOf(\n  t: spec.Type,\n  lookup: TypeLookup,\n): { [name: string]: spec.Property } {\n  if (!spec.isClassOrInterfaceType(t)) {\n    return {};\n  }\n\n  let ret: { [name: string]: spec.Property } = {};\n\n  if (t.interfaces) {\n    for (const iface of t.interfaces) {\n      ret = { ...ret, ...propertiesOf(lookup(iface), lookup) };\n    }\n  }\n  if (spec.isClassType(t) && t.base) {\n    ret = { ...ret, ...propertiesOf(lookup(t.base), lookup) };\n  }\n\n  for (const prop of t.properties ?? []) {\n    ret[prop.name] = prop;\n  }\n\n  return ret;\n}\n\n/**\n * Tests whether a given type (by it's FQN) can be assigned to a named type reference.\n *\n * @param actualTypeFqn the FQN of the type that is being tested.\n * @param requiredType  the required reference type.\n *\n * @returns true if ``requiredType`` is a super-type (base class or implemented interface) of the type designated by\n *          ``actualTypeFqn``.\n */\nfunction isAssignable(\n  actualTypeFqn: string,\n  requiredType: spec.NamedTypeReference,\n  lookup: TypeLookup,\n): boolean {\n  // The empty object is assignable to everything\n  if (actualTypeFqn === EMPTY_OBJECT_FQN) {\n    return true;\n  }\n\n  if (requiredType.fqn === actualTypeFqn) {\n    return true;\n  }\n  const actualType = lookup(actualTypeFqn);\n  if (spec.isClassType(actualType)) {\n    if (\n      actualType.base &&\n      isAssignable(actualType.base, requiredType, lookup)\n    ) {\n      return true;\n    }\n  }\n  if (spec.isClassOrInterfaceType(actualType) && actualType.interfaces) {\n    return (\n      actualType.interfaces.find((iface) =>\n        isAssignable(iface, requiredType, lookup),\n      ) != null\n    );\n  }\n  return false;\n}\n\nfunction validateRequiredProps(\n  actualProps: { [key: string]: any },\n  typeName: string,\n  specProps: { [key: string]: spec.Property },\n) {\n  // Check for required properties\n  const missingRequiredProps = Object.keys(specProps)\n    .filter((name) => !specProps[name].optional)\n    .filter((name) => !(name in actualProps));\n\n  if (missingRequiredProps.length > 0) {\n    throw new Error(\n      `Missing required properties for ${typeName}: ${missingRequiredProps.join(\n        ', ',\n      )}`,\n    );\n  }\n\n  return actualProps;\n}\n\nfunction compareSerializationClasses(\n  l: SerializationClass,\n  r: SerializationClass,\n): number {\n  const order = [\n    SerializationClass.Void,\n    SerializationClass.Date,\n    SerializationClass.Scalar,\n    SerializationClass.Json,\n    SerializationClass.Enum,\n    SerializationClass.Array,\n    SerializationClass.Map,\n    SerializationClass.Struct,\n    SerializationClass.ReferenceType,\n    SerializationClass.Any,\n  ];\n  return order.indexOf(l) - order.indexOf(r);\n}\n\n/**\n * Determines whether `obj` must be passed by-reference or if by-value is acceptable. For example,\n * objects with methods, or dynamic getters (or setters) should be passed by-reference as a matter\n * of security. The behavior in non-JS runtimes could otherwise differ from that in pure JS (if\n * getters are not stable, etc...).\n *\n * @param obj the object to be tested.\n *\n * @returns true if `obj` must be passed by-reference.\n */\nfunction isByReferenceOnly(obj: any): boolean {\n  if (Array.isArray(obj)) {\n    return false;\n  }\n\n  let curr = obj;\n  // Crawl up the prototype chain to look for dynamic properties or methods.\n  do {\n    for (const prop of Object.getOwnPropertyNames(curr)) {\n      const descr = Object.getOwnPropertyDescriptor(curr, prop);\n      if (\n        descr?.get != null ||\n        descr?.set != null ||\n        typeof descr?.value === 'function'\n      ) {\n        // Property has a dynamic getter, setter or is a constructor/method, so by-ref required!\n        return true;\n      }\n    }\n    // End when the parent proto is `Object`, which has no parent proto itself.\n  } while (Object.getPrototypeOf((curr = Object.getPrototypeOf(curr))) != null);\n\n  return false;\n}\n","import * as packageInfo from '../package.json';\nimport { KernelHost } from './host';\nimport { InputOutput } from './in-out';\n\nconst name = packageInfo.name;\nconst version = packageInfo.version;\n\nconst noStack = !!process.env.JSII_NOSTACK;\nconst debug = !!process.env.JSII_DEBUG;\n\nconst inout = new InputOutput();\nconst host = new KernelHost(inout, { debug, noStack });\n\n// say hello\ninout.write({ hello: `${name}@${version}` });\ninout.debug = debug; // we don't want \"hello\" emitted\n\nhost.run();\n","import { api, Kernel } from '@jsii/kernel';\nimport { Input, InputOutput } from './in-out';\nimport { EventEmitter } from 'events';\n\nexport class KernelHost {\n  private readonly kernel = new Kernel(this.callbackHandler.bind(this));\n  private readonly eventEmitter = new EventEmitter();\n\n  public constructor(\n    private readonly inout: InputOutput,\n    private readonly opts: { debug?: boolean; noStack?: boolean } = {},\n  ) {\n    this.kernel.traceEnabled = opts.debug ? true : false;\n  }\n\n  public run() {\n    const req = this.inout.read();\n    if (!req) {\n      this.eventEmitter.emit('exit');\n      return; // done\n    }\n\n    this.processRequest(req, () => {\n      // Schedule the call to run on the next event loop iteration to\n      // avoid recursion.\n      setImmediate(() => this.run());\n    });\n  }\n\n  public on(event: 'exit', listener: () => void) {\n    this.eventEmitter.on(event, listener);\n  }\n\n  private callbackHandler(callback: api.Callback) {\n    // write a \"callback\" response, which is a special response that tells\n    // the client that there's synchonous callback it needs to invoke and\n    // bring back the result via a \"complete\" request.\n    this.inout.write({ callback });\n\n    return completeCallback.call(this);\n\n    function completeCallback(this: KernelHost): void {\n      const req = this.inout.read();\n      if (!req) {\n        throw new Error('Interrupted before callback returned');\n      }\n\n      // if this is a completion for the current callback, then we can\n      // finally stop this nonsense and return the result.\n      const completeReq = req as { complete: api.CompleteRequest };\n      if (\n        'complete' in completeReq &&\n        completeReq.complete.cbid === callback.cbid\n      ) {\n        if (completeReq.complete.err) {\n          throw new Error(completeReq.complete.err);\n        }\n\n        return completeReq.complete.result;\n      }\n\n      // otherwise, process the request normally, but continue to wait for\n      // our callback to be completed. sync=true to enforce that `completeCallback`\n      // will be called synchronously and return value will be chained back so we can\n      // return it to the callback handler.\n      return this.processRequest(\n        req,\n        completeCallback.bind(this),\n        /* sync */ true,\n      );\n    }\n  }\n\n  /**\n   * Processes the input request `req` and writes the output response to\n   * stdout. This method invokes `next` when the request was fully processed.\n   * This either happens synchronously or asynchronously depending on the api\n   * (e.g. the \"end\" api will wait for an async promise to be fulfilled before\n   * it writes the response)\n   *\n   * @param req The input request\n   * @param next A callback to invoke to continue\n   * @param sync If this is 'true', \"next\" must be called synchronously. This means\n   *             that we won't process any async activity (begin/complete). The kernel\n   *             doesn't allow any async operations during a sync callback, so this shouldn't\n   *             happen, so we assert in this case to find bugs.\n   */\n  private processRequest(req: Input, next: () => void, sync = false) {\n    if ('callback' in req) {\n      throw new Error(\n        'Unexpected `callback` result. This request should have been processed by a callback handler',\n      );\n    }\n\n    if (!('api' in req)) {\n      throw new Error('Malformed request, \"api\" field is required');\n    }\n\n    const apiReq = req;\n    const fn = this.findApi(apiReq.api);\n\n    try {\n      const ret = fn.call(this.kernel, req);\n\n      // special case for 'begin' and 'complete' which are on an async\n      // promise path. in order to allow the kernel to actually fulfill\n      // the promise, and continue any async flows (which may potentially\n      // start other promises), we respond only within a setImmediate\n      // block, which is scheduled in the same micro-tasks queue as\n      // promises. see the kernel test 'async overrides: two overrides'\n      // for an example for this use case.\n      if (apiReq.api === 'begin' || apiReq.api === 'complete') {\n        checkIfAsyncIsAllowed();\n\n        this.debug('processing pending promises before responding');\n\n        setImmediate(() => {\n          this.writeOkay(ret);\n          next();\n        });\n\n        return undefined;\n      }\n\n      // if this is an async method, return immediately and\n      // call next only when the promise is fulfilled.\n      if (this.isPromise(ret)) {\n        checkIfAsyncIsAllowed();\n\n        this.debug('waiting for promise to be fulfilled');\n\n        const promise = ret;\n        promise\n          .then((val) => {\n            this.debug('promise succeeded:', val);\n            this.writeOkay(val);\n            next();\n          })\n          .catch((e) => {\n            this.debug('promise failed:', e);\n            this.writeError(e);\n            next();\n          });\n\n        return undefined;\n      }\n\n      this.writeOkay(ret);\n    } catch (e) {\n      this.writeError(e);\n    }\n\n    // indicate this request was processed (synchronously).\n    return next();\n\n    function checkIfAsyncIsAllowed() {\n      if (sync) {\n        throw new Error(\n          'Cannot handle async operations while waiting for a sync callback to return',\n        );\n      }\n    }\n  }\n\n  /**\n   * Writes an \"ok\" result to stdout.\n   */\n  private writeOkay(result: any) {\n    const res = { ok: result };\n    this.inout.write(res);\n  }\n\n  /**\n   * Writes an \"error\" result to stdout.\n   */\n  private writeError(error: any) {\n    const res = { error: error.message, stack: undefined };\n    if (!this.opts.noStack) {\n      res.stack = error.stack;\n    }\n    this.inout.write(res);\n  }\n\n  /**\n   * Returns true if the value is a promise.\n   */\n  private isPromise(v: any): v is Promise<any> {\n    return typeof v?.then === 'function';\n  }\n\n  /**\n   * Given a kernel api name, returns the function to invoke.\n   */\n  private findApi(apiName: string): (this: Kernel, arg: Input) => any {\n    const fn = (this.kernel as any)[apiName];\n    if (typeof fn !== 'function') {\n      throw new Error(`Invalid kernel api call: ${apiName}`);\n    }\n    return fn;\n  }\n\n  private debug(...args: any[]) {\n    if (!this.opts.debug) {\n      return;\n    }\n\n    console.error(...args);\n  }\n}\n","import * as fs from 'fs-extra';\nimport * as spec from '@jsii/spec';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { SourceMapConsumer } from 'source-map';\nimport * as tar from 'tar';\nimport * as vm from 'vm';\nimport * as api from './api';\nimport { TOKEN_REF } from './api';\nimport { ObjectTable, tagJsiiConstructor } from './objects';\nimport * as wire from './serialization';\n\nexport class Kernel {\n  /**\n   * Set to true for verbose debugging.\n   */\n  public traceEnabled = false;\n\n  private assemblies: { [name: string]: Assembly } = {};\n  private readonly objects = new ObjectTable(this._typeInfoForFqn.bind(this));\n  private cbs: { [cbid: string]: Callback } = {};\n  private waiting: { [cbid: string]: Callback } = {};\n  private promises: { [prid: string]: AsyncInvocation } = {};\n  private nextid = 20000; // incrementing counter for objid, cbid, promiseid\n  private syncInProgress?: string; // forbids async calls (begin) while processing sync calls (get/set/invoke)\n  private installDir?: string;\n\n  private readonly sandbox: vm.Context;\n  private readonly sourceMaps: { [assm: string]: SourceMapConsumer } = {};\n\n  /**\n   * Creates a jsii kernel object.\n   *\n   * @param callbackHandler This handler is invoked when a synchronous callback is called.\n   *                        It's responsibility is to execute the callback and return it's\n   *                        result (or throw an error).\n   */\n  public constructor(public callbackHandler: (callback: api.Callback) => any) {\n    // `setImmediate` is required for tests to pass (it is otherwise\n    // impossible to wait for in-VM promises to complete)\n\n    // `Buffer` is required when using simple-resource-bundler.\n\n    // HACK: when we webpack @jsii/runtime, all \"require\" statements get transpiled,\n    // so modules can be resolved within the pack. However, here we actually want to\n    // let loaded modules to use the native node \"require\" method.\n    // I wonder if webpack has some pragma that allows opting-out at certain points\n    // in the code.\n    // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires\n    const moduleLoad = require('module').Module._load;\n    const nodeRequire = (p: string) => moduleLoad(p, module, false);\n\n    this.sandbox = vm.createContext({\n      Buffer, // to use simple-resource-bundler\n      setImmediate, // async tests\n      require: nodeRequire, // modules need to \"require\"\n    });\n  }\n\n  public load(req: api.LoadRequest): api.LoadResponse {\n    this._debug('load', req);\n\n    if ('assembly' in req) {\n      throw new Error(\n        '`assembly` field is deprecated for \"load\", use `name`, `version` and `tarball` instead',\n      );\n    }\n\n    if (!this.installDir) {\n      this.installDir = fs.mkdtempSync(path.join(os.tmpdir(), 'jsii-kernel-'));\n      fs.mkdirpSync(path.join(this.installDir, 'node_modules'));\n      this._debug('creating jsii-kernel modules workdir:', this.installDir);\n\n      process.on('exit', () => {\n        if (this.installDir) {\n          this._debug('removing install dir', this.installDir);\n          fs.removeSync(this.installDir); // can't use async version during exit\n        }\n      });\n    }\n\n    const pkgname = req.name;\n    const pkgver = req.version;\n\n    // check if we already have such a module\n    const packageDir = path.join(this.installDir, 'node_modules', pkgname);\n    if (fs.pathExistsSync(packageDir)) {\n      // module exists, verify version\n      const epkg = fs.readJsonSync(path.join(packageDir, 'package.json'));\n      if (epkg.version !== pkgver) {\n        throw new Error(\n          `Multiple versions ${pkgver} and ${epkg.version} of the ` +\n            `package '${pkgname}' cannot be loaded together since this is unsupported by ` +\n            'some runtime environments',\n        );\n      }\n\n      // same version, no-op\n      this._debug('look up already-loaded assembly', pkgname);\n      const assm = this.assemblies[pkgname];\n\n      return {\n        assembly: assm.metadata.name,\n        types: Object.keys(assm.metadata.types ?? {}).length,\n      };\n    }\n\n    // Create the install directory (there may be several path components for @scoped/packages)\n    fs.mkdirpSync(packageDir);\n\n    // Force umask to have npm-install-like permissions\n    const originalUmask = process.umask(0o022);\n    try {\n      // untar the archive to its final location\n      tar.extract({\n        cwd: packageDir,\n        file: req.tarball,\n        strict: true,\n        strip: 1, // Removes the 'package/' path element from entries\n        sync: true,\n        unlink: true,\n      });\n    } finally {\n      // Reset umask to the initial value\n      process.umask(originalUmask);\n    }\n\n    // read .jsii metadata from the root of the package\n    const jsiiMetadataFile = path.join(packageDir, spec.SPEC_FILE_NAME);\n    if (!fs.pathExistsSync(jsiiMetadataFile)) {\n      throw new Error(\n        `Package tarball ${req.tarball} must have a file named ${spec.SPEC_FILE_NAME} at the root`,\n      );\n    }\n    const assmSpec = fs.readJsonSync(jsiiMetadataFile) as spec.Assembly;\n\n    // load the module and capture it's closure\n    const closure = this._execute(\n      `require(String.raw\\`${packageDir}\\`)`,\n      packageDir,\n    );\n    const assm = new Assembly(assmSpec, closure);\n    this._addAssembly(assm);\n\n    return {\n      assembly: assmSpec.name,\n      types: Object.keys(assmSpec.types ?? {}).length,\n    };\n  }\n\n  public create(req: api.CreateRequest): api.CreateResponse {\n    return this._create(req);\n  }\n\n  public del(req: api.DelRequest): api.DelResponse {\n    const { objref } = req;\n\n    this._debug('del', objref);\n    this.objects.deleteObject(objref);\n\n    return {};\n  }\n\n  public sget(req: api.StaticGetRequest): api.GetResponse {\n    const { fqn, property } = req;\n    const symbol = `${fqn}.${property}`;\n    this._debug('sget', symbol);\n    const ti = this._typeInfoForProperty(property, fqn);\n\n    if (!ti.static) {\n      throw new Error(`property ${symbol} is not static`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n\n    const value = this._ensureSync(`property ${property}`, () =>\n      this._wrapSandboxCode(() => prototype[property]),\n    );\n\n    this._debug('value:', value);\n    const ret = this._fromSandbox(value, ti);\n    this._debug('ret', ret);\n    return { value: ret };\n  }\n\n  public sset(req: api.StaticSetRequest): api.SetResponse {\n    const { fqn, property, value } = req;\n    const symbol = `${fqn}.${property}`;\n    this._debug('sset', symbol);\n    const ti = this._typeInfoForProperty(property, fqn);\n\n    if (!ti.static) {\n      throw new Error(`property ${symbol} is not static`);\n    }\n\n    if (ti.immutable) {\n      throw new Error(`static property ${symbol} is readonly`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n\n    this._ensureSync(`property ${property}`, () =>\n      this._wrapSandboxCode(\n        () => (prototype[property] = this._toSandbox(value, ti)),\n      ),\n    );\n\n    return {};\n  }\n\n  public get(req: api.GetRequest): api.GetResponse {\n    const { objref, property } = req;\n    this._debug('get', objref, property);\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n    const ti = this._typeInfoForProperty(property, fqn, interfaces);\n\n    // if the property is overridden by the native code and \"get\" is called on the object, it\n    // means that the native code is trying to access the \"super\" property. in order to enable\n    // that, we actually keep a copy of the original property descriptor when we override,\n    // so `findPropertyTarget` will return either the original property name (\"property\") or\n    // the \"super\" property name (somehing like \"$jsii$super$<property>$\").\n    const propertyToGet = this._findPropertyTarget(instance, property);\n\n    // make the actual \"get\", and block any async calls that might be performed\n    // by jsii overrides.\n    const value = this._ensureSync(\n      `property '${objref[TOKEN_REF]}.${propertyToGet}'`,\n      () => this._wrapSandboxCode(() => instance[propertyToGet]),\n    );\n    this._debug('value:', value);\n    const ret = this._fromSandbox(value, ti);\n    this._debug('ret:', ret);\n    return { value: ret };\n  }\n\n  public set(req: api.SetRequest): api.SetResponse {\n    const { objref, property, value } = req;\n    this._debug('set', objref, property, value);\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n\n    const propInfo = this._typeInfoForProperty(req.property, fqn, interfaces);\n\n    if (propInfo.immutable) {\n      throw new Error(\n        `Cannot set value of immutable property ${req.property} to ${req.value}`,\n      );\n    }\n\n    const propertyToSet = this._findPropertyTarget(instance, property);\n\n    this._ensureSync(`property '${objref[TOKEN_REF]}.${propertyToSet}'`, () =>\n      this._wrapSandboxCode(\n        () => (instance[propertyToSet] = this._toSandbox(value, propInfo)),\n      ),\n    );\n\n    return {};\n  }\n\n  public invoke(req: api.InvokeRequest): api.InvokeResponse {\n    const { objref, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('invoke', objref, method, args);\n    const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n    // verify this is not an async method\n    if (ti.async) {\n      throw new Error(`${method} is an async method, use \"begin\" instead`);\n    }\n\n    const ret = this._ensureSync(\n      `method '${objref[TOKEN_REF]}.${method}'`,\n      () => {\n        return this._wrapSandboxCode(() =>\n          fn.apply(obj, this._toSandboxValues(args, ti.parameters)),\n        );\n      },\n    );\n\n    const result = this._fromSandbox(ret, ti.returns ?? 'void');\n    this._debug('invoke result', result);\n\n    return { result };\n  }\n\n  public sinvoke(req: api.StaticInvokeRequest): api.InvokeResponse {\n    const { fqn, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('sinvoke', fqn, method, args);\n\n    const ti = this._typeInfoForMethod(method, fqn);\n\n    if (!ti.static) {\n      throw new Error(`${fqn}.${method} is not a static method`);\n    }\n\n    // verify this is not an async method\n    if (ti.async) {\n      throw new Error(`${method} is an async method, use \"begin\" instead`);\n    }\n\n    const prototype = this._findSymbol(fqn);\n    const fn = prototype[method] as (...params: any[]) => any;\n\n    const ret = this._ensureSync(`method '${fqn}.${method}'`, () => {\n      return this._wrapSandboxCode(() =>\n        fn.apply(prototype, this._toSandboxValues(args, ti.parameters)),\n      );\n    });\n\n    this._debug('method returned:', ret);\n    return { result: this._fromSandbox(ret, ti.returns ?? 'void') };\n  }\n\n  public begin(req: api.BeginRequest): api.BeginResponse {\n    const { objref, method } = req;\n    const args = req.args ?? [];\n\n    this._debug('begin', objref, method, args);\n\n    if (this.syncInProgress) {\n      throw new Error(\n        `Cannot invoke async method '${req.objref[TOKEN_REF]}.${req.method}' while sync ${this.syncInProgress} is being processed`,\n      );\n    }\n\n    const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);\n\n    // verify this is indeed an async method\n    if (!ti.async) {\n      throw new Error(`Method ${method} is expected to be an async method`);\n    }\n\n    const promise = this._wrapSandboxCode(() =>\n      fn.apply(obj, this._toSandboxValues(args, ti.parameters)),\n    ) as Promise<any>;\n\n    // since we are planning to resolve this promise in a different scope\n    // we need to handle rejections here [1]\n    // [1]: https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505\n    promise.catch((_) => undefined);\n\n    const prid = this._makeprid();\n    this.promises[prid] = {\n      promise,\n      method: ti,\n    };\n\n    return { promiseid: prid };\n  }\n\n  public async end(req: api.EndRequest): Promise<api.EndResponse> {\n    const { promiseid } = req;\n\n    this._debug('end', promiseid);\n\n    const { promise, method } = this.promises[promiseid];\n    if (promise == null) {\n      throw new Error(`Cannot find promise with ID: ${promiseid}`);\n    }\n\n    let result;\n    try {\n      result = await promise;\n      this._debug('promise result:', result);\n    } catch (e) {\n      this._debug('promise error:', e);\n      throw mapSource(e, this.sourceMaps);\n    }\n\n    return { result: this._fromSandbox(result, method.returns ?? 'void') };\n  }\n\n  public callbacks(_req?: api.CallbacksRequest): api.CallbacksResponse {\n    this._debug('callbacks');\n    const ret = Object.keys(this.cbs).map((cbid) => {\n      const cb = this.cbs[cbid];\n      this.waiting[cbid] = cb; // move to waiting\n      const callback: api.Callback = {\n        cbid,\n        cookie: cb.override.cookie,\n        invoke: {\n          objref: cb.objref,\n          method: cb.override.method,\n          args: cb.args,\n        },\n      };\n      return callback;\n    });\n\n    // move all callbacks to the wait queue and clean the callback queue.\n    this.cbs = {};\n    return { callbacks: ret };\n  }\n\n  public complete(req: api.CompleteRequest): api.CompleteResponse {\n    const { cbid, err, result } = req;\n\n    this._debug('complete', cbid, err, result);\n\n    if (!(cbid in this.waiting)) {\n      throw new Error(`Callback ${cbid} not found`);\n    }\n\n    const cb = this.waiting[cbid];\n    if (err) {\n      this._debug('completed with error:', err);\n      cb.fail(new Error(err));\n    } else {\n      const sandoxResult = this._toSandbox(\n        result,\n        cb.expectedReturnType ?? 'void',\n      );\n      this._debug('completed with result:', sandoxResult);\n      cb.succeed(sandoxResult);\n    }\n\n    delete this.waiting[cbid];\n\n    return { cbid };\n  }\n\n  /**\n   * Returns the language-specific names for a jsii module.\n   * @param assemblyName The name of the jsii module (i.e. jsii$jsii_calculator_lib$)\n   */\n  public naming(req: api.NamingRequest): api.NamingResponse {\n    const assemblyName = req.assembly;\n\n    this._debug('naming', assemblyName);\n\n    const assembly = this._assemblyFor(assemblyName);\n    const targets = assembly.metadata.targets;\n    if (!targets) {\n      throw new Error(`Unexpected - \"targets\" for ${assemblyName} is missing!`);\n    }\n\n    return { naming: targets };\n  }\n\n  public stats(_req?: api.StatsRequest): api.StatsResponse {\n    return {\n      objectCount: this.objects.count,\n    };\n  }\n\n  private _addAssembly(assm: Assembly) {\n    this.assemblies[assm.metadata.name] = assm;\n\n    // add the __jsii__.fqn property on every constructor. this allows\n    // traversing between the javascript and jsii worlds given any object.\n    for (const fqn of Object.keys(assm.metadata.types ?? {})) {\n      const typedef = assm.metadata.types![fqn];\n      switch (typedef.kind) {\n        case spec.TypeKind.Interface:\n          continue; // interfaces don't really exist\n        case spec.TypeKind.Class:\n        case spec.TypeKind.Enum:\n          const constructor = this._findSymbol(fqn);\n          tagJsiiConstructor(constructor, fqn);\n      }\n    }\n  }\n\n  // find the javascript constructor function for a jsii FQN.\n  private _findCtor(\n    fqn: string,\n    args: any[],\n  ): { ctor: any; parameters?: spec.Parameter[] } {\n    if (fqn === wire.EMPTY_OBJECT_FQN) {\n      return { ctor: Object };\n    }\n\n    const typeinfo = this._typeInfoForFqn(fqn);\n\n    switch (typeinfo.kind) {\n      case spec.TypeKind.Class:\n        const classType = typeinfo as spec.ClassType;\n        this._validateMethodArguments(classType.initializer, args);\n        return {\n          ctor: this._findSymbol(fqn),\n          parameters: classType.initializer && classType.initializer.parameters,\n        };\n\n      case spec.TypeKind.Interface:\n        throw new Error(\n          `Cannot create an object with an FQN of an interface: ${fqn}`,\n        );\n\n      default:\n        throw new Error(`Unexpected FQN kind: ${fqn}`);\n    }\n  }\n\n  // prefixed with _ to allow calling this method internally without\n  // getting it recorded for testing.\n  private _create(req: api.CreateRequest): api.CreateResponse {\n    this._debug('create', req);\n    const { fqn, interfaces, overrides } = req;\n\n    const requestArgs = req.args ?? [];\n\n    const ctorResult = this._findCtor(fqn, requestArgs);\n    const ctor = ctorResult.ctor;\n    const obj = this._wrapSandboxCode(\n      () =>\n        new ctor(...this._toSandboxValues(requestArgs, ctorResult.parameters)),\n    );\n    const objref = this.objects.registerObject(obj, fqn, req.interfaces ?? []);\n\n    // overrides: for each one of the override method names, installs a\n    // method on the newly created object which represents the remote \"reverse proxy\".\n\n    if (overrides) {\n      this._debug('overrides', overrides);\n\n      const overrideTypeErrorMessage =\n        'Override can either be \"method\" or \"property\"';\n      const methods = new Set<string>();\n      const properties = new Set<string>();\n\n      for (const override of overrides) {\n        if (api.isMethodOverride(override)) {\n          if (api.isPropertyOverride(override)) {\n            throw new Error(overrideTypeErrorMessage);\n          }\n          if (methods.has(override.method)) {\n            throw new Error(\n              `Duplicate override for method '${override.method}'`,\n            );\n          }\n          methods.add(override.method);\n\n          this._applyMethodOverride(obj, objref, fqn, interfaces, override);\n        } else if (api.isPropertyOverride(override)) {\n          if (api.isMethodOverride(override)) {\n            throw new Error(overrideTypeErrorMessage);\n          }\n          if (properties.has(override.property)) {\n            throw Error(\n              `Duplicate override for property '${override.property}'`,\n            );\n          }\n          properties.add(override.property);\n\n          this._applyPropertyOverride(obj, objref, fqn, interfaces, override);\n        } else {\n          throw new Error(overrideTypeErrorMessage);\n        }\n      }\n    }\n\n    return objref;\n  }\n\n  private _getSuperPropertyName(name: string) {\n    return `$jsii$super$${name}$`;\n  }\n\n  private _applyPropertyOverride(\n    obj: any,\n    objref: api.ObjRef,\n    typeFqn: string,\n    interfaces: string[] | undefined,\n    override: api.PropertyOverride,\n  ) {\n    // error if we can find a method with this name\n    if (this._tryTypeInfoForMethod(override.property, typeFqn, interfaces)) {\n      throw new Error(\n        `Trying to override method '${override.property}' as a property`,\n      );\n    }\n\n    let propInfo = this._tryTypeInfoForProperty(\n      override.property,\n      typeFqn,\n      interfaces,\n    );\n    // if this is a private property (i.e. doesn't have `propInfo` the object has a key)\n    if (!propInfo && override.property in obj) {\n      this._debug(`Skipping override of private property ${override.property}`);\n      return;\n    }\n\n    if (!propInfo) {\n      // We've overriding a property on an object we have NO type information on (probably\n      // because it's an anonymous object).\n      // Pretend it's 'prop: any';\n      //\n      // FIXME: We could do better type checking during the conversion if JSII clients\n      // would tell us the intended interface type.\n      propInfo = {\n        name: override.property,\n        type: spec.CANONICAL_ANY,\n      };\n    }\n\n    this._defineOverridenProperty(obj, objref, override, propInfo);\n  }\n\n  private _defineOverridenProperty(\n    obj: any,\n    objref: api.ObjRef,\n    override: api.PropertyOverride,\n    propInfo: spec.Property,\n  ) {\n    const propertyName = override.property;\n\n    this._debug('apply override', propertyName);\n\n    // save the old property under $jsii$super$<prop>$ so that property overrides\n    // can still access it via `super.<prop>`.\n    const prev = getPropertyDescriptor(obj, propertyName) ?? {\n      value: obj[propertyName],\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    };\n\n    const prevEnumerable = prev.enumerable;\n    prev.enumerable = false;\n    Object.defineProperty(obj, this._getSuperPropertyName(propertyName), prev);\n\n    // we add callbacks for both 'get' and 'set', even if the property\n    // is readonly. this is fine because if you try to set() a readonly\n    // property, it will fail.\n    Object.defineProperty(obj, propertyName, {\n      enumerable: prevEnumerable,\n      configurable: prev.configurable,\n      get: () => {\n        this._debug('virtual get', objref, propertyName, {\n          cookie: override.cookie,\n        });\n        const result = this.callbackHandler({\n          cookie: override.cookie,\n          cbid: this._makecbid(),\n          get: { objref, property: propertyName },\n        });\n        this._debug('callback returned', result);\n        return this._toSandbox(result, propInfo);\n      },\n      set: (value: any) => {\n        this._debug('virtual set', objref, propertyName, {\n          cookie: override.cookie,\n        });\n        this.callbackHandler({\n          cookie: override.cookie,\n          cbid: this._makecbid(),\n          set: {\n            objref,\n            property: propertyName,\n            value: this._fromSandbox(value, propInfo),\n          },\n        });\n      },\n    });\n\n    function getPropertyDescriptor(\n      obj: any,\n      propertyName: string,\n    ): PropertyDescriptor | undefined {\n      const direct = Object.getOwnPropertyDescriptor(obj, propertyName);\n      if (direct != null) {\n        return direct;\n      }\n      const proto = Object.getPrototypeOf(obj);\n      if (proto == null && proto !== Object.prototype) {\n        // We reached Object or the prototype chain root, all hope is lost!\n        return undefined;\n      }\n      return getPropertyDescriptor(proto, propertyName);\n    }\n  }\n\n  private _applyMethodOverride(\n    obj: any,\n    objref: api.ObjRef,\n    typeFqn: string,\n    interfaces: string[] | undefined,\n    override: api.MethodOverride,\n  ) {\n    // error if we can find a property with this name\n    if (this._tryTypeInfoForProperty(override.method, typeFqn, interfaces)) {\n      throw new Error(\n        `Trying to override property '${override.method}' as a method`,\n      );\n    }\n\n    let methodInfo = this._tryTypeInfoForMethod(\n      override.method,\n      typeFqn,\n      interfaces,\n    );\n\n    // If this is a private method (doesn't have methodInfo, key resolves on the object), we\n    // are going to skip the override.\n    if (!methodInfo && obj[override.method]) {\n      this._debug(`Skipping override of private method ${override.method}`);\n      return;\n    }\n\n    if (!methodInfo) {\n      // We've overriding a method on an object we have NO type information on (probably\n      // because it's an anonymous object).\n      // Pretend it's an (...args: any[]) => any\n      methodInfo = {\n        name: override.method,\n        returns: { type: spec.CANONICAL_ANY },\n        parameters: [\n          {\n            name: 'args',\n            type: spec.CANONICAL_ANY,\n            variadic: true,\n          },\n        ],\n        variadic: true,\n      };\n    }\n\n    this._defineOverridenMethod(obj, objref, override, methodInfo);\n  }\n\n  private _defineOverridenMethod(\n    obj: any,\n    objref: api.ObjRef,\n    override: api.MethodOverride,\n    methodInfo: spec.Method,\n  ) {\n    const methodName = override.method;\n\n    if (methodInfo.async) {\n      // async method override\n      Object.defineProperty(obj, methodName, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: (...methodArgs: any[]) => {\n          this._debug('invoke async method override', override);\n          const args = this._toSandboxValues(methodArgs, methodInfo.parameters);\n          return new Promise<any>((succeed, fail) => {\n            const cbid = this._makecbid();\n            this._debug('adding callback to queue', cbid);\n            this.cbs[cbid] = {\n              objref,\n              override,\n              args,\n              expectedReturnType: methodInfo.returns ?? 'void',\n              succeed,\n              fail,\n            };\n          });\n        },\n      });\n    } else {\n      // sync method override (method info is not required)\n      Object.defineProperty(obj, methodName, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: (...methodArgs: any[]) => {\n          this._debug(\n            'invoke sync method override',\n            override,\n            'args',\n            methodArgs,\n          );\n          // We should be validating the actual arguments according to the\n          // declared parameters here, but let's just assume the JSII runtime on the\n          // other end has done its work.\n          const result = this.callbackHandler({\n            cookie: override.cookie,\n            cbid: this._makecbid(),\n            invoke: {\n              objref,\n              method: methodName,\n              args: this._fromSandboxValues(methodArgs, methodInfo.parameters),\n            },\n          });\n          this._debug('Result', result);\n          return this._toSandbox(result, methodInfo.returns ?? 'void');\n        },\n      });\n    }\n  }\n\n  private _findInvokeTarget(\n    objref: api.ObjRef,\n    methodName: string,\n    args: any[],\n  ) {\n    const { instance, fqn, interfaces } = this.objects.findObject(objref);\n    const ti = this._typeInfoForMethod(methodName, fqn, interfaces);\n    this._validateMethodArguments(ti, args);\n\n    // always first look up the method in the prototype. this practically bypasses\n    // any methods overridden by derived classes (which are by definition native\n    // methods). this serves to allow native call to invoke \"super.method()\" when\n    // overriding the method.\n    // if we didn't find the method on the prototype, it could be a literal object\n    // that implements an interface, so we look if we have the method on the object\n    // itself. if we do, we invoke it.\n    let fn = instance.constructor.prototype[methodName];\n    if (!fn) {\n      fn = instance[methodName];\n      if (!fn) {\n        throw new Error(`Cannot find ${methodName} on object`);\n      }\n    }\n    return { ti, obj: instance, fn };\n  }\n\n  private _validateMethodArguments(\n    method: spec.Callable | undefined,\n    args: any[],\n  ) {\n    const params: spec.Parameter[] = method?.parameters ?? [];\n\n    // error if args > params\n    if (args.length > params.length && !(method && method.variadic)) {\n      throw new Error(\n        `Too many arguments (method accepts ${params.length} parameters, got ${args.length} arguments)`,\n      );\n    }\n\n    for (let i = 0; i < params.length; ++i) {\n      const param = params[i];\n      const arg = args[i];\n\n      if (param.variadic) {\n        if (params.length <= i) {\n          return;\n        } // No vararg was provided\n        for (let j = i; j < params.length; j++) {\n          if (!param.optional && params[j] === undefined) {\n            throw new Error(\n              `Unexpected 'undefined' value at index ${\n                j - i\n              } of variadic argument '${\n                param.name\n              }' of type '${spec.describeTypeReference(param.type)}'`,\n            );\n          }\n        }\n      } else if (!param.optional && arg === undefined) {\n        throw new Error(\n          `Not enough arguments. Missing argument for the required parameter '${\n            param.name\n          }' of type '${spec.describeTypeReference(param.type)}'`,\n        );\n      }\n    }\n  }\n\n  private _assemblyFor(assemblyName: string) {\n    const assembly = this.assemblies[assemblyName];\n    if (!assembly) {\n      throw new Error(`Could not find assembly: ${assemblyName}`);\n    }\n    return assembly;\n  }\n\n  private _findSymbol(fqn: string) {\n    const [assemblyName, ...parts] = fqn.split('.');\n    const assembly = this._assemblyFor(assemblyName);\n\n    let curr = assembly.closure;\n    while (parts.length > 0) {\n      const name = parts.shift();\n      if (!name) {\n        break;\n      }\n\n      curr = curr[name];\n    }\n    if (!curr) {\n      throw new Error(`Could not find symbol ${fqn}`);\n    }\n    return curr;\n  }\n\n  private _typeInfoForFqn(fqn: string): spec.Type {\n    const components = fqn.split('.');\n    const moduleName = components[0];\n\n    const assembly = this.assemblies[moduleName];\n    if (!assembly) {\n      throw new Error(`Module '${moduleName}' not found`);\n    }\n\n    const types = assembly.metadata.types ?? {};\n    const fqnInfo = types[fqn];\n    if (!fqnInfo) {\n      throw new Error(`Type '${fqn}' not found`);\n    }\n\n    return fqnInfo;\n  }\n\n  private _typeInfoForMethod(\n    methodName: string,\n    fqn: string,\n    interfaces?: string[],\n  ): spec.Method {\n    const ti = this._tryTypeInfoForMethod(methodName, fqn, interfaces);\n    if (!ti) {\n      const addendum =\n        interfaces && interfaces.length > 0\n          ? ` or interface(s) ${interfaces.join(', ')}`\n          : '';\n      throw new Error(\n        `Class ${fqn}${addendum} doesn't have a method '${methodName}'`,\n      );\n    }\n    return ti;\n  }\n\n  private _tryTypeInfoForMethod(\n    methodName: string,\n    classFqn: string,\n    interfaces: string[] = [],\n  ): spec.Method | undefined {\n    for (const fqn of [classFqn, ...interfaces]) {\n      if (fqn === 'Object') {\n        continue;\n      }\n      const typeinfo = this._typeInfoForFqn(fqn);\n\n      const methods =\n        (typeinfo as spec.ClassType | spec.InterfaceType).methods ?? [];\n\n      for (const m of methods) {\n        if (m.name === methodName) {\n          return m;\n        }\n      }\n\n      // recursion to parent type (if exists)\n      const bases = [\n        (typeinfo as spec.ClassType).base,\n        ...((typeinfo as spec.InterfaceType).interfaces ?? []),\n      ];\n      for (const base of bases) {\n        if (!base) {\n          continue;\n        }\n\n        const found = this._tryTypeInfoForMethod(methodName, base);\n        if (found) {\n          return found;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryTypeInfoForProperty(\n    property: string,\n    classFqn: string,\n    interfaces: string[] = [],\n  ): spec.Property | undefined {\n    for (const fqn of [classFqn, ...interfaces]) {\n      if (fqn === wire.EMPTY_OBJECT_FQN) {\n        continue;\n      }\n      const typeInfo = this._typeInfoForFqn(fqn);\n\n      let properties;\n      let bases;\n\n      if (spec.isClassType(typeInfo)) {\n        const classTypeInfo = typeInfo as spec.ClassType;\n        properties = classTypeInfo.properties;\n        bases = classTypeInfo.base ? [classTypeInfo.base] : [];\n      } else if (spec.isInterfaceType(typeInfo)) {\n        const interfaceTypeInfo = typeInfo as spec.InterfaceType;\n        properties = interfaceTypeInfo.properties;\n        bases = interfaceTypeInfo.interfaces ?? [];\n      } else {\n        throw new Error(\n          `Type of kind ${typeInfo.kind} does not have properties`,\n        );\n      }\n\n      for (const p of properties ?? []) {\n        if (p.name === property) {\n          return p;\n        }\n      }\n\n      // recurse to parent type (if exists)\n      for (const baseFqn of bases) {\n        const ret = this._tryTypeInfoForProperty(property, baseFqn);\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private _typeInfoForProperty(\n    property: string,\n    fqn: string,\n    interfaces?: string[],\n  ): spec.Property {\n    const typeInfo = this._tryTypeInfoForProperty(property, fqn, interfaces);\n    if (!typeInfo) {\n      const addendum =\n        interfaces && interfaces.length > 0\n          ? ` or interface(s) ${interfaces.join(', ')}`\n          : '';\n      throw new Error(\n        `Type ${fqn}${addendum} doesn't have a property '${property}'`,\n      );\n    }\n    return typeInfo;\n  }\n\n  private _toSandbox(v: any, expectedType: wire.OptionalValueOrVoid): any {\n    const serTypes = wire.serializationType(\n      expectedType,\n      this._typeInfoForFqn.bind(this),\n    );\n    this._debug('toSandbox', v, JSON.stringify(serTypes));\n\n    const host: wire.SerializerHost = {\n      objects: this.objects,\n      debug: this._debug.bind(this),\n      findSymbol: this._findSymbol.bind(this),\n      lookupType: this._typeInfoForFqn.bind(this),\n      recurse: this._toSandbox.bind(this),\n    };\n\n    const errors = new Array<string>();\n    for (const { serializationClass, typeRef } of serTypes) {\n      try {\n        return wire.SERIALIZERS[serializationClass].deserialize(\n          v,\n          typeRef,\n          host,\n        );\n      } catch (e) {\n        // If no union (99% case), rethrow immediately to preserve stack trace\n        if (serTypes.length === 1) {\n          throw e;\n        }\n        errors.push(e.message);\n      }\n    }\n\n    throw new Error(\n      `Value did not match any type in union: ${errors.join(', ')}`,\n    );\n  }\n\n  private _fromSandbox(v: any, targetType: wire.OptionalValueOrVoid): any {\n    const serTypes = wire.serializationType(\n      targetType,\n      this._typeInfoForFqn.bind(this),\n    );\n    this._debug('fromSandbox', v, JSON.stringify(serTypes));\n\n    const host: wire.SerializerHost = {\n      objects: this.objects,\n      debug: this._debug.bind(this),\n      findSymbol: this._findSymbol.bind(this),\n      lookupType: this._typeInfoForFqn.bind(this),\n      recurse: this._fromSandbox.bind(this),\n    };\n\n    const errors = new Array<string>();\n    for (const { serializationClass, typeRef } of serTypes) {\n      try {\n        return wire.SERIALIZERS[serializationClass].serialize(v, typeRef, host);\n      } catch (e) {\n        // If no union (99% case), rethrow immediately to preserve stack trace\n        if (serTypes.length === 1) {\n          throw e;\n        }\n        errors.push(e.message);\n      }\n    }\n\n    throw new Error(\n      `Value did not match any type in union: ${errors.join(', ')}`,\n    );\n  }\n\n  private _toSandboxValues(xs: any[], parameters?: spec.Parameter[]) {\n    return this._boxUnboxParameters(xs, parameters, this._toSandbox.bind(this));\n  }\n\n  private _fromSandboxValues(xs: any[], parameters?: spec.Parameter[]) {\n    return this._boxUnboxParameters(\n      xs,\n      parameters,\n      this._fromSandbox.bind(this),\n    );\n  }\n\n  private _boxUnboxParameters(\n    xs: any[],\n    parameters: spec.Parameter[] | undefined,\n    boxUnbox: (x: any, t: wire.OptionalValueOrVoid) => any,\n  ) {\n    parameters = [...(parameters ?? [])];\n    const variadic =\n      parameters.length > 0 && !!parameters[parameters.length - 1].variadic;\n    // Repeat the last (variadic) type to match the number of actual arguments\n    while (variadic && parameters.length < xs.length) {\n      parameters.push(parameters[parameters.length - 1]);\n    }\n    if (xs.length > parameters.length) {\n      throw new Error(\n        `Argument list (${JSON.stringify(\n          xs,\n        )}) not same size as expected argument list (length ${\n          parameters.length\n        })`,\n      );\n    }\n    return xs.map((x, i) => boxUnbox(x, parameters![i]));\n  }\n\n  private _debug(...args: any[]) {\n    if (this.traceEnabled) {\n      console.error('[@jsii/kernel]', ...args);\n    }\n  }\n\n  /**\n   * Ensures that `fn` is called and defends against beginning to invoke\n   * async methods until fn finishes (successfully or not).\n   */\n  private _ensureSync<T>(desc: string, fn: () => T): T {\n    this.syncInProgress = desc;\n    try {\n      return fn();\n    } finally {\n      delete this.syncInProgress;\n    }\n  }\n\n  private _findPropertyTarget(obj: any, property: string) {\n    const superProp = this._getSuperPropertyName(property);\n    if (superProp in obj) {\n      return superProp;\n    }\n    return property;\n  }\n\n  //\n  // type information\n  //\n\n  private _makecbid() {\n    return `jsii::callback::${this.nextid++}`;\n  }\n\n  private _makeprid() {\n    return `jsii::promise::${this.nextid++}`;\n  }\n\n  private _wrapSandboxCode<T>(fn: () => T): T {\n    try {\n      return fn();\n    } catch (err) {\n      throw mapSource(err, this.sourceMaps);\n    }\n  }\n\n  /**\n   * Executes arbitrary code in a VM sandbox.\n   *\n   * @param code       JavaScript code to be executed in the VM\n   * @param sandbox    a VM context to use for running the code\n   * @param sourceMaps source maps to be used in case an exception is thrown\n   * @param filename   the file name to use for the executed code\n   *\n   * @returns the result of evaluating the code\n   */\n  private _execute(code: string, filename: string) {\n    const script = new vm.Script(code, { filename });\n    try {\n      return script.runInContext(this.sandbox, { displayErrors: true });\n    } catch (err) {\n      throw mapSource(err, this.sourceMaps);\n    }\n  }\n}\n\ninterface Callback {\n  objref: api.ObjRef;\n  override: api.MethodOverride;\n  args: any[];\n  expectedReturnType: wire.OptionalValueOrVoid;\n\n  // completion callbacks\n  succeed: (...args: any[]) => any;\n  fail: (...args: any[]) => any;\n}\n\ninterface AsyncInvocation {\n  method: spec.Method;\n  promise: Promise<any>;\n}\n\nclass Assembly {\n  public constructor(\n    public readonly metadata: spec.Assembly,\n    public readonly closure: any,\n  ) {}\n}\n\n/**\n * Applies source maps to an error's stack trace and returns the mapped error,\n * and stitches stack trace elements to adapt the context to the current trace.\n *\n * @param err        is the error to be mapped\n * @param sourceMaps the source maps to be used\n *\n * @returns the mapped error\n */\nfunction mapSource(\n  err: Error,\n  sourceMaps: { [assm: string]: SourceMapConsumer },\n): Error {\n  if (!err.stack) {\n    return err;\n  }\n  const oldFrames = err.stack.split('\\n');\n  const obj = { stack: '' };\n  const previousLimit = Error.stackTraceLimit;\n  try {\n    Error.stackTraceLimit = err.stack.split('\\n').length;\n    Error.captureStackTrace(obj, mapSource);\n    const realFrames = obj.stack.split('\\n').slice(1);\n    const topFrame = realFrames[0].substring(0, realFrames[0].indexOf(' ('));\n    err.stack = [\n      ...oldFrames\n        .slice(\n          0,\n          oldFrames.findIndex((frame) => frame.startsWith(topFrame)),\n        )\n        .map(applyMaps),\n      ...realFrames,\n    ].join('\\n');\n    return err;\n  } finally {\n    Error.stackTraceLimit = previousLimit;\n  }\n\n  function applyMaps(frame: string): string {\n    const mappable = /^(\\s*at\\s+.+)\\(jsii\\/(.+)\\.js:(\\d+):(\\d+)\\)$/;\n    const matches = mappable.exec(frame);\n    if (!matches) {\n      return frame;\n    }\n    const assm = matches[2];\n    if (!(assm in sourceMaps)) {\n      return frame;\n    }\n    const prefix = matches[1];\n    const line = parseInt(matches[3], 10);\n    const column = parseInt(matches[4], 10);\n    const sourceMap = sourceMaps[assm];\n    const pos = sourceMap.originalPositionFor({ line, column });\n    if (pos.source != null && pos.line != null) {\n      const source = pos.source.replace(/^webpack:\\/\\//, `${assm}`);\n      return `${prefix}(${source}:${pos.line}:${pos.column || 0})`;\n    }\n    return frame;\n  }\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy-sync'),\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move-sync'),\n  ...require('./move'),\n  ...require('./output'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","module.exports = require(\"constants\");","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst fs = require('../fs')\nconst path = require('path')\nconst atLeastNode = require('at-least-node')\n\nconst useNativeRecursiveOption = atLeastNode('10.12.0')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n\nconst processOptions = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') options = { mode: options }\n  return { ...defaults, ...options }\n}\n\nconst permissionError = pth => {\n  // This replicates the exception of `fs.mkdir` with native the\n  // `recusive` option when run on an invalid drive under Windows.\n  const error = new Error(`operation not permitted, mkdir '${pth}'`)\n  error.code = 'EPERM'\n  error.errno = -4048\n  error.path = pth\n  error.syscall = 'mkdir'\n  return error\n}\n\nmodule.exports.makeDir = async (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdir(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = async pth => {\n    try {\n      await fs.mkdir(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        await make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        const stats = await fs.stat(pth)\n        if (!stats.isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n\nmodule.exports.makeDirSync = (input, options) => {\n  checkPath(input)\n  options = processOptions(options)\n\n  if (useNativeRecursiveOption) {\n    const pth = path.resolve(input)\n\n    return fs.mkdirSync(pth, {\n      mode: options.mode,\n      recursive: true\n    })\n  }\n\n  const make = pth => {\n    try {\n      fs.mkdirSync(pth, options.mode)\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error\n      }\n\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth)\n        }\n\n        if (error.message.includes('null bytes')) {\n          throw error\n        }\n\n        make(path.dirname(pth))\n        return make(pth)\n      }\n\n      try {\n        if (!fs.statSync(pth).isDirectory()) {\n          // This error is never exposed to the user\n          // it is caught below, and the original error is thrown\n          throw new Error('The path is not a directory')\n        }\n      } catch {\n        throw error\n      }\n    }\n  }\n\n  return make(path.resolve(input))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirs = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimesMillis = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirs(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  fs.copyFile(src, dest, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)\n    return setDestMode(dest, srcStat.mode, cb)\n  })\n}\n\nfunction handleTimestampsAndMode (srcMode, src, dest, cb) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    return makeFileWritable(dest, srcMode, err => {\n      if (err) return cb(err)\n      return setDestTimestampsAndMode(srcMode, src, dest, cb)\n    })\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest, cb)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode, cb) {\n  return setDestMode(dest, srcMode | 0o200, cb)\n}\n\nfunction setDestTimestampsAndMode (srcMode, src, dest, cb) {\n  setDestTimestamps(src, dest, err => {\n    if (err) return cb(err)\n    return setDestMode(dest, srcMode, cb)\n  })\n}\n\nfunction setDestMode (dest, srcMode, cb) {\n  return fs.chmod(dest, srcMode, cb)\n}\n\nfunction setDestTimestamps (src, dest, cb) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  fs.stat(src, (err, updatedSrcStat) => {\n    if (err) return cb(err)\n    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return setDestMode(dest, srcMode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch {}\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    fs.stat(dir, (err, stats) => {\n      if (err) {\n        // if the directory doesn't exist, make it\n        if (err.code === 'ENOENT') {\n          return mkdir.mkdirs(dir, err => {\n            if (err) return callback(err)\n            makeFile()\n          })\n        }\n        return callback(err)\n      }\n\n      if (stats.isDirectory()) makeFile()\n      else {\n        // parent is not a directory\n        // This is just to cause an internal ENOTDIR error to be thrown\n        fs.readdir(dir, err => {\n          if (err) return callback(err)\n        })\n      }\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        toCwd: srcpath,\n        toDst: srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          toCwd: relativeToDst,\n          toDst: srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            toCwd: srcpath,\n            toDst: path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        toCwd: relativeToDst,\n        toDst: srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        toCwd: srcpath,\n        toDst: path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n","let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n","'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nmodule.exports = {\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move'))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","export const SPEC_FILE_NAME = '.jsii';\n\n/**\n * A JSII assembly specification.\n */\nexport interface Assembly extends AssemblyConfiguration, Documentable {\n  /**\n   * The version of the spec schema\n   */\n  schema: SchemaVersion.LATEST;\n\n  /**\n   * The name of the assembly\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Description of the assembly, maps to \"description\" from package.json\n   * This is required since some package managers (like Maven) require it.\n   */\n  description: string;\n\n  /**\n   * The url to the project homepage. Maps to \"homepage\" from package.json.\n   */\n  homepage: string;\n\n  /**\n   * The module repository, maps to \"repository\" from package.json\n   * This is required since some package managers (like Maven) require it.\n   */\n  repository: {\n    /**\n     * The type of the repository (``git``, ``svn``, ...)\n     */\n    type: string;\n\n    /**\n     * The URL of the repository.\n     */\n    url: string;\n\n    /**\n     * If the package is not in the root directory (for example, when part\n     * of a monorepo), you should specify the directory in which it lives.\n     *\n     * @default the root of the repository\n     */\n    directory?: string;\n  };\n\n  /**\n   * The main author of this package.\n   */\n  author: Person;\n\n  /**\n   * Additional contributors to this package.\n   *\n   * @default none\n   */\n  contributors?: Person[];\n\n  /**\n   * A fingerprint that can be used to determine if the specification has\n   * changed.\n   *\n   * @minLength 1\n   */\n  fingerprint: string;\n\n  /**\n   * The version of the assembly\n   * @minLength 1\n   */\n  version: string;\n\n  /**\n   * The version of the jsii compiler that was used to produce this Assembly.\n   * @minLength 1\n   */\n  jsiiVersion: string;\n\n  /**\n   * The SPDX name of the license this assembly is distributed on.\n   */\n  license: string;\n\n  /**\n   * Arbitrary key-value pairs of metadata, which the maintainer chose to\n   * document with the assembly. These entries do not carry normative\n   * semantics and their interpretation is up to the assembly maintainer.\n   *\n   * @default none\n   */\n  metadata?: { [key: string]: any };\n\n  /**\n   * Keywords that help discover or identify this packages with respects to it's\n   * intended usage, audience, etc... Where possible, this will be rendered in\n   * the corresponding metadata section of idiomatic package manifests, for\n   * example NuGet package tags.\n   */\n  keywords?: string[];\n\n  /**\n   * Direct dependencies on other assemblies (with semver), the key is the JSII\n   * assembly name, and the value is a SemVer expression..\n   *\n   * @default none\n   */\n  dependencies?: { [assembly: string]: string };\n\n  /**\n   * Target configuration for all the assemblies that are direct or transitive\n   * dependencies of this assembly. This is needed to generate correct native\n   * type names for any transitively inherited member, in certain languages.\n   *\n   * @default none\n   */\n  dependencyClosure?: { [assembly: string]: AssemblyConfiguration };\n\n  /**\n   * List if bundled dependencies (these are not expected to be jsii\n   * assemblies).\n   *\n   * @default none\n   */\n  bundled?: { [module: string]: string };\n\n  /**\n   * All types in the assembly, keyed by their fully-qualified-name\n   *\n   * @default none\n   */\n  types?: { [fqn: string]: Type };\n\n  /**\n   * The top-level readme document for this assembly (if any).\n   *\n   * @default none\n   */\n  readme?: { markdown: string };\n}\n\n/**\n * Shareable configuration of a jsii Assembly.\n */\nexport interface AssemblyConfiguration extends Targetable {\n  /**\n   * Submodules declared in this assembly.\n   *\n   * @default none\n   */\n  submodules?: { [fqn: string]: SourceLocatable & Targetable };\n}\n\n/**\n * An entity on which targets may be configured.\n */\nexport interface Targetable {\n  /**\n   * Submodules defined in this assembly, if any, associated with their\n   * designated targets configuration.\n   *\n   * @default none\n   */\n  submodules?: { [fqn: string]: { targets?: AssemblyTargets } };\n\n  /**\n   * A map of target name to configuration, which is used when generating\n   * packages for various languages.\n   *\n   * @default none\n   */\n  targets?: AssemblyTargets;\n}\n\n/**\n * Versions of the JSII Assembly Specification.\n */\nexport enum SchemaVersion {\n  LATEST = 'jsii/0.10.0',\n}\n\n/**\n * Fully Qualified Name\n */\nexport type FQN = string;\n\n/**\n * Metadata about people or organizations associated with the project that\n * resulted in the Assembly. Some of this metadata is required in order to\n * publish to certain package repositories (for example, Maven Central), but is\n * not normalized, and the meaning of fields (role, for example), is up to each\n * project maintainer.\n */\nexport interface Person {\n  /**\n   * The name of the person\n   */\n  name: string;\n\n  /**\n   * A list of roles this person has in the project, for example `maintainer`,\n   * `contributor`, `owner`, ...\n   */\n  roles: string[];\n\n  /**\n   * The email of the person\n   *\n   * @default none\n   */\n  email?: string;\n\n  /**\n   * The URL for the person\n   *\n   * @default none\n   */\n  url?: string;\n\n  /**\n   * If true, this person is, in fact, an organization\n   *\n   * @default false\n   */\n  organization?: boolean;\n}\n\n/**\n * Configurable targets for an asembly.\n */\nexport interface AssemblyTargets {\n  /**\n   * Information about a particular language's targets\n   */\n  [language: string]: { [key: string]: any } | undefined;\n}\n\n/**\n * Where in the module source the definition for this API item was found\n */\nexport interface SourceLocation {\n  /**\n   * Relative filename\n   */\n  filename: string;\n\n  /**\n   * 1-based line number in the indicated file\n   */\n  line: number;\n}\n\n/**\n * Key value pairs of documentation nodes.\n * Based on TSDoc.\n */\nexport interface Docs {\n  /**\n   * Summary documentation for an API item.\n   *\n   * The first part of the documentation before hitting a `@remarks` tags, or\n   * the first line of the doc comment block if there is no `@remarks` tag.\n   *\n   * @default none\n   */\n  summary?: string;\n\n  /**\n   * Detailed information about an API item.\n   *\n   * Either the explicitly tagged `@remarks` section, otherwise everything\n   * past the first paragraph if there is no `@remarks` tag.\n   *\n   * @default none\n   */\n  remarks?: string;\n\n  /**\n   * If present, this block indicates that an API item is no longer supported\n   * and may be removed in a future release.  The `@deprecated` tag must be\n   * followed by a sentence describing the recommended alternative.\n   * Deprecation recursively applies to members of a container. For example,\n   * if a class is deprecated, then so are all of its members.\n   *\n   * @default none\n   */\n  deprecated?: string;\n\n  /**\n   * The `@returns` block for this doc comment, or undefined if there is not\n   * one.\n   *\n   * @default none\n   */\n  returns?: string;\n\n  /**\n   * Whether the API item is beta/experimental quality\n   */\n  stability?: Stability;\n\n  /**\n   * Example showing the usage of this API item\n   *\n   * Starts off in running text mode, may switch to code using fenced code\n   * blocks.\n   *\n   * @default none\n   */\n  example?: string;\n\n  /**\n   * A `@see` link with more information\n   *\n   * @default none\n   */\n  see?: string;\n\n  /**\n   * Whether this class or interface was intended to be subclassed/implemented\n   * by library users.\n   *\n   * Classes intended for subclassing, and interfaces intended to be\n   * implemented by consumers, are held to stricter standards of API\n   * compatibility.\n   *\n   * @default false\n   */\n  subclassable?: boolean;\n\n  /**\n   * Description of the default\n   *\n   * @default none\n   */\n  default?: string;\n\n  /**\n   * Custom tags that are not any of the default ones\n   *\n   * @default none\n   */\n  custom?: { [tag: string]: string };\n}\n\n/**\n * API Stability levels. These are modeled after the `node` stability index.\n *\n * @see https://nodejs.org/api/documentation.html#documentation_stability_index.\n */\nexport enum Stability {\n  /**\n   * The API may emit warnings. Backward compatibility is not guaranteed.\n   *\n   * More information about the deprecation can usually be found in the\n   * `deprecated` field.\n   */\n  Deprecated = 'deprecated',\n\n  /**\n   * This API is still under active development and subject to non-backward\n   * compatible changes or removal in any future version. Use of the API is\n   * not recommended in production environments. Experimental APIs are not\n   * subject to the Semantic Versioning model.\n   */\n  Experimental = 'experimental',\n\n  /**\n   * This API is subject to the Semantic Versioning model and may not change\n   * in breaking ways in a subsequent minor or patch version.\n   */\n  Stable = 'stable',\n\n  /**\n   * This API is an representation of an API managed elsewhere and follows\n   * the other API's versioning model.\n   */\n  External = 'external',\n}\n\n/**\n * Indicates that an entity is documentable.\n */\nexport interface Documentable {\n  /**\n   * Documentation for this entity.\n   *\n   * @default none\n   */\n  docs?: Docs;\n}\n\n/**\n * Indicates that an entity has a source location\n */\nexport interface SourceLocatable {\n  /**\n   * Where in the module this definition was found\n   *\n   * Why is this not `locationInAssembly`? Because the assembly is the JSII\n   * file combining compiled code and its manifest, whereas this is referring\n   * to the location of the source in the module the assembly was built from.\n   *\n   * @default none\n   */\n  locationInModule?: SourceLocation;\n}\n\n/**\n * Kinds of collections.\n */\nexport enum CollectionKind {\n  /**\n   * An array, or a list of some element type.\n   */\n  Array = 'array',\n  /**\n   * A map of a string to some element type.\n   */\n  Map = 'map',\n}\n\n/**\n * Kinds of primitive types.\n */\nexport enum PrimitiveType {\n  /**\n   * A JSON date (represented as it's ISO-8601 string form).\n   */\n  Date = 'date',\n\n  /**\n   * A plain string.\n   */\n  String = 'string',\n\n  /**\n   * A number (integer or float).\n   */\n  Number = 'number',\n\n  /**\n   * A boolean value.\n   */\n  Boolean = 'boolean',\n\n  /**\n   * A JSON object\n   */\n  Json = 'json',\n\n  /**\n   * Value with \"any\" or \"unknown\" type (aka Object). Values typed `any` may\n   * be `null` or `undefined`.\n   */\n  Any = 'any',\n}\n\n/**\n * A value that can possibly be optional.\n */\nexport interface OptionalValue {\n  /**\n   * Determines whether the value is, indeed, optional.\n   *\n   * @default false\n   */\n  optional?: boolean;\n\n  /**\n   * The declared type of the value, when it's present.\n   */\n  type: TypeReference;\n}\n\n/**\n * A reference to a type (primitive, collection or fqn).\n */\nexport type TypeReference =\n  | NamedTypeReference\n  | PrimitiveTypeReference\n  | CollectionTypeReference\n  | UnionTypeReference;\n\n/**\n * The standard representation of the `any` type (includes optionality marker).\n */\nexport const CANONICAL_ANY: Readonly<PrimitiveTypeReference> = {\n  primitive: PrimitiveType.Any,\n};\n\n/**\n * Reference to a named type, defined by this assembly or one of its\n * dependencies.\n */\nexport interface NamedTypeReference {\n  /**\n   * The fully-qualified-name of the type (can be located in the\n   * ``spec.types[fqn]``` of the assembly that defines the type).\n   */\n  fqn: FQN;\n}\nexport function isNamedTypeReference(\n  ref: TypeReference | undefined,\n): ref is NamedTypeReference {\n  return !!(ref as NamedTypeReference)?.fqn;\n}\n\n/**\n * Reference to a primitive type.\n */\nexport interface PrimitiveTypeReference {\n  /**\n   * If this is a reference to a primitive type, this will include the\n   * primitive type kind.\n   */\n  primitive: PrimitiveType;\n}\nexport function isPrimitiveTypeReference(\n  ref: TypeReference | undefined,\n): ref is PrimitiveTypeReference {\n  return !!(ref as PrimitiveTypeReference)?.primitive;\n}\n\n/**\n * Reference to a collection type.\n */\nexport interface CollectionTypeReference {\n  collection: {\n    /**\n     * The kind of collection.\n     */\n    kind: CollectionKind;\n\n    /**\n     * The type of an element (map keys are always strings).\n     */\n    elementtype: TypeReference;\n  };\n}\nexport function isCollectionTypeReference(\n  ref: TypeReference | undefined,\n): ref is CollectionTypeReference {\n  return !!(ref as CollectionTypeReference)?.collection;\n}\n\n/**\n * Reference to a union type.\n */\nexport interface UnionTypeReference {\n  /**\n   * Indicates that this is a union type, which means it can be one of a set\n   * of types.\n   */\n  union: {\n    /**\n     * All the possible types (including the primary type).\n     *\n     * @minItems 2\n     */\n    types: TypeReference[];\n  };\n}\nexport function isUnionTypeReference(\n  ref: TypeReference | undefined,\n): ref is UnionTypeReference {\n  return !!(ref as UnionTypeReference)?.union;\n}\n\n/**\n * Methods and properties can be overridden from parent classes or implemented\n * from interfaces.\n */\nexport interface Overridable {\n  /**\n   * The FQN of the parent type (class or interface) that this entity\n   * overrides or implements. If undefined, then this entity is the first in\n   * it's hierarchy to declare this entity.\n   *\n   * @default this member is not overriding anything\n   */\n  overrides?: FQN;\n}\n\n/**\n * A class property.\n */\nexport interface Property\n  extends Documentable,\n    OptionalValue,\n    Overridable,\n    SourceLocatable {\n  /**\n   * The name of the property.\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Indicates if this property only has a getter (immutable).\n   *\n   * @default false\n   */\n  immutable?: boolean;\n\n  /**\n   * Indicates if this property is protected (otherwise it is public)\n   *\n   * @default false\n   */\n  protected?: boolean;\n\n  /**\n   * Indicates if this property is abstract\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * Indicates if this is a static property.\n   *\n   * @default false\n   */\n  static?: boolean;\n\n  /**\n   * A hint that indicates that this static, immutable property is initialized\n   * during startup. This allows emitting \"const\" idioms in different target\n   * languages. Implies `static` and `immutable`.\n   *\n   * @default false\n   */\n  const?: boolean;\n}\n\n/**\n * Represents a method parameter.\n */\nexport interface Parameter extends Documentable, OptionalValue {\n  /**\n   * The name of the parameter.\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * Whether this is the last parameter of a variadic method. In such cases,\n   * the `#type` attribute is the type of each individual item of the variadic\n   * arguments list (as opposed to some array type, as for example TypeScript\n   * would model it).\n   *\n   * @default false\n   */\n  variadic?: boolean;\n}\n\n/**\n * An Initializer or a Method.\n */\nexport interface Callable extends Documentable, Overridable, SourceLocatable {\n  /**\n   * The parameters of the Initializer or Method.\n   *\n   * @default none\n   */\n  parameters?: Parameter[];\n\n  /**\n   * Indicates if this Initializer or Method is protected (otherwise it is\n   * public, since private members are not modeled).\n   *\n   * @default false\n   */\n  protected?: boolean;\n\n  /**\n   * Indicates whether this Initializer or Method is variadic or not. When\n   * ``true``, the last element of ``#parameters`` will also be flagged\n   * ``#variadic``.\n   *\n   * @default false\n   */\n  variadic?: boolean;\n}\n\n/**\n * An initializer.\n */\nexport type Initializer = Callable;\n\n/**\n * A method with a name (i.e: not an initializer).\n */\nexport interface Method extends Callable {\n  /**\n   * The name of the method. Undefined if this method is a initializer.\n   */\n  name: string;\n\n  /**\n   * The return type of the method (`undefined` if `void`)\n   *\n   * @default void\n   */\n  returns?: OptionalValue;\n\n  /**\n   * Is this method an abstract method (this means the class will also be an abstract class)\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * Indicates if this is an asynchronous method (it will return a promise).\n   *\n   * @default false\n   */\n  async?: boolean;\n\n  /**\n   * Indicates if this is a static method.\n   *\n   * @default false\n   */\n  static?: boolean;\n}\n/**\n * Determines whether a Callable is a Method or not.\n *\n * @param callable the callable to be checked.\n */\nexport function isMethod(callable: Callable): callable is Method {\n  return !!(callable as Method).name;\n}\n\n/**\n * Represents a type definition (not a type reference).\n */\nexport type Type = TypeBase & (ClassType | EnumType | InterfaceType);\n\n/**\n * Common attributes of a type definition.\n */\nexport interface TypeBase extends Documentable, SourceLocatable {\n  /**\n   * The fully qualified name of the type (``<assembly>.<namespace>.<name>``)\n   *\n   * @minLength 3\n   */\n  fqn: FQN;\n\n  /**\n   * The name of the assembly the type belongs to.\n   *\n   * @minLength 1\n   */\n  assembly: string;\n\n  /**\n   * The namespace of the type (``foo.bar.baz``). When undefined, the type is located at the root of the assembly\n   * (it's ``fqn`` would be like ``<assembly>.<name>``). If the `namespace` corresponds to an existing type's\n   * namespace-qualified (e.g: ``<namespace>.<name>``), then the current type is a nested type.\n   *\n   * @default none\n   */\n  namespace?: string;\n\n  /**\n   * The simple name of the type (MyClass).\n   *\n   * @minLength 1\n   */\n  name: string;\n\n  /**\n   * The kind of the type.\n   */\n  kind: TypeKind;\n}\n\n/**\n * Kinds of types.\n */\nexport enum TypeKind {\n  Class = 'class',\n  Enum = 'enum',\n  Interface = 'interface',\n}\n\n/**\n * Represents classes.\n */\nexport interface ClassType extends TypeBase {\n  kind: TypeKind.Class;\n\n  /**\n   * The FQN of the base class of this class, if it has one.\n   *\n   * @default no base class\n   */\n  base?: FQN;\n\n  /**\n   * Initializer (constructor) method.\n   *\n   * @default no initializer\n   */\n  initializer?: Initializer;\n\n  /**\n   * List of properties.\n   *\n   * @default none\n   */\n  properties?: Property[];\n\n  /**\n   * List of methods.\n   *\n   * @default none\n   */\n  methods?: Method[];\n\n  /**\n   * Indicates if this class is an abstract class.\n   *\n   * @default false\n   */\n  abstract?: boolean;\n\n  /**\n   * The FQNs of the interfaces this class implements, if any.\n   *\n   * @default none\n   * @uniqueItems true\n   */\n  interfaces?: FQN[];\n}\n\nexport function isClassType(type: Type | undefined): type is ClassType {\n  return type?.kind === TypeKind.Class;\n}\n\nexport interface InterfaceType extends TypeBase {\n  kind: TypeKind.Interface;\n\n  /**\n   * The FQNs of the interfaces this interface extends, if any.\n   *\n   * @default none\n   * @uniqueItems true\n   */\n  interfaces?: FQN[];\n\n  /**\n   * List of methods.\n   *\n   * @default none\n   */\n  methods?: Method[];\n\n  /**\n   * List of properties.\n   *\n   * @default none\n   */\n  properties?: Property[];\n\n  /**\n   * True if this interface only contains properties. Different backends might\n   * have idiomatic ways to allow defining concrete instances such interfaces.\n   * For example, in Java, the generator will produce a PoJo and a builder\n   * which will allow users to create a concrete object with data which\n   * adheres to this interface.\n   *\n   * @default false\n   */\n  datatype?: boolean;\n}\n\nexport function isInterfaceType(type: Type | undefined): type is InterfaceType {\n  return type?.kind === TypeKind.Interface;\n}\n\n/**\n * Represents a member of an enum.\n */\nexport interface EnumMember extends Documentable {\n  /**\n   * The name/symbol of the member.\n   */\n  name: string;\n}\n\n/**\n * Represents an enum type.\n */\nexport interface EnumType extends TypeBase {\n  kind: TypeKind.Enum;\n\n  /**\n   * Members of the enum.\n   */\n  members: EnumMember[];\n}\n\nexport function isEnumType(type: Type | undefined): type is EnumType {\n  return type?.kind === TypeKind.Enum;\n}\n\n/**\n * Return whether this type is a class or interface type\n */\nexport function isClassOrInterfaceType(\n  type: Type | undefined,\n): type is InterfaceType | ClassType {\n  return isClassType(type) || isInterfaceType(type);\n}\n\n/**\n * Return a string representation of the given type reference.\n */\nexport function describeTypeReference(type?: TypeReference): string {\n  if (type === undefined) {\n    return 'void';\n  }\n\n  if (isNamedTypeReference(type)) {\n    return type.fqn;\n  }\n\n  if (isPrimitiveTypeReference(type)) {\n    return type.primitive;\n  }\n\n  if (isCollectionTypeReference(type)) {\n    return `${type.collection.kind}<${describeTypeReference(\n      type.collection.elementtype,\n    )}>`;\n  }\n\n  if (isUnionTypeReference(type)) {\n    const unionType = type.union.types.map(describeTypeReference).join(' | ');\n    return unionType;\n  }\n\n  throw new Error('Unrecognized type reference');\n}\n\n/**\n * Determines whether an entity is deprecated.\n *\n * @param entity the entity to be checked.\n *\n * @returns true if the entity is marked as deprecated.\n */\nexport function isDeprecated(entity: Documentable): boolean {\n  return entity?.docs?.stability === Stability.Deprecated;\n}\n","import * as spec from './assembly';\n\n/**\n * A tree of all names in a module. A node represent a type (terminal)\n * and may represent another node in the namespace (at the same time).\n * Therefore, a key of '_' represents a terminal and references the fqn\n * of the type.\n *\n * For example, say we have the following types:\n *   - aws.ec2.Host\n *   - aws.ec2.Instance\n *   - aws.ec2.Instance.Subtype\n *\n * the the name tree will look like this:\n *\n * module: {\n *   children: {\n *     aws: {\n *       children {\n *         ec2: {\n *           children: {\n *             Host: {\n *               fqn: 'aws.ec2.Host',\n *               children: {}\n *             },\n *             Instance: {\n *               fqn: 'aws.ec2.Host',\n *               children: {\n *                 Subtype: {\n *                   fqn: 'aws.ec2.Host.Subtype',\n *                   children: {}\n *                 }\n *               }\n *             }\n *           }\n *         }\n *       }\n *     }\n *   }\n * }\n */\nexport class NameTree {\n  public static of(assm: spec.Assembly): NameTree {\n    const nameTree = new NameTree();\n    for (const type of Object.values(assm.types ?? {})) {\n      nameTree.register(type.fqn);\n    }\n    return nameTree;\n  }\n\n  private _children: { [name: string]: NameTree } = {};\n  private _fqn?: string;\n\n  /* NameTree.of(assembly) should be used. */\n  private constructor() {}\n\n  /** The children of this node, by name. */\n  public get children(): { readonly [name: string]: NameTree } {\n    return this._children;\n  }\n\n  /** The fully qualified name of the type at this node, if there is one. */\n  public get fqn(): string | undefined {\n    return this._fqn;\n  }\n\n  /**\n   * Adds a type to this ``NameTree``.\n   *\n   * @param type the type to be added.\n   * @param path the path at which to add the node under this tree.\n   */\n  private register(fqn: string, path: string[] = fqn.split('.')): this {\n    if (path.length === 0) {\n      this._fqn = fqn;\n    } else {\n      const [head, ...rest] = path;\n      if (!this._children[head]) {\n        this._children[head] = new NameTree();\n      }\n      this._children[head]!.register(fqn, rest);\n    }\n    return this;\n  }\n}\n","import { Schema, Validator } from 'jsonschema';\nimport { Assembly } from './assembly';\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\nexport const schema: Schema = require('../schema/jsii-spec.schema.json');\n\nexport function validateAssembly(obj: any): Assembly {\n  const validator = new Validator();\n  validator.addSchema(schema); // For definitions\n  const result = validator.validate(obj, schema, { nestedErrors: true } as any); // nestedErrors does exist but is not in the TypeScript definitions\n  if (result.valid) {\n    return obj;\n  }\n  throw new Error(`Invalid assembly:\\n${result.toString()}`);\n}\n","'use strict';\n\nvar Validator = module.exports.Validator = require('./validator');\n\nmodule.exports.ValidatorResult = require('./helpers').ValidatorResult;\nmodule.exports.ValidationError = require('./helpers').ValidationError;\nmodule.exports.SchemaError = require('./helpers').SchemaError;\nmodule.exports.SchemaScanResult = require('./scan').SchemaScanResult;\nmodule.exports.scan = require('./scan').scan;\n\nmodule.exports.validate = function (instance, schema, options) {\n  var v = new Validator();\n  return v.validate(instance, schema, options);\n};\n","'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    this.unresolvedRefs.push(uri);\n  }\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!Array.isArray(schemas)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||anonymousBase, schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n    // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n","'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  options.throwError = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = Object.hasOwnProperty.call(instance, property) ? instance[property] : undefined;\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n","module.exports = require(\"os\");","'use strict'\n\n// high-level commands\nexports.c = exports.create = require('./lib/create.js')\nexports.r = exports.replace = require('./lib/replace.js')\nexports.t = exports.list = require('./lib/list.js')\nexports.u = exports.update = require('./lib/update.js')\nexports.x = exports.extract = require('./lib/extract.js')\n\n// classes\nexports.Pack = require('./lib/pack.js')\nexports.Unpack = require('./lib/unpack.js')\nexports.Parse = require('./lib/parse.js')\nexports.ReadEntry = require('./lib/read-entry.js')\nexports.WriteEntry = require('./lib/write-entry.js')\nexports.Header = require('./lib/header.js')\nexports.Pax = require('./lib/pax.js')\nexports.types = require('./lib/types.js')\n","'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nconst c = module.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","module.exports = require(\"string_decoder\");","module.exports = require(\"buffer\");","// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = require('zlib').constants ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n","'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw Error('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n","'use strict'\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) &~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n","'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n","'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n","'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst mkdir = module.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst mkdirSync = module.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n       p && (part += '/' + p);\n       p = parts.shift()) {\n\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n","const optsArg = require('./lib/opts-arg.js')\nconst pathArg = require('./lib/path-arg.js')\n\nconst {mkdirpNative, mkdirpNativeSync} = require('./lib/mkdirp-native.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./lib/mkdirp-manual.js')\nconst {useNative, useNativeSync} = require('./lib/use-native.js')\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n","const { promisify } = require('util')\nconst fs = require('fs')\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n","const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = require('path')\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n","const {dirname} = require('path')\nconst {findMade, findMadeSync} = require('./find-made.js')\nconst {mkdirpManual, mkdirpManualSync} = require('./mkdirp-manual.js')\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n","const {dirname} = require('path')\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n","const fs = require('fs')\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n","'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  const { join } = require('path')\n  const getDirs = path =>\n    join(path).split(/[\\\\\\/]/).slice(0, -1).reduce((set, path) =>\n      set.length ? set.concat(join(set[set.length-1], path)) : [path], [])\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length-1] instanceof Set)\n        q[q.length-1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n","module.exports = require(\"crypto\");","// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || require('fs')\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n","module.exports = require(\"vm\");","module.exports = require(\"module\");","import { SyncStdio } from './sync-stdio';\nimport { api } from '@jsii/kernel';\n\nexport type Output =\n  | { hello: string }\n  | { ok: api.KernelResponse }\n  | { callback: api.Callback }\n  | { pending: true }\n  | { error: string; stack?: string };\n\nexport type Input =\n  | ({ api: string } & api.KernelRequest)\n  | { complete: api.CompleteRequest };\n\nexport class InputOutput {\n  public debug = false;\n\n  private readonly stdio = new SyncStdio();\n\n  public write(obj: Output) {\n    const output = JSON.stringify(obj);\n    this.stdio.writeLine(output);\n\n    if (this.debug) {\n      this.stdio.writeErrorLine(`< ${output}`);\n    }\n  }\n\n  public read(): Input | undefined {\n    let reqLine = this.stdio.readLine();\n    if (!reqLine) {\n      return undefined;\n    }\n\n    // skip recorded responses\n    if (reqLine.startsWith('< ')) {\n      return this.read();\n    }\n\n    // stip \"> \" from recorded requests\n    if (reqLine.startsWith('> ')) {\n      reqLine = reqLine.substr(2);\n    }\n\n    const input = JSON.parse(reqLine);\n\n    if (this.debug) {\n      this.stdio.writeErrorLine(`> ${JSON.stringify(input)}`);\n    }\n\n    return input;\n  }\n}\n","import * as fs from 'fs';\n\nconst STDIN_FD = 0;\nconst STDOUT_FD = 1;\nconst STDERR_FD = 2;\nconst INPUT_BUFFER_SIZE = 1024 * 1024; // not related to max line length\n\nconst EMPTY_BUFFER = Buffer.alloc(0);\n\nexport class SyncStdio {\n  private bufferedData = EMPTY_BUFFER;\n\n  public writeErrorLine(line: string) {\n    this.writeBuffer(Buffer.from(`${line}\\n`), STDERR_FD);\n  }\n\n  public writeLine(line: string) {\n    this.writeBuffer(Buffer.from(`${line}\\n`), STDOUT_FD);\n  }\n\n  public readLine(): string | undefined {\n    const buff = Buffer.alloc(INPUT_BUFFER_SIZE);\n    while (!this.bufferedData.includes('\\n', 0, 'utf-8')) {\n      try {\n        const read = fs.readSync(STDIN_FD, buff, 0, buff.length, null);\n\n        if (read === 0) {\n          return undefined;\n        }\n\n        const newData = buff.slice(0, read);\n        this.bufferedData = Buffer.concat([this.bufferedData, newData]);\n      } catch (e) {\n        // HACK: node may set O_NONBLOCK on it's STDIN depending on what kind of input it is made\n        // of (see https://github.com/nodejs/help/issues/2663). When STDIN has O_NONBLOCK, calls may\n        // result in EAGAIN. In such cases, the call should be retried until it succeeds. This kind\n        // of polling will result in horrible CPU thrashing, but there does not seem to be a way to\n        // force a O_SYNC access to STDIN in a reliable way within node.\n        // In order to make this stop we need to either stop depending on synchronous reads, or to\n        // provision our own communication channel that can reliably be synchronous. This work is\n        // \"tracked\" at https://github.com/aws/aws-cdk/issues/5187\n        if (e.code !== 'EAGAIN') {\n          throw e;\n        }\n      }\n    }\n\n    const newLinePos = this.bufferedData.indexOf('\\n', 0, 'utf-8');\n    const next = this.bufferedData.slice(0, newLinePos).toString('utf-8');\n    this.bufferedData = this.bufferedData.slice(newLinePos + 1);\n\n    return next;\n  }\n\n  private writeBuffer(buffer: Buffer, fd: number) {\n    let offset = 0;\n    while (offset < buffer.length) {\n      try {\n        offset += fs.writeSync(fd, buffer, offset);\n      } catch (e) {\n        if (e.code !== 'EAGAIN') {\n          throw e;\n        }\n      }\n    }\n  }\n}\n"],"sourceRoot":""}