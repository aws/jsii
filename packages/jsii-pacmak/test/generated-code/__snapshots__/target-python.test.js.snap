// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/ 1`] = `
<root>
 ‚îó‚îÅ üìÅ python
    ‚î£‚îÅ üìÑ LICENSE
    ‚î£‚îÅ üìÑ MANIFEST.in
    ‚î£‚îÅ üìÑ NOTICE
    ‚î£‚îÅ üìÑ pyproject.toml
    ‚î£‚îÅ üìÑ README.md
    ‚î£‚îÅ üìÑ setup.py
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_base
             ‚î£‚îÅ üìÑ __init__.py
             ‚î£‚îÅ üìÅ _jsii
             ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
             ‚îÉ  ‚îó‚îÅ üìÑ jsii-calc-base@0.0.0.jsii.tgz
             ‚îó‚îÅ üìÑ py.typed
`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/LICENSE 1`] = `

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/MANIFEST.in 1`] = `
include pyproject.toml

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/NOTICE 1`] = `
jsii
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/README.md 1`] = `
scope.jsii-calc-base
====================

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/pyproject.toml 1`] = `
[build-system]
requires = ["setuptools~=67.3.2", "wheel~=0.38"]
build-backend = "setuptools.build_meta"

[tool.pyright]
defineConstant = { DEBUG = true }
pythonVersion = "3.7"
pythonPlatform = "All"
reportSelfClsParameterName = false

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/setup.py 1`] = `
import json
import setuptools

kwargs = json.loads(
    """
{
    "name": "scope.jsii-calc-base",
    "version": "0.0.0",
    "description": "An example direct dependency for jsii-calc.",
    "license": "Apache-2.0",
    "url": "https://github.com/aws/jsii",
    "long_description_content_type": "text/markdown",
    "author": "Amazon Web Services",
    "bdist_wheel": {
        "universal": true
    },
    "project_urls": {
        "Source": "https://github.com/aws/jsii.git"
    },
    "package_dir": {
        "": "src"
    },
    "packages": [
        "scope.jsii_calc_base",
        "scope.jsii_calc_base._jsii"
    ],
    "package_data": {
        "scope.jsii_calc_base._jsii": [
            "jsii-calc-base@0.0.0.jsii.tgz"
        ],
        "scope.jsii_calc_base": [
            "py.typed"
        ]
    },
    "python_requires": "~=3.7",
    "install_requires": [
        "jsii<0.0.1",
        "publication>=0.0.3",
        "scope.jsii-calc-base-of-base>=2.1.1, <3.0.0",
        "typeguard~=2.13.3"
    ],
    "classifiers": [
        "Intended Audience :: Developers",
        "Operating System :: OS Independent",
        "Programming Language :: JavaScript",
        "Programming Language :: Python :: 3 :: Only",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Typing :: Typed",
        "License :: OSI Approved"
    ],
    "scripts": []
}
"""
)

with open("README.md", encoding="utf8") as fp:
    kwargs["long_description"] = fp.read()


setuptools.setup(**kwargs)

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/src/scope/jsii_calc_base/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import scope.jsii_calc_base_of_base as _scope_jsii_calc_base_of_base_49fa37fe


class Base(metaclass=jsii.JSIIAbstractClass, jsii_type="@scope/jsii-calc-base.Base"):
    '''A base class.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="typeName")
    def type_name(self) -> typing.Any:
        '''
        :return: the name of the class (to verify native type names are created for derived classes).
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "typeName", []))


class _BaseProxy(Base):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Base).__jsii_proxy_class__ = lambda : _BaseProxy


@jsii.data_type(
    jsii_type="@scope/jsii-calc-base.BaseProps",
    jsii_struct_bases=[_scope_jsii_calc_base_of_base_49fa37fe.VeryBaseProps],
    name_mapping={"foo": "foo", "bar": "bar"},
)
class BaseProps(_scope_jsii_calc_base_of_base_49fa37fe.VeryBaseProps):
    def __init__(
        self,
        *,
        foo: _scope_jsii_calc_base_of_base_49fa37fe.Very,
        bar: builtins.str,
    ) -> None:
        '''
        :param foo: -
        :param bar: -
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
            "bar": bar,
        }

    @builtins.property
    def foo(self) -> _scope_jsii_calc_base_of_base_49fa37fe.Very:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(_scope_jsii_calc_base_of_base_49fa37fe.Very, result)

    @builtins.property
    def bar(self) -> builtins.str:
        result = self._values.get("bar")
        assert result is not None, "Required property 'bar' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="@scope/jsii-calc-base.IBaseInterface")
class IBaseInterface(
    _scope_jsii_calc_base_of_base_49fa37fe.IVeryBaseInterface,
    typing_extensions.Protocol,
):
    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        ...


class _IBaseInterfaceProxy(
    jsii.proxy_for(_scope_jsii_calc_base_of_base_49fa37fe.IVeryBaseInterface), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-base.IBaseInterface"

    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bar", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IBaseInterface).__jsii_proxy_class__ = lambda : _IBaseInterfaceProxy


class StaticConsumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-base.StaticConsumer",
):
    '''Hides the transitive dependency of base-of-base.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="consume")
    @builtins.classmethod
    def consume(cls, *args: typing.Any) -> None:
        '''
        :param args: -
        '''
        return typing.cast(None, jsii.sinvoke(cls, "consume", [*args]))


__all__ = [
    "Base",
    "BaseProps",
    "IBaseInterface",
    "StaticConsumer",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/src/scope/jsii_calc_base/_jsii/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

import scope.jsii_calc_base_of_base._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    "@scope/jsii-calc-base", "0.0.0", __name__[0:-6], "jsii-calc-base@0.0.0.jsii.tgz"
)

__all__ = [
    "__jsii_assembly__",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/src/scope/jsii_calc_base/_jsii/jsii-calc-base@0.0.0.jsii.tgz 1`] = `python/src/scope/jsii_calc_base/_jsii/jsii-calc-base@0.0.0.jsii.tgz is a tarball`;

exports[`Generated code for "@scope/jsii-calc-base": <outDir>/python/src/scope/jsii_calc_base/py.typed 1`] = `


`;

exports[`Generated code for "@scope/jsii-calc-base": <runtime-type-check-diff>/ 1`] = `
<runtime-type-check-diff>
 ‚îó‚îÅ üìÅ python
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_base
             ‚îó‚îÅ üìÑ __init__.py.diff
`;

exports[`Generated code for "@scope/jsii-calc-base": <runtime-type-check-diff>/python/src/scope/jsii_calc_base/__init__.py.diff 1`] = `
--- python/src/scope/jsii_calc_base/__init__.py	--no-runtime-type-checking
+++ python/src/scope/jsii_calc_base/__init__.py	--runtime-type-checking
@@ -50,10 +50,14 @@
     ) -> None:
         '''
         :param foo: -
         :param bar: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e2d8a566db7d86eb1cb511cb869273dae39a21b3ad7041359aabb7bd283dcfef)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
             "bar": bar,
         }
 
@@ -117,10 +121,13 @@
     @builtins.classmethod
     def consume(cls, *args: typing.Any) -> None:
         '''
         :param args: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__66400f6ebe2f9a3fbb550342b894bebf4f5368890843f3917e2b903f62d48b38)
+            check_type(argname="argument args", value=args, expected_type=typing.Tuple[type_hints["args"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(None, jsii.sinvoke(cls, "consume", [*args]))
 
 
 __all__ = [
     "Base",
@@ -128,5 +135,19 @@
     "IBaseInterface",
     "StaticConsumer",
 ]
 
 publication.publish()
+
+def _typecheckingstub__e2d8a566db7d86eb1cb511cb869273dae39a21b3ad7041359aabb7bd283dcfef(
+    *,
+    foo: _scope_jsii_calc_base_of_base_49fa37fe.Very,
+    bar: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__66400f6ebe2f9a3fbb550342b894bebf4f5368890843f3917e2b903f62d48b38(
+    *args: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/ 1`] = `
<root>
 ‚îó‚îÅ üìÅ python
    ‚î£‚îÅ üìÑ LICENSE
    ‚î£‚îÅ üìÑ MANIFEST.in
    ‚î£‚îÅ üìÑ NOTICE
    ‚î£‚îÅ üìÑ pyproject.toml
    ‚î£‚îÅ üìÑ README.md
    ‚î£‚îÅ üìÑ setup.py
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_base_of_base
             ‚î£‚îÅ üìÑ __init__.py
             ‚î£‚îÅ üìÅ _jsii
             ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
             ‚îÉ  ‚îó‚îÅ üìÑ jsii-calc-base-of-base@2.1.1.jsii.tgz
             ‚îó‚îÅ üìÑ py.typed
`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/LICENSE 1`] = `

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/MANIFEST.in 1`] = `
include pyproject.toml

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/NOTICE 1`] = `
jsii
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/README.md 1`] = `
scope.jsii-calc-base-of-base
============================

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/pyproject.toml 1`] = `
[build-system]
requires = ["setuptools~=67.3.2", "wheel~=0.38"]
build-backend = "setuptools.build_meta"

[tool.pyright]
defineConstant = { DEBUG = true }
pythonVersion = "3.7"
pythonPlatform = "All"
reportSelfClsParameterName = false

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/setup.py 1`] = `
import json
import setuptools

kwargs = json.loads(
    """
{
    "name": "scope.jsii-calc-base-of-base",
    "version": "2.1.1",
    "description": "An example transitive dependency for jsii-calc.",
    "license": "Apache-2.0",
    "url": "https://github.com/aws/jsii",
    "long_description_content_type": "text/markdown",
    "author": "Amazon Web Services",
    "bdist_wheel": {
        "universal": true
    },
    "project_urls": {
        "Source": "https://github.com/aws/jsii.git"
    },
    "package_dir": {
        "": "src"
    },
    "packages": [
        "scope.jsii_calc_base_of_base",
        "scope.jsii_calc_base_of_base._jsii"
    ],
    "package_data": {
        "scope.jsii_calc_base_of_base._jsii": [
            "jsii-calc-base-of-base@2.1.1.jsii.tgz"
        ],
        "scope.jsii_calc_base_of_base": [
            "py.typed"
        ]
    },
    "python_requires": "~=3.7",
    "install_requires": [
        "jsii<0.0.1",
        "publication>=0.0.3",
        "typeguard~=2.13.3"
    ],
    "classifiers": [
        "Intended Audience :: Developers",
        "Operating System :: OS Independent",
        "Programming Language :: JavaScript",
        "Programming Language :: Python :: 3 :: Only",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Typing :: Typed",
        "License :: OSI Approved"
    ],
    "scripts": []
}
"""
)

with open("README.md", encoding="utf8") as fp:
    kwargs["long_description"] = fp.read()


setuptools.setup(**kwargs)

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/src/scope/jsii_calc_base_of_base/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *


@jsii.interface(jsii_type="@scope/jsii-calc-base-of-base.IVeryBaseInterface")
class IVeryBaseInterface(typing_extensions.Protocol):
    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        ...


class _IVeryBaseInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-base-of-base.IVeryBaseInterface"

    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "foo", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVeryBaseInterface).__jsii_proxy_class__ = lambda : _IVeryBaseInterfaceProxy


class StaticConsumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-base-of-base.StaticConsumer",
):
    @jsii.member(jsii_name="consume")
    @builtins.classmethod
    def consume(cls, *_args: typing.Any) -> None:
        '''
        :param _args: -
        '''
        return typing.cast(None, jsii.sinvoke(cls, "consume", [*_args]))


class Very(metaclass=jsii.JSIIMeta, jsii_type="@scope/jsii-calc-base-of-base.Very"):
    '''(experimental) Something here.

    :stability: experimental
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="hey")
    def hey(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "hey", []))


@jsii.data_type(
    jsii_type="@scope/jsii-calc-base-of-base.VeryBaseProps",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo"},
)
class VeryBaseProps:
    def __init__(self, *, foo: Very) -> None:
        '''
        :param foo: -
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }

    @builtins.property
    def foo(self) -> Very:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(Very, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VeryBaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "IVeryBaseInterface",
    "StaticConsumer",
    "Very",
    "VeryBaseProps",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/src/scope/jsii_calc_base_of_base/_jsii/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

__jsii_assembly__ = jsii.JSIIAssembly.load(
    "@scope/jsii-calc-base-of-base",
    "2.1.1",
    __name__[0:-6],
    "jsii-calc-base-of-base@2.1.1.jsii.tgz",
)

__all__ = [
    "__jsii_assembly__",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/src/scope/jsii_calc_base_of_base/_jsii/jsii-calc-base-of-base@2.1.1.jsii.tgz 1`] = `python/src/scope/jsii_calc_base_of_base/_jsii/jsii-calc-base-of-base@2.1.1.jsii.tgz is a tarball`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <outDir>/python/src/scope/jsii_calc_base_of_base/py.typed 1`] = `


`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <runtime-type-check-diff>/ 1`] = `
<runtime-type-check-diff>
 ‚îó‚îÅ üìÅ python
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_base_of_base
             ‚îó‚îÅ üìÑ __init__.py.diff
`;

exports[`Generated code for "@scope/jsii-calc-base-of-base": <runtime-type-check-diff>/python/src/scope/jsii_calc_base_of_base/__init__.py.diff 1`] = `
--- python/src/scope/jsii_calc_base_of_base/__init__.py	--no-runtime-type-checking
+++ python/src/scope/jsii_calc_base_of_base/__init__.py	--runtime-type-checking
@@ -39,10 +39,13 @@
     @builtins.classmethod
     def consume(cls, *_args: typing.Any) -> None:
         '''
         :param _args: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__740535cda6ecbc578919a2921dd1fa0b87c5dd735a2acd391963310cdf59f47c)
+            check_type(argname="argument _args", value=_args, expected_type=typing.Tuple[type_hints["_args"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(None, jsii.sinvoke(cls, "consume", [*_args]))
 
 
 class Very(metaclass=jsii.JSIIMeta, jsii_type="@scope/jsii-calc-base-of-base.Very"):
     '''(experimental) Something here.
@@ -69,10 +72,13 @@
 class VeryBaseProps:
     def __init__(self, *, foo: Very) -> None:
         '''
         :param foo: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c314d9d6951cb6f41a208c5feb55cc9d30da774b67f6d47cb4fa13215b96f2b9)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
 
     @builtins.property
@@ -99,5 +105,18 @@
     "Very",
     "VeryBaseProps",
 ]
 
 publication.publish()
+
+def _typecheckingstub__740535cda6ecbc578919a2921dd1fa0b87c5dd735a2acd391963310cdf59f47c(
+    *_args: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c314d9d6951cb6f41a208c5feb55cc9d30da774b67f6d47cb4fa13215b96f2b9(
+    *,
+    foo: Very,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/ 1`] = `
<root>
 ‚îó‚îÅ üìÅ python
    ‚î£‚îÅ üìÑ LICENSE
    ‚î£‚îÅ üìÑ MANIFEST.in
    ‚î£‚îÅ üìÑ NOTICE
    ‚î£‚îÅ üìÑ pyproject.toml
    ‚î£‚îÅ üìÑ README.md
    ‚î£‚îÅ üìÑ setup.py
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_lib
             ‚î£‚îÅ üìÑ __init__.py
             ‚î£‚îÅ üìÅ _jsii
             ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
             ‚îÉ  ‚îó‚îÅ üìÑ jsii-calc-lib@0.0.0.jsii.tgz
             ‚î£‚îÅ üìÅ custom_submodule_name
             ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
             ‚î£‚îÅ üìÅ deprecation_removal
             ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
             ‚îó‚îÅ üìÑ py.typed
`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/LICENSE 1`] = `

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/MANIFEST.in 1`] = `
include pyproject.toml

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/NOTICE 1`] = `
jsii
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/README.md 1`] = `
scope.jsii-calc-lib
===================

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/pyproject.toml 1`] = `
[build-system]
requires = ["setuptools~=67.3.2", "wheel~=0.38"]
build-backend = "setuptools.build_meta"

[tool.pyright]
defineConstant = { DEBUG = true }
pythonVersion = "3.7"
pythonPlatform = "All"
reportSelfClsParameterName = false

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/setup.py 1`] = `
import json
import setuptools

kwargs = json.loads(
    """
{
    "name": "scope.jsii-calc-lib",
    "version": "0.0.0",
    "description": "A simple calcuator library built on JSII.",
    "license": "Apache-2.0",
    "url": "https://github.com/aws/jsii",
    "long_description_content_type": "text/markdown",
    "author": "Amazon Web Services",
    "bdist_wheel": {
        "universal": true
    },
    "project_urls": {
        "Source": "https://github.com/aws/jsii.git"
    },
    "package_dir": {
        "": "src"
    },
    "packages": [
        "scope.jsii_calc_lib",
        "scope.jsii_calc_lib._jsii",
        "scope.jsii_calc_lib.custom_submodule_name",
        "scope.jsii_calc_lib.deprecation_removal"
    ],
    "package_data": {
        "scope.jsii_calc_lib._jsii": [
            "jsii-calc-lib@0.0.0.jsii.tgz"
        ],
        "scope.jsii_calc_lib": [
            "py.typed"
        ]
    },
    "python_requires": "~=3.7",
    "install_requires": [
        "jsii<0.0.1",
        "publication>=0.0.3",
        "scope.jsii-calc-base-of-base>=2.1.1, <3.0.0",
        "scope.jsii-calc-base<0.0.1",
        "typeguard~=2.13.3"
    ],
    "classifiers": [
        "Intended Audience :: Developers",
        "Operating System :: OS Independent",
        "Programming Language :: JavaScript",
        "Programming Language :: Python :: 3 :: Only",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Typing :: Typed",
        "Development Status :: 7 - Inactive",
        "License :: OSI Approved"
    ],
    "scripts": []
}
"""
)

with open("README.md", encoding="utf8") as fp:
    kwargs["long_description"] = fp.read()


setuptools.setup(**kwargs)

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_base_of_base as _scope_jsii_calc_base_of_base_49fa37fe


class BaseFor2647(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-lib.BaseFor2647",
):
    '''(deprecated) A base class for testing #2647.

    The method \`\`foo\`\` has a parameter that uses a type
    from a dependent module. Since Go "reimplments" this method, it will also need
    to include an "import" statement for the calc-base module.

    :see: https://github.com/aws/jsii/issues/2647
    :stability: deprecated
    '''

    def __init__(self, very: _scope_jsii_calc_base_of_base_49fa37fe.Very) -> None:
        '''
        :param very: -

        :stability: deprecated
        '''
        jsii.create(self.__class__, self, [very])

    @jsii.member(jsii_name="foo")
    def foo(self, obj: _scope_jsii_calc_base_734f0262.IBaseInterface) -> None:
        '''
        :param obj: -

        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "foo", [obj]))


@jsii.data_type(
    jsii_type="@scope/jsii-calc-lib.DiamondLeft",
    jsii_struct_bases=[],
    name_mapping={"hoisted_top": "hoistedTop", "left": "left"},
)
class DiamondLeft:
    def __init__(
        self,
        *,
        hoisted_top: typing.Optional[builtins.str] = None,
        left: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param hoisted_top: 
        :param left: 

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hoisted_top is not None:
            self._values["hoisted_top"] = hoisted_top
        if left is not None:
            self._values["left"] = left

    @builtins.property
    def hoisted_top(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("hoisted_top")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def left(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("left")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondLeft(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@scope/jsii-calc-lib.DiamondRight",
    jsii_struct_bases=[],
    name_mapping={"hoisted_top": "hoistedTop", "right": "right"},
)
class DiamondRight:
    def __init__(
        self,
        *,
        hoisted_top: typing.Optional[builtins.str] = None,
        right: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param hoisted_top: 
        :param right: 

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hoisted_top is not None:
            self._values["hoisted_top"] = hoisted_top
        if right is not None:
            self._values["right"] = right

    @builtins.property
    def hoisted_top(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("hoisted_top")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def right(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("right")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondRight(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="@scope/jsii-calc-lib.EnumFromScopedModule")
class EnumFromScopedModule(enum.Enum):
    '''(deprecated) Check that enums from @scoped packages can be references.

    See awslabs/jsii#138

    :stability: deprecated
    '''

    VALUE1 = "VALUE1"
    '''
    :stability: deprecated
    '''
    VALUE2 = "VALUE2"
    '''
    :stability: deprecated
    '''


@jsii.interface(jsii_type="@scope/jsii-calc-lib.IDoublable")
class IDoublable(typing_extensions.Protocol):
    '''(deprecated) The general contract for a concrete number.

    :stability: deprecated
    '''

    @builtins.property
    @jsii.member(jsii_name="doubleValue")
    def double_value(self) -> jsii.Number:
        '''
        :stability: deprecated
        '''
        ...


class _IDoublableProxy:
    '''(deprecated) The general contract for a concrete number.

    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-lib.IDoublable"

    @builtins.property
    @jsii.member(jsii_name="doubleValue")
    def double_value(self) -> jsii.Number:
        '''
        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "doubleValue"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDoublable).__jsii_proxy_class__ = lambda : _IDoublableProxy


@jsii.interface(jsii_type="@scope/jsii-calc-lib.IFriendly")
class IFriendly(typing_extensions.Protocol):
    '''(deprecated) Applies to classes that are considered friendly.

    These classes can be greeted with
    a "hello" or "goodbye" blessing and they will respond back in a fun and friendly manner.

    :stability: deprecated
    '''

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''(deprecated) Say hello!

        :stability: deprecated
        '''
        ...


class _IFriendlyProxy:
    '''(deprecated) Applies to classes that are considered friendly.

    These classes can be greeted with
    a "hello" or "goodbye" blessing and they will respond back in a fun and friendly manner.

    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-lib.IFriendly"

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''(deprecated) Say hello!

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "hello", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFriendly).__jsii_proxy_class__ = lambda : _IFriendlyProxy


@jsii.interface(jsii_type="@scope/jsii-calc-lib.IThreeLevelsInterface")
class IThreeLevelsInterface(
    _scope_jsii_calc_base_734f0262.IBaseInterface,
    typing_extensions.Protocol,
):
    '''(deprecated) Interface that inherits from packages 2 levels up the tree.

    Their presence validates that .NET/Java/jsii-reflect can track all fields
    far enough up the tree.

    :stability: deprecated
    '''

    @jsii.member(jsii_name="baz")
    def baz(self) -> None:
        '''
        :stability: deprecated
        '''
        ...


class _IThreeLevelsInterfaceProxy(
    jsii.proxy_for(_scope_jsii_calc_base_734f0262.IBaseInterface), # type: ignore[misc]
):
    '''(deprecated) Interface that inherits from packages 2 levels up the tree.

    Their presence validates that .NET/Java/jsii-reflect can track all fields
    far enough up the tree.

    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-lib.IThreeLevelsInterface"

    @jsii.member(jsii_name="baz")
    def baz(self) -> None:
        '''
        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "baz", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IThreeLevelsInterface).__jsii_proxy_class__ = lambda : _IThreeLevelsInterfaceProxy


@jsii.data_type(
    jsii_type="@scope/jsii-calc-lib.MyFirstStruct",
    jsii_struct_bases=[],
    name_mapping={
        "anumber": "anumber",
        "astring": "astring",
        "first_optional": "firstOptional",
    },
)
class MyFirstStruct:
    def __init__(
        self,
        *,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''(deprecated) This is the first struct we have created in jsii.

        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "anumber": anumber,
            "astring": astring,
        }
        if first_optional is not None:
            self._values["first_optional"] = first_optional

    @builtins.property
    def anumber(self) -> jsii.Number:
        '''(deprecated) An awesome number value.

        :stability: deprecated
        '''
        result = self._values.get("anumber")
        assert result is not None, "Required property 'anumber' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def astring(self) -> builtins.str:
        '''(deprecated) A string value.

        :stability: deprecated
        '''
        result = self._values.get("astring")
        assert result is not None, "Required property 'astring' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def first_optional(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("first_optional")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MyFirstStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NumericValue(
    _scope_jsii_calc_base_734f0262.Base,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@scope/jsii-calc-lib.NumericValue",
):
    '''(deprecated) Abstract class which represents a numeric value.

    :stability: deprecated
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''(deprecated) String representation of the value.

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="value")
    @abc.abstractmethod
    def value(self) -> jsii.Number:
        '''(deprecated) The value.

        :stability: deprecated
        '''
        ...


class _NumericValueProxy(
    NumericValue,
    jsii.proxy_for(_scope_jsii_calc_base_734f0262.Base), # type: ignore[misc]
):
    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''(deprecated) The value.

        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "value"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, NumericValue).__jsii_proxy_class__ = lambda : _NumericValueProxy


class Operation(
    NumericValue,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@scope/jsii-calc-lib.Operation",
):
    '''(deprecated) Represents an operation on values.

    :stability: deprecated
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toString")
    @abc.abstractmethod
    def to_string(self) -> builtins.str:
        '''(deprecated) String representation of the value.

        :stability: deprecated
        '''
        ...


class _OperationProxy(
    Operation,
    jsii.proxy_for(NumericValue), # type: ignore[misc]
):
    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''(deprecated) String representation of the value.

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Operation).__jsii_proxy_class__ = lambda : _OperationProxy


@jsii.data_type(
    jsii_type="@scope/jsii-calc-lib.StructWithOnlyOptionals",
    jsii_struct_bases=[],
    name_mapping={
        "optional1": "optional1",
        "optional2": "optional2",
        "optional3": "optional3",
    },
)
class StructWithOnlyOptionals:
    def __init__(
        self,
        *,
        optional1: typing.Optional[builtins.str] = None,
        optional2: typing.Optional[jsii.Number] = None,
        optional3: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(deprecated) This is a struct with only optional properties.

        :param optional1: (deprecated) The first optional!
        :param optional2: 
        :param optional3: 

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if optional1 is not None:
            self._values["optional1"] = optional1
        if optional2 is not None:
            self._values["optional2"] = optional2
        if optional3 is not None:
            self._values["optional3"] = optional3

    @builtins.property
    def optional1(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The first optional!

        :stability: deprecated
        '''
        result = self._values.get("optional1")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional2(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("optional2")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def optional3(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("optional3")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructWithOnlyOptionals(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDoublable)
class Number(
    NumericValue,
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-lib.Number",
):
    '''(deprecated) Represents a concrete number.

    :stability: deprecated
    '''

    def __init__(self, value: jsii.Number) -> None:
        '''(deprecated) Creates a Number object.

        :param value: The number.

        :stability: deprecated
        '''
        jsii.create(self.__class__, self, [value])

    @builtins.property
    @jsii.member(jsii_name="doubleValue")
    def double_value(self) -> jsii.Number:
        '''(deprecated) The number multiplied by 2.

        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "doubleValue"))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''(deprecated) The number.

        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "value"))


__all__ = [
    "BaseFor2647",
    "DiamondLeft",
    "DiamondRight",
    "EnumFromScopedModule",
    "IDoublable",
    "IFriendly",
    "IThreeLevelsInterface",
    "MyFirstStruct",
    "Number",
    "NumericValue",
    "Operation",
    "StructWithOnlyOptionals",
    "custom_submodule_name",
    "deprecation_removal",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import custom_submodule_name
from . import deprecation_removal

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/_jsii/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

import scope.jsii_calc_base._jsii
import scope.jsii_calc_base_of_base._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    "@scope/jsii-calc-lib", "0.0.0", __name__[0:-6], "jsii-calc-lib@0.0.0.jsii.tgz"
)

__all__ = [
    "__jsii_assembly__",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/_jsii/jsii-calc-lib@0.0.0.jsii.tgz 1`] = `python/src/scope/jsii_calc_lib/_jsii/jsii-calc-lib@0.0.0.jsii.tgz is a tarball`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/custom_submodule_name/__init__.py 1`] = `
'''
# Submodule Readme

This is a submodule readme.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.interface(jsii_type="@scope/jsii-calc-lib.submodule.IReflectable")
class IReflectable(typing_extensions.Protocol):
    '''
    :stability: deprecated
    '''

    @builtins.property
    @jsii.member(jsii_name="entries")
    def entries(self) -> typing.List["ReflectableEntry"]:
        '''
        :stability: deprecated
        '''
        ...


class _IReflectableProxy:
    '''
    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-lib.submodule.IReflectable"

    @builtins.property
    @jsii.member(jsii_name="entries")
    def entries(self) -> typing.List["ReflectableEntry"]:
        '''
        :stability: deprecated
        '''
        return typing.cast(typing.List["ReflectableEntry"], jsii.get(self, "entries"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IReflectable).__jsii_proxy_class__ = lambda : _IReflectableProxy


class NestingClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-lib.submodule.NestingClass",
):
    '''(deprecated) This class is here to show we can use nested classes across module boundaries.

    :stability: deprecated
    '''

    class NestedClass(
        metaclass=jsii.JSIIMeta,
        jsii_type="@scope/jsii-calc-lib.submodule.NestingClass.NestedClass",
    ):
        '''(deprecated) This class is here to show we can use nested classes across module boundaries.

        :stability: deprecated
        '''

        def __init__(self) -> None:
            '''
            :stability: deprecated
            '''
            jsii.create(self.__class__, self, [])

        @builtins.property
        @jsii.member(jsii_name="property")
        def property(self) -> builtins.str:
            '''
            :stability: deprecated
            '''
            return typing.cast(builtins.str, jsii.get(self, "property"))

    @jsii.data_type(
        jsii_type="@scope/jsii-calc-lib.submodule.NestingClass.NestedStruct",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class NestedStruct:
        def __init__(self, *, name: builtins.str) -> None:
            '''(deprecated) This is a struct, nested within a class.

            Normal.

            :param name: 

            :stability: deprecated
            '''
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "name": name,
            }

        @builtins.property
        def name(self) -> builtins.str:
            '''
            :stability: deprecated
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NestedStruct(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="@scope/jsii-calc-lib.submodule.ReflectableEntry",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "value": "value"},
)
class ReflectableEntry:
    def __init__(self, *, key: builtins.str, value: typing.Any) -> None:
        '''
        :param key: 
        :param value: 

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "value": value,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Any:
        '''
        :stability: deprecated
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ReflectableEntry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Reflector(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-lib.submodule.Reflector",
):
    '''
    :stability: deprecated
    '''

    def __init__(self) -> None:
        '''
        :stability: deprecated
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="asMap")
    def as_map(
        self,
        reflectable: IReflectable,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param reflectable: -

        :stability: deprecated
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "asMap", [reflectable]))


__all__ = [
    "IReflectable",
    "NestingClass",
    "ReflectableEntry",
    "Reflector",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/deprecation_removal/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.interface(jsii_type="@scope/jsii-calc-lib.deprecationRemoval.IInterface")
class IInterface(typing_extensions.Protocol):
    '''
    :stability: deprecated
    '''

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :stability: deprecated
        '''
        ...


class _IInterfaceProxy:
    '''
    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "@scope/jsii-calc-lib.deprecationRemoval.IInterface"

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterface).__jsii_proxy_class__ = lambda : _IInterfaceProxy


class InterfaceFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="@scope/jsii-calc-lib.deprecationRemoval.InterfaceFactory",
):
    '''
    :stability: deprecated
    '''

    @jsii.member(jsii_name="create")
    @builtins.classmethod
    def create(cls) -> IInterface:
        '''
        :stability: deprecated
        '''
        return typing.cast(IInterface, jsii.sinvoke(cls, "create", []))


__all__ = [
    "IInterface",
    "InterfaceFactory",
]

publication.publish()

`;

exports[`Generated code for "@scope/jsii-calc-lib": <outDir>/python/src/scope/jsii_calc_lib/py.typed 1`] = `


`;

exports[`Generated code for "@scope/jsii-calc-lib": <runtime-type-check-diff>/ 1`] = `
<runtime-type-check-diff>
 ‚îó‚îÅ üìÅ python
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ scope
          ‚îó‚îÅ üìÅ jsii_calc_lib
             ‚î£‚îÅ üìÑ __init__.py.diff
             ‚îó‚îÅ üìÅ custom_submodule_name
                ‚îó‚îÅ üìÑ __init__.py.diff
`;

exports[`Generated code for "@scope/jsii-calc-lib": <runtime-type-check-diff>/python/src/scope/jsii_calc_lib/__init__.py.diff 1`] = `
--- python/src/scope/jsii_calc_lib/__init__.py	--no-runtime-type-checking
+++ python/src/scope/jsii_calc_lib/__init__.py	--runtime-type-checking
@@ -34,19 +34,25 @@
         '''
         :param very: -
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__46512218b53da06690990919b41a88d6c2379b11ef0a3243cf6d60add5197ae2)
+            check_type(argname="argument very", value=very, expected_type=type_hints["very"])
         jsii.create(self.__class__, self, [very])
 
     @jsii.member(jsii_name="foo")
     def foo(self, obj: _scope_jsii_calc_base_734f0262.IBaseInterface) -> None:
         '''
         :param obj: -
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e721760a6f0cb2ba909986665323a1f1f880769c379ae1f2ad0dbadf80ee9016)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         return typing.cast(None, jsii.invoke(self, "foo", [obj]))
 
 
 @jsii.data_type(
     jsii_type="@scope/jsii-calc-lib.DiamondLeft",
@@ -64,10 +70,14 @@
         :param hoisted_top: 
         :param left: 
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__969bc4b33aa2d0684b20d440803d81dfda55aa9fa6398ac40f1afafc2114db5a)
+            check_type(argname="argument hoisted_top", value=hoisted_top, expected_type=type_hints["hoisted_top"])
+            check_type(argname="argument left", value=left, expected_type=type_hints["left"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if hoisted_top is not None:
             self._values["hoisted_top"] = hoisted_top
         if left is not None:
             self._values["left"] = left
@@ -116,10 +126,14 @@
         :param hoisted_top: 
         :param right: 
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__31f7eac552107efa0a4275f6798b003fcc3b6e74e0a463ae709af8b660b91dc4)
+            check_type(argname="argument hoisted_top", value=hoisted_top, expected_type=type_hints["hoisted_top"])
+            check_type(argname="argument right", value=right, expected_type=type_hints["right"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if hoisted_top is not None:
             self._values["hoisted_top"] = hoisted_top
         if right is not None:
             self._values["right"] = right
@@ -317,10 +331,15 @@
         :param astring: (deprecated) A string value.
         :param first_optional: 
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__de81edc65427ea9129fd035388008307a6cae942eefc63cb3d9fd8b42956da06)
+            check_type(argname="argument anumber", value=anumber, expected_type=type_hints["anumber"])
+            check_type(argname="argument astring", value=astring, expected_type=type_hints["astring"])
+            check_type(argname="argument first_optional", value=first_optional, expected_type=type_hints["first_optional"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "anumber": anumber,
             "astring": astring,
         }
         if first_optional is not None:
@@ -477,10 +496,15 @@
         :param optional2: 
         :param optional3: 
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__82b4e5e8f3b46996124a87aac13a874f61bf9660a45a062bafa08046c027da63)
+            check_type(argname="argument optional1", value=optional1, expected_type=type_hints["optional1"])
+            check_type(argname="argument optional2", value=optional2, expected_type=type_hints["optional2"])
+            check_type(argname="argument optional3", value=optional3, expected_type=type_hints["optional3"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if optional1 is not None:
             self._values["optional1"] = optional1
         if optional2 is not None:
             self._values["optional2"] = optional2
@@ -540,10 +564,13 @@
 
         :param value: The number.
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__adff4f4d0383c32ffdeb0bca92ae1ea2ebe0b2ea8d9bf5f5433287cc06e55e07)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.create(self.__class__, self, [value])
 
     @builtins.property
     @jsii.member(jsii_name="doubleValue")
     def double_value(self) -> jsii.Number:
@@ -583,5 +610,57 @@
 publication.publish()
 
 # Loading modules to ensure their types are registered with the jsii runtime library
 from . import custom_submodule_name
 from . import deprecation_removal
+
+def _typecheckingstub__46512218b53da06690990919b41a88d6c2379b11ef0a3243cf6d60add5197ae2(
+    very: _scope_jsii_calc_base_of_base_49fa37fe.Very,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e721760a6f0cb2ba909986665323a1f1f880769c379ae1f2ad0dbadf80ee9016(
+    obj: _scope_jsii_calc_base_734f0262.IBaseInterface,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__969bc4b33aa2d0684b20d440803d81dfda55aa9fa6398ac40f1afafc2114db5a(
+    *,
+    hoisted_top: typing.Optional[builtins.str] = None,
+    left: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__31f7eac552107efa0a4275f6798b003fcc3b6e74e0a463ae709af8b660b91dc4(
+    *,
+    hoisted_top: typing.Optional[builtins.str] = None,
+    right: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__de81edc65427ea9129fd035388008307a6cae942eefc63cb3d9fd8b42956da06(
+    *,
+    anumber: jsii.Number,
+    astring: builtins.str,
+    first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__82b4e5e8f3b46996124a87aac13a874f61bf9660a45a062bafa08046c027da63(
+    *,
+    optional1: typing.Optional[builtins.str] = None,
+    optional2: typing.Optional[jsii.Number] = None,
+    optional3: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__adff4f4d0383c32ffdeb0bca92ae1ea2ebe0b2ea8d9bf5f5433287cc06e55e07(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "@scope/jsii-calc-lib": <runtime-type-check-diff>/python/src/scope/jsii_calc_lib/custom_submodule_name/__init__.py.diff 1`] = `
--- python/src/scope/jsii_calc_lib/custom_submodule_name/__init__.py	--no-runtime-type-checking
+++ python/src/scope/jsii_calc_lib/custom_submodule_name/__init__.py	--runtime-type-checking
@@ -97,10 +97,13 @@
 
             :param name: 
 
             :stability: deprecated
             '''
+            if __debug__:
+                type_hints = typing.get_type_hints(_typecheckingstub__5c03ed6e0d395f6fa262d12c7831dd2893af2098bf580a0c602a20f92c1ad24b)
+                check_type(argname="argument name", value=name, expected_type=type_hints["name"])
             self._values: typing.Dict[builtins.str, typing.Any] = {
                 "name": name,
             }
 
         @builtins.property
@@ -135,10 +138,14 @@
         :param key: 
         :param value: 
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__301126f287c0bfbbd3cb015833c5e0b2ced77e73d25597215c917612b67c3331)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "key": key,
             "value": value,
         }
 
@@ -194,10 +201,13 @@
         '''
         :param reflectable: -
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bed3b5b08c611933987ef5d9dfc131289e09ebcd26286417337c3708ca054e9f)
+            check_type(argname="argument reflectable", value=reflectable, expected_type=type_hints["reflectable"])
         return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "asMap", [reflectable]))
 
 
 __all__ = [
     "IReflectable",
@@ -205,5 +215,26 @@
     "ReflectableEntry",
     "Reflector",
 ]
 
 publication.publish()
+
+def _typecheckingstub__5c03ed6e0d395f6fa262d12c7831dd2893af2098bf580a0c602a20f92c1ad24b(
+    *,
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__301126f287c0bfbbd3cb015833c5e0b2ced77e73d25597215c917612b67c3331(
+    *,
+    key: builtins.str,
+    value: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__bed3b5b08c611933987ef5d9dfc131289e09ebcd26286417337c3708ca054e9f(
+    reflectable: IReflectable,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <outDir>/ 1`] = `
<root>
 ‚îó‚îÅ üìÅ python
    ‚î£‚îÅ üìÑ LICENSE
    ‚î£‚îÅ üìÑ MANIFEST.in
    ‚î£‚îÅ üìÑ NOTICE
    ‚î£‚îÅ üìÑ pyproject.toml
    ‚î£‚îÅ üìÑ README.md
    ‚î£‚îÅ üìÑ setup.py
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ jsii_calc
          ‚î£‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ _jsii
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ bin
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ calc
          ‚îÉ  ‚îó‚îÅ üìÑ jsii-calc@3.20.120.jsii.tgz
          ‚î£‚îÅ üìÅ anonymous
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ cdk16625
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ donotimport
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ cdk22369
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ composition
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ derived_class_has_no_properties
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ homonymous_forward_references
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ bar
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ foo
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ interface_in_namespace_includes_classes
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ interface_in_namespace_only_interface
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ jsii3656
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2530
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2617
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2647
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2689
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ methods
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ props
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ retval
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ structs
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2692
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ submodule1
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ submodule2
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2700
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ module2702
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ nodirect
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ sub1
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ sub2
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ onlystatic
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÑ py.typed
          ‚î£‚îÅ üìÅ python_self
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚î£‚îÅ üìÅ submodule
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ back_references
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ child
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ isolated
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ nested_submodule
          ‚îÉ  ‚îÉ  ‚î£‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÅ deeply_nested
          ‚îÉ  ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚î£‚îÅ üìÅ param
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py
          ‚îÉ  ‚îó‚îÅ üìÅ returnsparam
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py
          ‚îó‚îÅ üìÅ union
             ‚îó‚îÅ üìÑ __init__.py
`;

exports[`Generated code for "jsii-calc": <outDir>/python/LICENSE 1`] = `

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
`;

exports[`Generated code for "jsii-calc": <outDir>/python/MANIFEST.in 1`] = `
include pyproject.toml

`;

exports[`Generated code for "jsii-calc": <outDir>/python/NOTICE 1`] = `
jsii
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

`;

exports[`Generated code for "jsii-calc": <outDir>/python/README.md 1`] = `
# jsii Calculator

This library is used to demonstrate and test the features of JSII

## How to use running sum API:

First, create a calculator:

\`\`\`python
calculator = calc.Calculator()
\`\`\`

Then call some operations:

\`\`\`python
calculator.add(10)
\`\`\`

## Code Samples

\`\`\`python
# This is totes a magic comment in here, just you wait!
foo = "bar"
\`\`\`

`;

exports[`Generated code for "jsii-calc": <outDir>/python/pyproject.toml 1`] = `
[build-system]
requires = ["setuptools~=67.3.2", "wheel~=0.38"]
build-backend = "setuptools.build_meta"

[tool.pyright]
defineConstant = { DEBUG = true }
pythonVersion = "3.7"
pythonPlatform = "All"
reportSelfClsParameterName = false

`;

exports[`Generated code for "jsii-calc": <outDir>/python/setup.py 1`] = `
import json
import setuptools

kwargs = json.loads(
    """
{
    "name": "jsii-calc",
    "version": "3.20.120",
    "description": "A simple calcuator built on JSII.",
    "license": "Apache-2.0",
    "url": "https://github.com/aws/jsii",
    "long_description_content_type": "text/markdown",
    "author": "Amazon Web Services",
    "bdist_wheel": {
        "universal": true
    },
    "project_urls": {
        "Source": "https://github.com/aws/jsii.git"
    },
    "package_dir": {
        "": "src"
    },
    "packages": [
        "jsii_calc",
        "jsii_calc._jsii",
        "jsii_calc.anonymous",
        "jsii_calc.cdk16625",
        "jsii_calc.cdk16625.donotimport",
        "jsii_calc.cdk22369",
        "jsii_calc.composition",
        "jsii_calc.derived_class_has_no_properties",
        "jsii_calc.homonymous_forward_references",
        "jsii_calc.homonymous_forward_references.bar",
        "jsii_calc.homonymous_forward_references.foo",
        "jsii_calc.interface_in_namespace_includes_classes",
        "jsii_calc.interface_in_namespace_only_interface",
        "jsii_calc.jsii3656",
        "jsii_calc.module2530",
        "jsii_calc.module2617",
        "jsii_calc.module2647",
        "jsii_calc.module2689",
        "jsii_calc.module2689.methods",
        "jsii_calc.module2689.props",
        "jsii_calc.module2689.retval",
        "jsii_calc.module2689.structs",
        "jsii_calc.module2692",
        "jsii_calc.module2692.submodule1",
        "jsii_calc.module2692.submodule2",
        "jsii_calc.module2700",
        "jsii_calc.module2702",
        "jsii_calc.nodirect",
        "jsii_calc.nodirect.sub1",
        "jsii_calc.nodirect.sub2",
        "jsii_calc.onlystatic",
        "jsii_calc.python_self",
        "jsii_calc.submodule",
        "jsii_calc.submodule.back_references",
        "jsii_calc.submodule.child",
        "jsii_calc.submodule.isolated",
        "jsii_calc.submodule.nested_submodule",
        "jsii_calc.submodule.nested_submodule.deeply_nested",
        "jsii_calc.submodule.param",
        "jsii_calc.submodule.returnsparam",
        "jsii_calc.union"
    ],
    "package_data": {
        "jsii_calc._jsii": [
            "jsii-calc@3.20.120.jsii.tgz"
        ],
        "jsii_calc": [
            "py.typed"
        ]
    },
    "python_requires": "~=3.7",
    "install_requires": [
        "jsii<0.0.1",
        "publication>=0.0.3",
        "scope.jsii-calc-base<0.0.1",
        "scope.jsii-calc-lib<0.0.1",
        "typeguard~=2.13.3"
    ],
    "classifiers": [
        "Intended Audience :: Developers",
        "Operating System :: OS Independent",
        "Programming Language :: JavaScript",
        "Programming Language :: Python :: 3 :: Only",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Typing :: Typed",
        "Development Status :: 5 - Production/Stable",
        "License :: OSI Approved",
        "Test :: Classifier :: Is Dummy"
    ],
    "scripts": [
        "src/jsii_calc/_jsii/bin/calc"
    ]
}
"""
)

with open("README.md", encoding="utf8") as fp:
    kwargs["long_description"] = fp.read()


setuptools.setup(**kwargs)

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/__init__.py 1`] = `
'''
# jsii Calculator

This library is used to demonstrate and test the features of JSII

## How to use running sum API:

First, create a calculator:

\`\`\`python
calculator = calc.Calculator()
\`\`\`

Then call some operations:

\`\`\`python
calculator.add(10)
\`\`\`

## Code Samples

\`\`\`python
# This is totes a magic comment in here, just you wait!
foo = "bar"
\`\`\`
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_base_of_base as _scope_jsii_calc_base_of_base_49fa37fe
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f
import scope.jsii_calc_lib.custom_submodule_name as _scope_jsii_calc_lib_custom_submodule_name_c61f082f
from .composition import CompositeOperation as _CompositeOperation_1c4d123b


class AbstractClassBase(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.AbstractClassBase",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="abstractProperty")
    @abc.abstractmethod
    def abstract_property(self) -> builtins.str:
        ...


class _AbstractClassBaseProxy(AbstractClassBase):
    @builtins.property
    @jsii.member(jsii_name="abstractProperty")
    def abstract_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "abstractProperty"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AbstractClassBase).__jsii_proxy_class__ = lambda : _AbstractClassBaseProxy


class AbstractClassReturner(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.AbstractClassReturner",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="giveMeAbstract")
    def give_me_abstract(self) -> "AbstractClass":
        return typing.cast("AbstractClass", jsii.invoke(self, "giveMeAbstract", []))

    @jsii.member(jsii_name="giveMeInterface")
    def give_me_interface(self) -> "IInterfaceImplementedByAbstractClass":
        return typing.cast("IInterfaceImplementedByAbstractClass", jsii.invoke(self, "giveMeInterface", []))

    @builtins.property
    @jsii.member(jsii_name="returnAbstractFromProperty")
    def return_abstract_from_property(self) -> AbstractClassBase:
        return typing.cast(AbstractClassBase, jsii.get(self, "returnAbstractFromProperty"))


class AbstractSuite(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.AbstractSuite",
):
    '''Ensures abstract members implementations correctly register overrides in various languages.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="someMethod")
    @abc.abstractmethod
    def _some_method(self, str: builtins.str) -> builtins.str:
        '''
        :param str: -
        '''
        ...

    @jsii.member(jsii_name="workItAll")
    def work_it_all(self, seed: builtins.str) -> builtins.str:
        '''Sets \`\`seed\`\` to \`\`this.property\`\`, then calls \`\`someMethod\`\` with \`\`this.property\`\` and returns the result.

        :param seed: a \`\`string\`\`.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "workItAll", [seed]))

    @builtins.property
    @jsii.member(jsii_name="property")
    @abc.abstractmethod
    def _property(self) -> builtins.str:
        ...

    @_property.setter
    @abc.abstractmethod
    def _property(self, value: builtins.str) -> None:
        ...


class _AbstractSuiteProxy(AbstractSuite):
    @jsii.member(jsii_name="someMethod")
    def _some_method(self, str: builtins.str) -> builtins.str:
        '''
        :param str: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "someMethod", [str]))

    @builtins.property
    @jsii.member(jsii_name="property")
    def _property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))

    @_property.setter
    def _property(self, value: builtins.str) -> None:
        jsii.set(self, "property", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AbstractSuite).__jsii_proxy_class__ = lambda : _AbstractSuiteProxy


class AllTypes(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.AllTypes"):
    '''This class includes property for all types supported by jsii.

    The setters will validate
    that the value set is of the expected type and throw otherwise.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="anyIn")
    def any_in(self, inp: typing.Any) -> None:
        '''
        :param inp: -
        '''
        return typing.cast(None, jsii.invoke(self, "anyIn", [inp]))

    @jsii.member(jsii_name="anyOut")
    def any_out(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.invoke(self, "anyOut", []))

    @jsii.member(jsii_name="enumMethod")
    def enum_method(self, value: "StringEnum") -> "StringEnum":
        '''
        :param value: -
        '''
        return typing.cast("StringEnum", jsii.invoke(self, "enumMethod", [value]))

    @builtins.property
    @jsii.member(jsii_name="enumPropertyValue")
    def enum_property_value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "enumPropertyValue"))

    @builtins.property
    @jsii.member(jsii_name="anyArrayProperty")
    def any_array_property(self) -> typing.List[typing.Any]:
        return typing.cast(typing.List[typing.Any], jsii.get(self, "anyArrayProperty"))

    @any_array_property.setter
    def any_array_property(self, value: typing.List[typing.Any]) -> None:
        jsii.set(self, "anyArrayProperty", value)

    @builtins.property
    @jsii.member(jsii_name="anyMapProperty")
    def any_map_property(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "anyMapProperty"))

    @any_map_property.setter
    def any_map_property(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        jsii.set(self, "anyMapProperty", value)

    @builtins.property
    @jsii.member(jsii_name="anyProperty")
    def any_property(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "anyProperty"))

    @any_property.setter
    def any_property(self, value: typing.Any) -> None:
        jsii.set(self, "anyProperty", value)

    @builtins.property
    @jsii.member(jsii_name="arrayProperty")
    def array_property(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "arrayProperty"))

    @array_property.setter
    def array_property(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "arrayProperty", value)

    @builtins.property
    @jsii.member(jsii_name="booleanProperty")
    def boolean_property(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "booleanProperty"))

    @boolean_property.setter
    def boolean_property(self, value: builtins.bool) -> None:
        jsii.set(self, "booleanProperty", value)

    @builtins.property
    @jsii.member(jsii_name="dateProperty")
    def date_property(self) -> datetime.datetime:
        return typing.cast(datetime.datetime, jsii.get(self, "dateProperty"))

    @date_property.setter
    def date_property(self, value: datetime.datetime) -> None:
        jsii.set(self, "dateProperty", value)

    @builtins.property
    @jsii.member(jsii_name="enumProperty")
    def enum_property(self) -> "AllTypesEnum":
        return typing.cast("AllTypesEnum", jsii.get(self, "enumProperty"))

    @enum_property.setter
    def enum_property(self, value: "AllTypesEnum") -> None:
        jsii.set(self, "enumProperty", value)

    @builtins.property
    @jsii.member(jsii_name="jsonProperty")
    def json_property(self) -> typing.Mapping[typing.Any, typing.Any]:
        return typing.cast(typing.Mapping[typing.Any, typing.Any], jsii.get(self, "jsonProperty"))

    @json_property.setter
    def json_property(self, value: typing.Mapping[typing.Any, typing.Any]) -> None:
        jsii.set(self, "jsonProperty", value)

    @builtins.property
    @jsii.member(jsii_name="mapProperty")
    def map_property(
        self,
    ) -> typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.Number]:
        return typing.cast(typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.Number], jsii.get(self, "mapProperty"))

    @map_property.setter
    def map_property(
        self,
        value: typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.Number],
    ) -> None:
        jsii.set(self, "mapProperty", value)

    @builtins.property
    @jsii.member(jsii_name="numberProperty")
    def number_property(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "numberProperty"))

    @number_property.setter
    def number_property(self, value: jsii.Number) -> None:
        jsii.set(self, "numberProperty", value)

    @builtins.property
    @jsii.member(jsii_name="stringProperty")
    def string_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "stringProperty"))

    @string_property.setter
    def string_property(self, value: builtins.str) -> None:
        jsii.set(self, "stringProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unionArrayProperty")
    def union_array_property(
        self,
    ) -> typing.List[typing.Union[jsii.Number, _scope_jsii_calc_lib_c61f082f.NumericValue]]:
        return typing.cast(typing.List[typing.Union[jsii.Number, _scope_jsii_calc_lib_c61f082f.NumericValue]], jsii.get(self, "unionArrayProperty"))

    @union_array_property.setter
    def union_array_property(
        self,
        value: typing.List[typing.Union[jsii.Number, _scope_jsii_calc_lib_c61f082f.NumericValue]],
    ) -> None:
        jsii.set(self, "unionArrayProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unionMapProperty")
    def union_map_property(
        self,
    ) -> typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number]]:
        return typing.cast(typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number]], jsii.get(self, "unionMapProperty"))

    @union_map_property.setter
    def union_map_property(
        self,
        value: typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number]],
    ) -> None:
        jsii.set(self, "unionMapProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unionProperty")
    def union_property(
        self,
    ) -> typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number, "Multiply"]:
        return typing.cast(typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number, "Multiply"], jsii.get(self, "unionProperty"))

    @union_property.setter
    def union_property(
        self,
        value: typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number, "Multiply"],
    ) -> None:
        jsii.set(self, "unionProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unknownArrayProperty")
    def unknown_array_property(self) -> typing.List[typing.Any]:
        return typing.cast(typing.List[typing.Any], jsii.get(self, "unknownArrayProperty"))

    @unknown_array_property.setter
    def unknown_array_property(self, value: typing.List[typing.Any]) -> None:
        jsii.set(self, "unknownArrayProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unknownMapProperty")
    def unknown_map_property(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "unknownMapProperty"))

    @unknown_map_property.setter
    def unknown_map_property(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        jsii.set(self, "unknownMapProperty", value)

    @builtins.property
    @jsii.member(jsii_name="unknownProperty")
    def unknown_property(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.get(self, "unknownProperty"))

    @unknown_property.setter
    def unknown_property(self, value: typing.Any) -> None:
        jsii.set(self, "unknownProperty", value)

    @builtins.property
    @jsii.member(jsii_name="optionalEnumValue")
    def optional_enum_value(self) -> typing.Optional["StringEnum"]:
        return typing.cast(typing.Optional["StringEnum"], jsii.get(self, "optionalEnumValue"))

    @optional_enum_value.setter
    def optional_enum_value(self, value: typing.Optional["StringEnum"]) -> None:
        jsii.set(self, "optionalEnumValue", value)


@jsii.enum(jsii_type="jsii-calc.AllTypesEnum")
class AllTypesEnum(enum.Enum):
    MY_ENUM_VALUE = "MY_ENUM_VALUE"
    YOUR_ENUM_VALUE = "YOUR_ENUM_VALUE"
    THIS_IS_GREAT = "THIS_IS_GREAT"


class AllowedMethodNames(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.AllowedMethodNames",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="getBar")
    def get_bar(self, _p1: builtins.str, _p2: jsii.Number) -> None:
        '''
        :param _p1: -
        :param _p2: -
        '''
        return typing.cast(None, jsii.invoke(self, "getBar", [_p1, _p2]))

    @jsii.member(jsii_name="getFoo")
    def get_foo(self, with_param: builtins.str) -> builtins.str:
        '''getXxx() is not allowed (see negatives), but getXxx(a, ...) is okay.

        :param with_param: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "getFoo", [with_param]))

    @jsii.member(jsii_name="setBar")
    def set_bar(self, _x: builtins.str, _y: jsii.Number, _z: builtins.bool) -> None:
        '''
        :param _x: -
        :param _y: -
        :param _z: -
        '''
        return typing.cast(None, jsii.invoke(self, "setBar", [_x, _y, _z]))

    @jsii.member(jsii_name="setFoo")
    def set_foo(self, _x: builtins.str, _y: jsii.Number) -> None:
        '''setFoo(x) is not allowed (see negatives), but setXxx(a, b, ...) is okay.

        :param _x: -
        :param _y: -
        '''
        return typing.cast(None, jsii.invoke(self, "setFoo", [_x, _y]))


class AmbiguousParameters(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.AmbiguousParameters",
):
    def __init__(
        self,
        scope_: "Bell",
        *,
        scope: builtins.str,
        props: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope_: -
        :param scope: 
        :param props: 
        '''
        props_ = StructParameterType(scope=scope, props=props)

        jsii.create(self.__class__, self, [scope_, props_])

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "StructParameterType":
        return typing.cast("StructParameterType", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="scope")
    def scope(self) -> "Bell":
        return typing.cast("Bell", jsii.get(self, "scope"))


class AsyncVirtualMethods(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.AsyncVirtualMethods",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="callMe")
    def call_me(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.ainvoke(self, "callMe", []))

    @jsii.member(jsii_name="callMe2")
    def call_me2(self) -> jsii.Number:
        '''Just calls "overrideMeToo".'''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "callMe2", []))

    @jsii.member(jsii_name="callMeDoublePromise")
    def call_me_double_promise(self) -> jsii.Number:
        '''This method calls the "callMe" async method indirectly, which will then invoke a virtual method.

        This is a "double promise" situation, which
        means that callbacks are not going to be available immediate, but only
        after an "immediates" cycle.
        '''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "callMeDoublePromise", []))

    @jsii.member(jsii_name="dontOverrideMe")
    def dont_override_me(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "dontOverrideMe", []))

    @jsii.member(jsii_name="overrideMe")
    def override_me(self, mult: jsii.Number) -> jsii.Number:
        '''
        :param mult: -
        '''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMe", [mult]))

    @jsii.member(jsii_name="overrideMeToo")
    def override_me_too(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMeToo", []))


class AugmentableClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.AugmentableClass"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="methodOne")
    def method_one(self) -> None:
        return typing.cast(None, jsii.invoke(self, "methodOne", []))

    @jsii.member(jsii_name="methodTwo")
    def method_two(self) -> None:
        return typing.cast(None, jsii.invoke(self, "methodTwo", []))


class BaseClass(metaclass=jsii.JSIIAbstractClass, jsii_type="jsii-calc.BaseClass"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="method")
    def method(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "method", []))

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))


class _BaseClassProxy(BaseClass):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, BaseClass).__jsii_proxy_class__ = lambda : _BaseClassProxy


class BaseJsii976(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.BaseJsii976"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


@jsii.implements(_scope_jsii_calc_lib_c61f082f.IFriendly)
class BinaryOperation(
    _scope_jsii_calc_lib_c61f082f.Operation,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.BinaryOperation",
):
    '''Represents an operation with two operands.'''

    def __init__(
        self,
        lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
        rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
    ) -> None:
        '''Creates a BinaryOperation.

        :param lhs: Left-hand side operand.
        :param rhs: Right-hand side operand.
        '''
        jsii.create(self.__class__, self, [lhs, rhs])

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''Say hello!'''
        return typing.cast(builtins.str, jsii.invoke(self, "hello", []))

    @builtins.property
    @jsii.member(jsii_name="lhs")
    def lhs(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''Left-hand side operand.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "lhs"))

    @builtins.property
    @jsii.member(jsii_name="rhs")
    def rhs(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''Right-hand side operand.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "rhs"))


class _BinaryOperationProxy(
    BinaryOperation,
    jsii.proxy_for(_scope_jsii_calc_lib_c61f082f.Operation), # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, BinaryOperation).__jsii_proxy_class__ = lambda : _BinaryOperationProxy


class BurriedAnonymousObject(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.BurriedAnonymousObject",
):
    '''See https://github.com/aws/aws-cdk/issues/7977.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="check")
    def check(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.invoke(self, "check", []))

    @jsii.member(jsii_name="giveItBack")
    @abc.abstractmethod
    def give_it_back(self, value: typing.Any) -> typing.Any:
        '''Implement this method and have it return it's parameter.

        :param value: the value that should be returned.

        :return: \`\`value\`\`
        '''
        ...


class _BurriedAnonymousObjectProxy(BurriedAnonymousObject):
    @jsii.member(jsii_name="giveItBack")
    def give_it_back(self, value: typing.Any) -> typing.Any:
        '''Implement this method and have it return it's parameter.

        :param value: the value that should be returned.

        :return: \`\`value\`\`
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "giveItBack", [value]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, BurriedAnonymousObject).__jsii_proxy_class__ = lambda : _BurriedAnonymousObjectProxy


class Calculator(
    _CompositeOperation_1c4d123b,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.Calculator",
):
    '''A calculator which maintains a current value and allows adding operations.

    Here's how you use it::

       calculator = calc.Calculator()
       calculator.add(5)
       calculator.mul(3)
       print(calculator.expression.value)

    I will repeat this example again, but in an @example tag.

    Example::

        calculator = calc.Calculator()
        calculator.add(5)
        calculator.mul(3)
        print(calculator.expression.value)
    '''

    def __init__(
        self,
        *,
        initial_value: typing.Optional[jsii.Number] = None,
        maximum_value: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Creates a Calculator object.

        :param initial_value: The initial value of the calculator. NOTE: Any number works here, it's fine. Default: 0
        :param maximum_value: The maximum value the calculator can store. Default: none
        '''
        props = CalculatorProps(
            initial_value=initial_value, maximum_value=maximum_value
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="add")
    def add(self, value: jsii.Number) -> None:
        '''Adds a number to the current value.

        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "add", [value]))

    @jsii.member(jsii_name="mul")
    def mul(self, value: jsii.Number) -> None:
        '''Multiplies the current value by a number.

        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "mul", [value]))

    @jsii.member(jsii_name="neg")
    def neg(self) -> None:
        '''Negates the current value.'''
        return typing.cast(None, jsii.invoke(self, "neg", []))

    @jsii.member(jsii_name="pow")
    def pow(self, value: jsii.Number) -> None:
        '''Raises the current value by a power.

        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "pow", [value]))

    @jsii.member(jsii_name="readUnionValue")
    def read_union_value(self) -> jsii.Number:
        '''Returns teh value of the union property (if defined).'''
        return typing.cast(jsii.Number, jsii.invoke(self, "readUnionValue", []))

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''Returns the expression.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "expression"))

    @builtins.property
    @jsii.member(jsii_name="operationsLog")
    def operations_log(self) -> typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue]:
        '''A log of all operations.'''
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue], jsii.get(self, "operationsLog"))

    @builtins.property
    @jsii.member(jsii_name="operationsMap")
    def operations_map(
        self,
    ) -> typing.Mapping[builtins.str, typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue]]:
        '''A map of per operation name of all operations performed.'''
        return typing.cast(typing.Mapping[builtins.str, typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue]], jsii.get(self, "operationsMap"))

    @builtins.property
    @jsii.member(jsii_name="curr")
    def curr(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The current value.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "curr"))

    @curr.setter
    def curr(self, value: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
        jsii.set(self, "curr", value)

    @builtins.property
    @jsii.member(jsii_name="maxValue")
    def max_value(self) -> typing.Optional[jsii.Number]:
        '''The maximum value allows in this calculator.'''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxValue"))

    @max_value.setter
    def max_value(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "maxValue", value)

    @builtins.property
    @jsii.member(jsii_name="unionProperty")
    def union_property(
        self,
    ) -> typing.Optional[typing.Union["Add", "Multiply", "Power"]]:
        '''Example of a property that accepts a union of types.'''
        return typing.cast(typing.Optional[typing.Union["Add", "Multiply", "Power"]], jsii.get(self, "unionProperty"))

    @union_property.setter
    def union_property(
        self,
        value: typing.Optional[typing.Union["Add", "Multiply", "Power"]],
    ) -> None:
        jsii.set(self, "unionProperty", value)


@jsii.data_type(
    jsii_type="jsii-calc.CalculatorProps",
    jsii_struct_bases=[],
    name_mapping={"initial_value": "initialValue", "maximum_value": "maximumValue"},
)
class CalculatorProps:
    def __init__(
        self,
        *,
        initial_value: typing.Optional[jsii.Number] = None,
        maximum_value: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for Calculator.

        :param initial_value: The initial value of the calculator. NOTE: Any number works here, it's fine. Default: 0
        :param maximum_value: The maximum value the calculator can store. Default: none
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if initial_value is not None:
            self._values["initial_value"] = initial_value
        if maximum_value is not None:
            self._values["maximum_value"] = maximum_value

    @builtins.property
    def initial_value(self) -> typing.Optional[jsii.Number]:
        '''The initial value of the calculator.

        NOTE: Any number works here, it's fine.

        :default: 0
        '''
        result = self._values.get("initial_value")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def maximum_value(self) -> typing.Optional[jsii.Number]:
        '''The maximum value the calculator can store.

        :default: none
        '''
        result = self._values.get("maximum_value")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CalculatorProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClassWithCollectionOfUnions(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithCollectionOfUnions",
):
    def __init__(
        self,
        union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''
        :param union_property: -
        '''
        jsii.create(self.__class__, self, [union_property])

    @builtins.property
    @jsii.member(jsii_name="unionProperty")
    def union_property(
        self,
    ) -> typing.List[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]]]:
        return typing.cast(typing.List[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]]], jsii.get(self, "unionProperty"))

    @union_property.setter
    def union_property(
        self,
        value: typing.List[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]]],
    ) -> None:
        jsii.set(self, "unionProperty", value)


class ClassWithCollections(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithCollections",
):
    def __init__(
        self,
        map: typing.Mapping[builtins.str, builtins.str],
        array: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param map: -
        :param array: -
        '''
        jsii.create(self.__class__, self, [map, array])

    @jsii.member(jsii_name="createAList")
    @builtins.classmethod
    def create_a_list(cls) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.sinvoke(cls, "createAList", []))

    @jsii.member(jsii_name="createAMap")
    @builtins.classmethod
    def create_a_map(cls) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.sinvoke(cls, "createAMap", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="staticArray")
    def static_array(cls) -> typing.List[builtins.str]:  # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(typing.List[builtins.str], jsii.sget(cls, "staticArray"))

    @static_array.setter # type: ignore[no-redef]
    def static_array(cls, value: typing.List[builtins.str]) -> None:
        jsii.sset(cls, "staticArray", value)

    @jsii.python.classproperty
    @jsii.member(jsii_name="staticMap")
    def static_map(cls) -> typing.Mapping[builtins.str, builtins.str]:  # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.sget(cls, "staticMap"))

    @static_map.setter # type: ignore[no-redef]
    def static_map(cls, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        jsii.sset(cls, "staticMap", value)

    @builtins.property
    @jsii.member(jsii_name="array")
    def array(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "array"))

    @array.setter
    def array(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "array", value)

    @builtins.property
    @jsii.member(jsii_name="map")
    def map(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "map"))

    @map.setter
    def map(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        jsii.set(self, "map", value)


class ClassWithContainerTypes(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithContainerTypes",
):
    def __init__(
        self,
        array: typing.Sequence[typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        record: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        obj: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        *,
        array_prop: typing.Sequence[typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        obj_prop: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        record_prop: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''
        :param array: -
        :param record: -
        :param obj: -
        :param array_prop: 
        :param obj_prop: 
        :param record_prop: 
        '''
        props = ContainerProps(
            array_prop=array_prop, obj_prop=obj_prop, record_prop=record_prop
        )

        jsii.create(self.__class__, self, [array, record, obj, props])

    @builtins.property
    @jsii.member(jsii_name="array")
    def array(self) -> typing.List["DummyObj"]:
        return typing.cast(typing.List["DummyObj"], jsii.get(self, "array"))

    @builtins.property
    @jsii.member(jsii_name="obj")
    def obj(self) -> typing.Mapping[builtins.str, "DummyObj"]:
        return typing.cast(typing.Mapping[builtins.str, "DummyObj"], jsii.get(self, "obj"))

    @builtins.property
    @jsii.member(jsii_name="record")
    def record(self) -> typing.Mapping[builtins.str, "DummyObj"]:
        return typing.cast(typing.Mapping[builtins.str, "DummyObj"], jsii.get(self, "record"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> typing.Optional["ContainerProps"]:
        return typing.cast(typing.Optional["ContainerProps"], jsii.get(self, "props"))


class ClassWithDocs(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.ClassWithDocs"):
    '''This class has docs.

    The docs are great. They're a bunch of tags.

    :see: https://aws.amazon.com/
    :customAttribute: hasAValue

    Example::

        def an_example():
            pass
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


class ClassWithJavaReservedWords(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithJavaReservedWords",
):
    def __init__(self, int: builtins.str) -> None:
        '''
        :param int: -
        '''
        jsii.create(self.__class__, self, [int])

    @jsii.member(jsii_name="import")
    def import_(self, assert_: builtins.str) -> builtins.str:
        '''
        :param assert_: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "import", [assert_]))

    @builtins.property
    @jsii.member(jsii_name="int")
    def int(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "int"))


class ClassWithMutableObjectLiteralProperty(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithMutableObjectLiteralProperty",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="mutableObject")
    def mutable_object(self) -> "IMutableObjectLiteral":
        return typing.cast("IMutableObjectLiteral", jsii.get(self, "mutableObject"))

    @mutable_object.setter
    def mutable_object(self, value: "IMutableObjectLiteral") -> None:
        jsii.set(self, "mutableObject", value)


class ClassWithNestedUnion(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithNestedUnion",
):
    def __init__(
        self,
        union_property: typing.Sequence[typing.Union[typing.Mapping[builtins.str, typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]], typing.Sequence[typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]]]],
    ) -> None:
        '''
        :param union_property: -
        '''
        jsii.create(self.__class__, self, [union_property])

    @builtins.property
    @jsii.member(jsii_name="unionProperty")
    def union_property(
        self,
    ) -> typing.List[typing.Union[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]], typing.List[typing.Union["StructA", "StructB"]]]]:
        return typing.cast(typing.List[typing.Union[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]], typing.List[typing.Union["StructA", "StructB"]]]], jsii.get(self, "unionProperty"))

    @union_property.setter
    def union_property(
        self,
        value: typing.List[typing.Union[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]], typing.List[typing.Union["StructA", "StructB"]]]],
    ) -> None:
        jsii.set(self, "unionProperty", value)


class ConfusingToJackson(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ConfusingToJackson",
):
    '''This tries to confuse Jackson by having overloaded property setters.

    :see: https://github.com/aws/aws-cdk/issues/4080
    '''

    @jsii.member(jsii_name="makeInstance")
    @builtins.classmethod
    def make_instance(cls) -> "ConfusingToJackson":
        return typing.cast("ConfusingToJackson", jsii.sinvoke(cls, "makeInstance", []))

    @jsii.member(jsii_name="makeStructInstance")
    @builtins.classmethod
    def make_struct_instance(cls) -> "ConfusingToJacksonStruct":
        return typing.cast("ConfusingToJacksonStruct", jsii.sinvoke(cls, "makeStructInstance", []))

    @builtins.property
    @jsii.member(jsii_name="unionProperty")
    def union_property(
        self,
    ) -> typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]]:
        return typing.cast(typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]], jsii.get(self, "unionProperty"))

    @union_property.setter
    def union_property(
        self,
        value: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]],
    ) -> None:
        jsii.set(self, "unionProperty", value)


@jsii.data_type(
    jsii_type="jsii-calc.ConfusingToJacksonStruct",
    jsii_struct_bases=[],
    name_mapping={"union_property": "unionProperty"},
)
class ConfusingToJacksonStruct:
    def __init__(
        self,
        *,
        union_property: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.Sequence[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]] = None,
    ) -> None:
        '''
        :param union_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if union_property is not None:
            self._values["union_property"] = union_property

    @builtins.property
    def union_property(
        self,
    ) -> typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]]:
        result = self._values.get("union_property")
        return typing.cast(typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConfusingToJacksonStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ConstructorPassesThisOut(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ConstructorPassesThisOut",
):
    def __init__(self, consumer: "PartiallyInitializedThisConsumer") -> None:
        '''
        :param consumer: -
        '''
        jsii.create(self.__class__, self, [consumer])


class Constructors(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Constructors"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="hiddenInterface")
    @builtins.classmethod
    def hidden_interface(cls) -> "IPublicInterface":
        return typing.cast("IPublicInterface", jsii.sinvoke(cls, "hiddenInterface", []))

    @jsii.member(jsii_name="hiddenInterfaces")
    @builtins.classmethod
    def hidden_interfaces(cls) -> typing.List["IPublicInterface"]:
        return typing.cast(typing.List["IPublicInterface"], jsii.sinvoke(cls, "hiddenInterfaces", []))

    @jsii.member(jsii_name="hiddenSubInterfaces")
    @builtins.classmethod
    def hidden_sub_interfaces(cls) -> typing.List["IPublicInterface"]:
        return typing.cast(typing.List["IPublicInterface"], jsii.sinvoke(cls, "hiddenSubInterfaces", []))

    @jsii.member(jsii_name="makeClass")
    @builtins.classmethod
    def make_class(cls) -> "PublicClass":
        return typing.cast("PublicClass", jsii.sinvoke(cls, "makeClass", []))

    @jsii.member(jsii_name="makeInterface")
    @builtins.classmethod
    def make_interface(cls) -> "IPublicInterface":
        return typing.cast("IPublicInterface", jsii.sinvoke(cls, "makeInterface", []))

    @jsii.member(jsii_name="makeInterface2")
    @builtins.classmethod
    def make_interface2(cls) -> "IPublicInterface2":
        return typing.cast("IPublicInterface2", jsii.sinvoke(cls, "makeInterface2", []))

    @jsii.member(jsii_name="makeInterfaces")
    @builtins.classmethod
    def make_interfaces(cls) -> typing.List["IPublicInterface"]:
        return typing.cast(typing.List["IPublicInterface"], jsii.sinvoke(cls, "makeInterfaces", []))


class ConsumePureInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ConsumePureInterface",
):
    def __init__(self, delegate: "IStructReturningDelegate") -> None:
        '''
        :param delegate: -
        '''
        jsii.create(self.__class__, self, [delegate])

    @jsii.member(jsii_name="workItBaby")
    def work_it_baby(self) -> "StructB":
        return typing.cast("StructB", jsii.invoke(self, "workItBaby", []))


class ConsumerCanRingBell(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ConsumerCanRingBell",
):
    '''Test calling back to consumers that implement interfaces.

    Check that if a JSII consumer implements IConsumerWithInterfaceParam, they can call
    the method on the argument that they're passed...
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="staticImplementedByObjectLiteral")
    @builtins.classmethod
    def static_implemented_by_object_literal(
        cls,
        ringer: "IBellRinger",
    ) -> builtins.bool:
        '''...if the interface is implemented using an object literal.

        Returns whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByObjectLiteral", [ringer]))

    @jsii.member(jsii_name="staticImplementedByPrivateClass")
    @builtins.classmethod
    def static_implemented_by_private_class(
        cls,
        ringer: "IBellRinger",
    ) -> builtins.bool:
        '''...if the interface is implemented using a private class.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByPrivateClass", [ringer]))

    @jsii.member(jsii_name="staticImplementedByPublicClass")
    @builtins.classmethod
    def static_implemented_by_public_class(cls, ringer: "IBellRinger") -> builtins.bool:
        '''...if the interface is implemented using a public class.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByPublicClass", [ringer]))

    @jsii.member(jsii_name="staticWhenTypedAsClass")
    @builtins.classmethod
    def static_when_typed_as_class(cls, ringer: "IConcreteBellRinger") -> builtins.bool:
        '''If the parameter is a concrete class instead of an interface.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticWhenTypedAsClass", [ringer]))

    @jsii.member(jsii_name="implementedByObjectLiteral")
    def implemented_by_object_literal(self, ringer: "IBellRinger") -> builtins.bool:
        '''...if the interface is implemented using an object literal.

        Returns whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "implementedByObjectLiteral", [ringer]))

    @jsii.member(jsii_name="implementedByPrivateClass")
    def implemented_by_private_class(self, ringer: "IBellRinger") -> builtins.bool:
        '''...if the interface is implemented using a private class.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "implementedByPrivateClass", [ringer]))

    @jsii.member(jsii_name="implementedByPublicClass")
    def implemented_by_public_class(self, ringer: "IBellRinger") -> builtins.bool:
        '''...if the interface is implemented using a public class.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "implementedByPublicClass", [ringer]))

    @jsii.member(jsii_name="whenTypedAsClass")
    def when_typed_as_class(self, ringer: "IConcreteBellRinger") -> builtins.bool:
        '''If the parameter is a concrete class instead of an interface.

        Return whether the bell was rung.

        :param ringer: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "whenTypedAsClass", [ringer]))


class ConsumersOfThisCrazyTypeSystem(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ConsumersOfThisCrazyTypeSystem",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="consumeAnotherPublicInterface")
    def consume_another_public_interface(
        self,
        obj: "IAnotherPublicInterface",
    ) -> builtins.str:
        '''
        :param obj: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "consumeAnotherPublicInterface", [obj]))

    @jsii.member(jsii_name="consumeNonInternalInterface")
    def consume_non_internal_interface(
        self,
        obj: "INonInternalInterface",
    ) -> typing.Any:
        '''
        :param obj: -
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "consumeNonInternalInterface", [obj]))


@jsii.data_type(
    jsii_type="jsii-calc.ContainerProps",
    jsii_struct_bases=[],
    name_mapping={
        "array_prop": "arrayProp",
        "obj_prop": "objProp",
        "record_prop": "recordProp",
    },
)
class ContainerProps:
    def __init__(
        self,
        *,
        array_prop: typing.Sequence[typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        obj_prop: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
        record_prop: typing.Mapping[builtins.str, typing.Union["DummyObj", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''
        :param array_prop: 
        :param obj_prop: 
        :param record_prop: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "array_prop": array_prop,
            "obj_prop": obj_prop,
            "record_prop": record_prop,
        }

    @builtins.property
    def array_prop(self) -> typing.List["DummyObj"]:
        result = self._values.get("array_prop")
        assert result is not None, "Required property 'array_prop' is missing"
        return typing.cast(typing.List["DummyObj"], result)

    @builtins.property
    def obj_prop(self) -> typing.Mapping[builtins.str, "DummyObj"]:
        result = self._values.get("obj_prop")
        assert result is not None, "Required property 'obj_prop' is missing"
        return typing.cast(typing.Mapping[builtins.str, "DummyObj"], result)

    @builtins.property
    def record_prop(self) -> typing.Mapping[builtins.str, "DummyObj"]:
        result = self._values.get("record_prop")
        assert result is not None, "Required property 'record_prop' is missing"
        return typing.cast(typing.Mapping[builtins.str, "DummyObj"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataRenderer(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.DataRenderer"):
    '''Verifies proper type handling through dynamic overrides.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="render")
    def render(
        self,
        *,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> builtins.str:
        '''
        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 
        '''
        data = _scope_jsii_calc_lib_c61f082f.MyFirstStruct(
            anumber=anumber, astring=astring, first_optional=first_optional
        )

        return typing.cast(builtins.str, jsii.invoke(self, "render", [data]))

    @jsii.member(jsii_name="renderArbitrary")
    def render_arbitrary(
        self,
        data: typing.Mapping[builtins.str, typing.Any],
    ) -> builtins.str:
        '''
        :param data: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "renderArbitrary", [data]))

    @jsii.member(jsii_name="renderMap")
    def render_map(self, map: typing.Mapping[builtins.str, typing.Any]) -> builtins.str:
        '''
        :param map: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "renderMap", [map]))


class Default(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Default"):
    '''A class named "Default".

    :see: https://github.com/aws/jsii/issues/2637
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="pleaseCompile")
    def please_compile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "pleaseCompile", []))


class DefaultedConstructorArgument(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DefaultedConstructorArgument",
):
    def __init__(
        self,
        arg1: typing.Optional[jsii.Number] = None,
        arg2: typing.Optional[builtins.str] = None,
        arg3: typing.Optional[datetime.datetime] = None,
    ) -> None:
        '''
        :param arg1: -
        :param arg2: -
        :param arg3: -
        '''
        jsii.create(self.__class__, self, [arg1, arg2, arg3])

    @builtins.property
    @jsii.member(jsii_name="arg1")
    def arg1(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "arg1"))

    @builtins.property
    @jsii.member(jsii_name="arg3")
    def arg3(self) -> datetime.datetime:
        return typing.cast(datetime.datetime, jsii.get(self, "arg3"))

    @builtins.property
    @jsii.member(jsii_name="arg2")
    def arg2(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "arg2"))


class Demonstrate982(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Demonstrate982"):
    '''1.

    call #takeThis() -> An ObjectRef will be provisioned for the value (it'll be re-used!)
    2. call #takeThisToo() -> The ObjectRef from before will need to be down-cased to the ParentStruct982 type
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="takeThis")
    @builtins.classmethod
    def take_this(cls) -> "ChildStruct982":
        '''It's dangerous to go alone!'''
        return typing.cast("ChildStruct982", jsii.sinvoke(cls, "takeThis", []))

    @jsii.member(jsii_name="takeThisToo")
    @builtins.classmethod
    def take_this_too(cls) -> "ParentStruct982":
        '''It's dangerous to go alone!'''
        return typing.cast("ParentStruct982", jsii.sinvoke(cls, "takeThisToo", []))


class DeprecatedClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.DeprecatedClass"):
    '''
    :deprecated: a pretty boring class

    :stability: deprecated
    '''

    def __init__(
        self,
        readonly_string: builtins.str,
        mutable_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param readonly_string: -
        :param mutable_number: -

        :deprecated: this constructor is "just" okay

        :stability: deprecated
        '''
        jsii.create(self.__class__, self, [readonly_string, mutable_number])

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :deprecated: it was a bad idea

        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

    @builtins.property
    @jsii.member(jsii_name="readonlyProperty")
    def readonly_property(self) -> builtins.str:
        '''
        :deprecated: this is not always "wazoo", be ready to be disappointed

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.get(self, "readonlyProperty"))

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :deprecated: shouldn't have been mutable

        :stability: deprecated
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)


@jsii.enum(jsii_type="jsii-calc.DeprecatedEnum")
class DeprecatedEnum(enum.Enum):
    '''
    :deprecated: your deprecated selection of bad options

    :stability: deprecated
    '''

    OPTION_A = "OPTION_A"
    '''
    :deprecated: option A is not great

    :stability: deprecated
    '''
    OPTION_B = "OPTION_B"
    '''
    :deprecated: option B is kinda bad, too

    :stability: deprecated
    '''


@jsii.data_type(
    jsii_type="jsii-calc.DeprecatedStruct",
    jsii_struct_bases=[],
    name_mapping={"readonly_property": "readonlyProperty"},
)
class DeprecatedStruct:
    def __init__(self, *, readonly_property: builtins.str) -> None:
        '''
        :param readonly_property: 

        :deprecated: it just wraps a string

        :stability: deprecated
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "readonly_property": readonly_property,
        }

    @builtins.property
    def readonly_property(self) -> builtins.str:
        '''
        :deprecated: well, yeah

        :stability: deprecated
        '''
        result = self._values.get("readonly_property")
        assert result is not None, "Required property 'readonly_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DeprecatedStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DerivedStruct",
    jsii_struct_bases=[_scope_jsii_calc_lib_c61f082f.MyFirstStruct],
    name_mapping={
        "anumber": "anumber",
        "astring": "astring",
        "first_optional": "firstOptional",
        "another_required": "anotherRequired",
        "bool": "bool",
        "non_primitive": "nonPrimitive",
        "another_optional": "anotherOptional",
        "optional_any": "optionalAny",
        "optional_array": "optionalArray",
    },
)
class DerivedStruct(_scope_jsii_calc_lib_c61f082f.MyFirstStruct):
    def __init__(
        self,
        *,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
        another_required: datetime.datetime,
        bool: builtins.bool,
        non_primitive: "DoubleTrouble",
        another_optional: typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]] = None,
        optional_any: typing.Any = None,
        optional_array: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A struct which derives from another struct.

        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 
        :param another_required: 
        :param bool: 
        :param non_primitive: An example of a non primitive property.
        :param another_optional: This is optional.
        :param optional_any: 
        :param optional_array: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "anumber": anumber,
            "astring": astring,
            "another_required": another_required,
            "bool": bool,
            "non_primitive": non_primitive,
        }
        if first_optional is not None:
            self._values["first_optional"] = first_optional
        if another_optional is not None:
            self._values["another_optional"] = another_optional
        if optional_any is not None:
            self._values["optional_any"] = optional_any
        if optional_array is not None:
            self._values["optional_array"] = optional_array

    @builtins.property
    def anumber(self) -> jsii.Number:
        '''(deprecated) An awesome number value.

        :stability: deprecated
        '''
        result = self._values.get("anumber")
        assert result is not None, "Required property 'anumber' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def astring(self) -> builtins.str:
        '''(deprecated) A string value.

        :stability: deprecated
        '''
        result = self._values.get("astring")
        assert result is not None, "Required property 'astring' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def first_optional(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("first_optional")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def another_required(self) -> datetime.datetime:
        result = self._values.get("another_required")
        assert result is not None, "Required property 'another_required' is missing"
        return typing.cast(datetime.datetime, result)

    @builtins.property
    def bool(self) -> builtins.bool:
        result = self._values.get("bool")
        assert result is not None, "Required property 'bool' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def non_primitive(self) -> "DoubleTrouble":
        '''An example of a non primitive property.'''
        result = self._values.get("non_primitive")
        assert result is not None, "Required property 'non_primitive' is missing"
        return typing.cast("DoubleTrouble", result)

    @builtins.property
    def another_optional(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]]:
        '''This is optional.'''
        result = self._values.get("another_optional")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]], result)

    @builtins.property
    def optional_any(self) -> typing.Any:
        result = self._values.get("optional_any")
        return typing.cast(typing.Any, result)

    @builtins.property
    def optional_array(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("optional_array")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DerivedStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DiamondBottom",
    jsii_struct_bases=[
        _scope_jsii_calc_lib_c61f082f.DiamondLeft,
        _scope_jsii_calc_lib_c61f082f.DiamondRight,
    ],
    name_mapping={
        "hoisted_top": "hoistedTop",
        "left": "left",
        "right": "right",
        "bottom": "bottom",
    },
)
class DiamondBottom(
    _scope_jsii_calc_lib_c61f082f.DiamondLeft,
    _scope_jsii_calc_lib_c61f082f.DiamondRight,
):
    def __init__(
        self,
        *,
        hoisted_top: typing.Optional[builtins.str] = None,
        left: typing.Optional[jsii.Number] = None,
        right: typing.Optional[builtins.bool] = None,
        bottom: typing.Optional[datetime.datetime] = None,
    ) -> None:
        '''
        :param hoisted_top: 
        :param left: 
        :param right: 
        :param bottom: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hoisted_top is not None:
            self._values["hoisted_top"] = hoisted_top
        if left is not None:
            self._values["left"] = left
        if right is not None:
            self._values["right"] = right
        if bottom is not None:
            self._values["bottom"] = bottom

    @builtins.property
    def hoisted_top(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("hoisted_top")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def left(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("left")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def right(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("right")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def bottom(self) -> typing.Optional[datetime.datetime]:
        result = self._values.get("bottom")
        return typing.cast(typing.Optional[datetime.datetime], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondBottom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DiamondInheritanceBaseLevelStruct",
    jsii_struct_bases=[],
    name_mapping={"base_level_property": "baseLevelProperty"},
)
class DiamondInheritanceBaseLevelStruct:
    def __init__(self, *, base_level_property: builtins.str) -> None:
        '''
        :param base_level_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "base_level_property": base_level_property,
        }

    @builtins.property
    def base_level_property(self) -> builtins.str:
        result = self._values.get("base_level_property")
        assert result is not None, "Required property 'base_level_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondInheritanceBaseLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DiamondInheritanceFirstMidLevelStruct",
    jsii_struct_bases=[DiamondInheritanceBaseLevelStruct],
    name_mapping={
        "base_level_property": "baseLevelProperty",
        "first_mid_level_property": "firstMidLevelProperty",
    },
)
class DiamondInheritanceFirstMidLevelStruct(DiamondInheritanceBaseLevelStruct):
    def __init__(
        self,
        *,
        base_level_property: builtins.str,
        first_mid_level_property: builtins.str,
    ) -> None:
        '''
        :param base_level_property: 
        :param first_mid_level_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "base_level_property": base_level_property,
            "first_mid_level_property": first_mid_level_property,
        }

    @builtins.property
    def base_level_property(self) -> builtins.str:
        result = self._values.get("base_level_property")
        assert result is not None, "Required property 'base_level_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def first_mid_level_property(self) -> builtins.str:
        result = self._values.get("first_mid_level_property")
        assert result is not None, "Required property 'first_mid_level_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondInheritanceFirstMidLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DiamondInheritanceSecondMidLevelStruct",
    jsii_struct_bases=[DiamondInheritanceBaseLevelStruct],
    name_mapping={
        "base_level_property": "baseLevelProperty",
        "second_mid_level_property": "secondMidLevelProperty",
    },
)
class DiamondInheritanceSecondMidLevelStruct(DiamondInheritanceBaseLevelStruct):
    def __init__(
        self,
        *,
        base_level_property: builtins.str,
        second_mid_level_property: builtins.str,
    ) -> None:
        '''
        :param base_level_property: 
        :param second_mid_level_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "base_level_property": base_level_property,
            "second_mid_level_property": second_mid_level_property,
        }

    @builtins.property
    def base_level_property(self) -> builtins.str:
        result = self._values.get("base_level_property")
        assert result is not None, "Required property 'base_level_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def second_mid_level_property(self) -> builtins.str:
        result = self._values.get("second_mid_level_property")
        assert result is not None, "Required property 'second_mid_level_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondInheritanceSecondMidLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.DiamondInheritanceTopLevelStruct",
    jsii_struct_bases=[
        DiamondInheritanceFirstMidLevelStruct, DiamondInheritanceSecondMidLevelStruct
    ],
    name_mapping={
        "base_level_property": "baseLevelProperty",
        "first_mid_level_property": "firstMidLevelProperty",
        "second_mid_level_property": "secondMidLevelProperty",
        "top_level_property": "topLevelProperty",
    },
)
class DiamondInheritanceTopLevelStruct(
    DiamondInheritanceFirstMidLevelStruct,
    DiamondInheritanceSecondMidLevelStruct,
):
    def __init__(
        self,
        *,
        base_level_property: builtins.str,
        first_mid_level_property: builtins.str,
        second_mid_level_property: builtins.str,
        top_level_property: builtins.str,
    ) -> None:
        '''
        :param base_level_property: 
        :param first_mid_level_property: 
        :param second_mid_level_property: 
        :param top_level_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "base_level_property": base_level_property,
            "first_mid_level_property": first_mid_level_property,
            "second_mid_level_property": second_mid_level_property,
            "top_level_property": top_level_property,
        }

    @builtins.property
    def base_level_property(self) -> builtins.str:
        result = self._values.get("base_level_property")
        assert result is not None, "Required property 'base_level_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def first_mid_level_property(self) -> builtins.str:
        result = self._values.get("first_mid_level_property")
        assert result is not None, "Required property 'first_mid_level_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def second_mid_level_property(self) -> builtins.str:
        result = self._values.get("second_mid_level_property")
        assert result is not None, "Required property 'second_mid_level_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def top_level_property(self) -> builtins.str:
        result = self._values.get("top_level_property")
        assert result is not None, "Required property 'top_level_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiamondInheritanceTopLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DisappointingCollectionSource(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DisappointingCollectionSource",
):
    '''Verifies that null/undefined can be returned for optional collections.

    This source of collections is disappointing - it'll always give you nothing :(
    '''

    @jsii.python.classproperty
    @jsii.member(jsii_name="maybeList")
    def MAYBE_LIST(cls) -> typing.Optional[typing.List[builtins.str]]:
        '''Some List of strings, maybe?

        (Nah, just a billion dollars mistake!)
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.sget(cls, "maybeList"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="maybeMap")
    def MAYBE_MAP(cls) -> typing.Optional[typing.Mapping[builtins.str, jsii.Number]]:
        '''Some Map of strings to numbers, maybe?

        (Nah, just a billion dollars mistake!)
        '''
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, jsii.Number]], jsii.sget(cls, "maybeMap"))


class DoNotOverridePrivates(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DoNotOverridePrivates",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="changePrivatePropertyValue")
    def change_private_property_value(self, new_value: builtins.str) -> None:
        '''
        :param new_value: -
        '''
        return typing.cast(None, jsii.invoke(self, "changePrivatePropertyValue", [new_value]))

    @jsii.member(jsii_name="privateMethodValue")
    def private_method_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "privateMethodValue", []))

    @jsii.member(jsii_name="privatePropertyValue")
    def private_property_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "privatePropertyValue", []))


class DoNotRecognizeAnyAsOptional(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DoNotRecognizeAnyAsOptional",
):
    '''jsii#284: do not recognize "any" as an optional argument.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="method")
    def method(
        self,
        _required_any: typing.Any,
        _optional_any: typing.Any = None,
        _optional_string: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param _required_any: -
        :param _optional_any: -
        :param _optional_string: -
        '''
        return typing.cast(None, jsii.invoke(self, "method", [_required_any, _optional_any, _optional_string]))


class DocumentedClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.DocumentedClass"):
    '''Here's the first line of the TSDoc comment.

    This is the meat of the TSDoc comment. It may contain
    multiple lines and multiple paragraphs.

    Multiple paragraphs are separated by an empty line.

    Example::

        x = 12 + 44
        s1 = "string"
        s2 = "string \\nwith new newlines" # see https://github.com/aws/jsii/issues/2569
        s3 = """string
                    with
                    new lines"""
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="greet")
    def greet(self, *, name: typing.Optional[builtins.str] = None) -> jsii.Number:
        '''Greet the indicated person.

        This will print out a friendly greeting intended for the indicated person.

        :param name: The name of the greetee. Default: world

        :return:

        A number that everyone knows very well and represents the answer
        to the ultimate question
        '''
        greetee = Greetee(name=name)

        return typing.cast(jsii.Number, jsii.invoke(self, "greet", [greetee]))

    @jsii.member(jsii_name="hola")
    def hola(self) -> None:
        '''(experimental) Say ¬°Hola!

        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "hola", []))


class DontComplainAboutVariadicAfterOptional(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DontComplainAboutVariadicAfterOptional",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="optionalAndVariadic")
    def optional_and_variadic(
        self,
        optional: typing.Optional[builtins.str] = None,
        *things: builtins.str,
    ) -> builtins.str:
        '''
        :param optional: -
        :param things: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "optionalAndVariadic", [optional, *things]))


@jsii.data_type(
    jsii_type="jsii-calc.DummyObj",
    jsii_struct_bases=[],
    name_mapping={"example": "example"},
)
class DummyObj:
    def __init__(self, *, example: builtins.str) -> None:
        '''
        :param example: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "example": example,
        }

    @builtins.property
    def example(self) -> builtins.str:
        result = self._values.get("example")
        assert result is not None, "Required property 'example' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DummyObj(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamicPropertyBearer(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DynamicPropertyBearer",
):
    '''Ensures we can override a dynamic property that was inherited.'''

    def __init__(self, value_store: builtins.str) -> None:
        '''
        :param value_store: -
        '''
        jsii.create(self.__class__, self, [value_store])

    @builtins.property
    @jsii.member(jsii_name="dynamicProperty")
    def dynamic_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "dynamicProperty"))

    @dynamic_property.setter
    def dynamic_property(self, value: builtins.str) -> None:
        jsii.set(self, "dynamicProperty", value)

    @builtins.property
    @jsii.member(jsii_name="valueStore")
    def value_store(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "valueStore"))

    @value_store.setter
    def value_store(self, value: builtins.str) -> None:
        jsii.set(self, "valueStore", value)


class DynamicPropertyBearerChild(
    DynamicPropertyBearer,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DynamicPropertyBearerChild",
):
    def __init__(self, original_value: builtins.str) -> None:
        '''
        :param original_value: -
        '''
        jsii.create(self.__class__, self, [original_value])

    @jsii.member(jsii_name="overrideValue")
    def override_value(self, new_value: builtins.str) -> builtins.str:
        '''Sets \`\`this.dynamicProperty\`\` to the new value, and returns the old value.

        :param new_value: the new value to be set.

        :return: the old value that was set.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "overrideValue", [new_value]))

    @builtins.property
    @jsii.member(jsii_name="originalValue")
    def original_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "originalValue"))


class Entropy(metaclass=jsii.JSIIAbstractClass, jsii_type="jsii-calc.Entropy"):
    '''This class is used to validate that serialization and deserialization does not interpret ISO-8601-formatted timestampts to the native date/time object, as the jsii protocol has a $jsii$date wrapper for this purpose (node's JSON parsing does *NOT* detect dates automatically in this way, so host libraries should not either).'''

    def __init__(self, clock: "IWallClock") -> None:
        '''Creates a new instance of Entropy.

        :param clock: your implementation of \`\`WallClock\`\`.
        '''
        jsii.create(self.__class__, self, [clock])

    @jsii.member(jsii_name="increase")
    def increase(self) -> builtins.str:
        '''Increases entropy by consuming time from the clock (yes, this is a long shot, please don't judge).

        :return: the time from the \`\`WallClock\`\`.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "increase", []))

    @jsii.member(jsii_name="repeat")
    @abc.abstractmethod
    def repeat(self, word: builtins.str) -> builtins.str:
        '''Implement this method such that it returns \`\`word\`\`.

        :param word: the value to return.

        :return: \`\`word\`\`.
        '''
        ...


class _EntropyProxy(Entropy):
    @jsii.member(jsii_name="repeat")
    def repeat(self, word: builtins.str) -> builtins.str:
        '''Implement this method such that it returns \`\`word\`\`.

        :param word: the value to return.

        :return: \`\`word\`\`.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "repeat", [word]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Entropy).__jsii_proxy_class__ = lambda : _EntropyProxy


class EnumDispenser(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.EnumDispenser"):
    @jsii.member(jsii_name="randomIntegerLikeEnum")
    @builtins.classmethod
    def random_integer_like_enum(cls) -> AllTypesEnum:
        return typing.cast(AllTypesEnum, jsii.sinvoke(cls, "randomIntegerLikeEnum", []))

    @jsii.member(jsii_name="randomStringLikeEnum")
    @builtins.classmethod
    def random_string_like_enum(cls) -> "StringEnum":
        return typing.cast("StringEnum", jsii.sinvoke(cls, "randomStringLikeEnum", []))


class EraseUndefinedHashValues(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.EraseUndefinedHashValues",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="doesKeyExist")
    @builtins.classmethod
    def does_key_exist(
        cls,
        opts: typing.Union["EraseUndefinedHashValuesOptions", typing.Dict[builtins.str, typing.Any]],
        key: builtins.str,
    ) -> builtins.bool:
        '''Returns \`\`true\`\` if \`\`key\`\` is defined in \`\`opts\`\`.

        Used to check that undefined/null hash values
        are being erased when sending values from native code to JS.

        :param opts: -
        :param key: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "doesKeyExist", [opts, key]))

    @jsii.member(jsii_name="prop1IsNull")
    @builtins.classmethod
    def prop1_is_null(cls) -> typing.Mapping[builtins.str, typing.Any]:
        '''We expect "prop1" to be erased.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.sinvoke(cls, "prop1IsNull", []))

    @jsii.member(jsii_name="prop2IsUndefined")
    @builtins.classmethod
    def prop2_is_undefined(cls) -> typing.Mapping[builtins.str, typing.Any]:
        '''We expect "prop2" to be erased.'''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.sinvoke(cls, "prop2IsUndefined", []))


@jsii.data_type(
    jsii_type="jsii-calc.EraseUndefinedHashValuesOptions",
    jsii_struct_bases=[],
    name_mapping={"option1": "option1", "option2": "option2"},
)
class EraseUndefinedHashValuesOptions:
    def __init__(
        self,
        *,
        option1: typing.Optional[builtins.str] = None,
        option2: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param option1: 
        :param option2: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if option1 is not None:
            self._values["option1"] = option1
        if option2 is not None:
            self._values["option2"] = option2

    @builtins.property
    def option1(self) -> typing.Optional[builtins.str]:
        result = self._values.get("option1")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def option2(self) -> typing.Optional[builtins.str]:
        result = self._values.get("option2")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EraseUndefinedHashValuesOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExperimentalClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ExperimentalClass",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        readonly_string: builtins.str,
        mutable_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param readonly_string: -
        :param mutable_number: -

        :stability: experimental
        '''
        jsii.create(self.__class__, self, [readonly_string, mutable_number])

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

    @builtins.property
    @jsii.member(jsii_name="readonlyProperty")
    def readonly_property(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "readonlyProperty"))

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)


@jsii.enum(jsii_type="jsii-calc.ExperimentalEnum")
class ExperimentalEnum(enum.Enum):
    '''
    :stability: experimental
    '''

    OPTION_A = "OPTION_A"
    '''
    :stability: experimental
    '''
    OPTION_B = "OPTION_B"
    '''
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="jsii-calc.ExperimentalStruct",
    jsii_struct_bases=[],
    name_mapping={"readonly_property": "readonlyProperty"},
)
class ExperimentalStruct:
    def __init__(self, *, readonly_property: builtins.str) -> None:
        '''
        :param readonly_property: 

        :stability: experimental
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "readonly_property": readonly_property,
        }

    @builtins.property
    def readonly_property(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("readonly_property")
        assert result is not None, "Required property 'readonly_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExperimentalStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExportedBaseClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ExportedBaseClass",
):
    def __init__(self, success: builtins.bool) -> None:
        '''
        :param success: -
        '''
        jsii.create(self.__class__, self, [success])

    @builtins.property
    @jsii.member(jsii_name="success")
    def success(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "success"))


@jsii.data_type(
    jsii_type="jsii-calc.ExtendsInternalInterface",
    jsii_struct_bases=[],
    name_mapping={"boom": "boom", "prop": "prop"},
)
class ExtendsInternalInterface:
    def __init__(self, *, boom: builtins.bool, prop: builtins.str) -> None:
        '''
        :param boom: 
        :param prop: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "boom": boom,
            "prop": prop,
        }

    @builtins.property
    def boom(self) -> builtins.bool:
        result = self._values.get("boom")
        assert result is not None, "Required property 'boom' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def prop(self) -> builtins.str:
        result = self._values.get("prop")
        assert result is not None, "Required property 'prop' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExtendsInternalInterface(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.ExternalClass"):
    '''
    :external: true
    '''

    def __init__(
        self,
        readonly_string: builtins.str,
        mutable_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param readonly_string: -
        :param mutable_number: -

        :external: true
        '''
        jsii.create(self.__class__, self, [readonly_string, mutable_number])

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :external: true
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

    @builtins.property
    @jsii.member(jsii_name="readonlyProperty")
    def readonly_property(self) -> builtins.str:
        '''
        :external: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "readonlyProperty"))

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :external: true
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)


@jsii.enum(jsii_type="jsii-calc.ExternalEnum")
class ExternalEnum(enum.Enum):
    '''
    :external: true
    '''

    OPTION_A = "OPTION_A"
    '''
    :external: true
    '''
    OPTION_B = "OPTION_B"
    '''
    :external: true
    '''


@jsii.data_type(
    jsii_type="jsii-calc.ExternalStruct",
    jsii_struct_bases=[],
    name_mapping={"readonly_property": "readonlyProperty"},
)
class ExternalStruct:
    def __init__(self, *, readonly_property: builtins.str) -> None:
        '''
        :param readonly_property: 

        :external: true
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "readonly_property": readonly_property,
        }

    @builtins.property
    def readonly_property(self) -> builtins.str:
        '''
        :external: true
        '''
        result = self._values.get("readonly_property")
        assert result is not None, "Required property 'readonly_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GiveMeStructs(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.GiveMeStructs"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="derivedToFirst")
    def derived_to_first(
        self,
        *,
        another_required: datetime.datetime,
        bool: builtins.bool,
        non_primitive: "DoubleTrouble",
        another_optional: typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]] = None,
        optional_any: typing.Any = None,
        optional_array: typing.Optional[typing.Sequence[builtins.str]] = None,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> _scope_jsii_calc_lib_c61f082f.MyFirstStruct:
        '''Accepts a struct of type DerivedStruct and returns a struct of type FirstStruct.

        :param another_required: 
        :param bool: 
        :param non_primitive: An example of a non primitive property.
        :param another_optional: This is optional.
        :param optional_any: 
        :param optional_array: 
        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 
        '''
        derived = DerivedStruct(
            another_required=another_required,
            bool=bool,
            non_primitive=non_primitive,
            another_optional=another_optional,
            optional_any=optional_any,
            optional_array=optional_array,
            anumber=anumber,
            astring=astring,
            first_optional=first_optional,
        )

        return typing.cast(_scope_jsii_calc_lib_c61f082f.MyFirstStruct, jsii.invoke(self, "derivedToFirst", [derived]))

    @jsii.member(jsii_name="readDerivedNonPrimitive")
    def read_derived_non_primitive(
        self,
        *,
        another_required: datetime.datetime,
        bool: builtins.bool,
        non_primitive: "DoubleTrouble",
        another_optional: typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]] = None,
        optional_any: typing.Any = None,
        optional_array: typing.Optional[typing.Sequence[builtins.str]] = None,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "DoubleTrouble":
        '''Returns the boolean from a DerivedStruct struct.

        :param another_required: 
        :param bool: 
        :param non_primitive: An example of a non primitive property.
        :param another_optional: This is optional.
        :param optional_any: 
        :param optional_array: 
        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 
        '''
        derived = DerivedStruct(
            another_required=another_required,
            bool=bool,
            non_primitive=non_primitive,
            another_optional=another_optional,
            optional_any=optional_any,
            optional_array=optional_array,
            anumber=anumber,
            astring=astring,
            first_optional=first_optional,
        )

        return typing.cast("DoubleTrouble", jsii.invoke(self, "readDerivedNonPrimitive", [derived]))

    @jsii.member(jsii_name="readFirstNumber")
    def read_first_number(
        self,
        *,
        anumber: jsii.Number,
        astring: builtins.str,
        first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> jsii.Number:
        '''Returns the "anumber" from a MyFirstStruct struct;

        :param anumber: (deprecated) An awesome number value.
        :param astring: (deprecated) A string value.
        :param first_optional: 
        '''
        first = _scope_jsii_calc_lib_c61f082f.MyFirstStruct(
            anumber=anumber, astring=astring, first_optional=first_optional
        )

        return typing.cast(jsii.Number, jsii.invoke(self, "readFirstNumber", [first]))

    @builtins.property
    @jsii.member(jsii_name="structLiteral")
    def struct_literal(self) -> _scope_jsii_calc_lib_c61f082f.StructWithOnlyOptionals:
        return typing.cast(_scope_jsii_calc_lib_c61f082f.StructWithOnlyOptionals, jsii.get(self, "structLiteral"))


@jsii.data_type(
    jsii_type="jsii-calc.Greetee",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class Greetee:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''These are some arguments you can pass to a method.

        :param name: The name of the greetee. Default: world
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the greetee.

        :default: world
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Greetee(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GreetingAugmenter(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.GreetingAugmenter",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="betterGreeting")
    def better_greeting(
        self,
        friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
    ) -> builtins.str:
        '''
        :param friendly: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "betterGreeting", [friendly]))


@jsii.interface(jsii_type="jsii-calc.IAnonymousImplementationProvider")
class IAnonymousImplementationProvider(typing_extensions.Protocol):
    '''We can return an anonymous interface implementation from an override without losing the interface declarations.'''

    @jsii.member(jsii_name="provideAsClass")
    def provide_as_class(self) -> "Implementation":
        ...

    @jsii.member(jsii_name="provideAsInterface")
    def provide_as_interface(self) -> "IAnonymouslyImplementMe":
        ...


class _IAnonymousImplementationProviderProxy:
    '''We can return an anonymous interface implementation from an override without losing the interface declarations.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IAnonymousImplementationProvider"

    @jsii.member(jsii_name="provideAsClass")
    def provide_as_class(self) -> "Implementation":
        return typing.cast("Implementation", jsii.invoke(self, "provideAsClass", []))

    @jsii.member(jsii_name="provideAsInterface")
    def provide_as_interface(self) -> "IAnonymouslyImplementMe":
        return typing.cast("IAnonymouslyImplementMe", jsii.invoke(self, "provideAsInterface", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAnonymousImplementationProvider).__jsii_proxy_class__ = lambda : _IAnonymousImplementationProviderProxy


@jsii.interface(jsii_type="jsii-calc.IAnonymouslyImplementMe")
class IAnonymouslyImplementMe(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        ...

    @jsii.member(jsii_name="verb")
    def verb(self) -> builtins.str:
        ...


class _IAnonymouslyImplementMeProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IAnonymouslyImplementMe"

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @jsii.member(jsii_name="verb")
    def verb(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "verb", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAnonymouslyImplementMe).__jsii_proxy_class__ = lambda : _IAnonymouslyImplementMeProxy


@jsii.interface(jsii_type="jsii-calc.IAnotherPublicInterface")
class IAnotherPublicInterface(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="a")
    def a(self) -> builtins.str:
        ...

    @a.setter
    def a(self, value: builtins.str) -> None:
        ...


class _IAnotherPublicInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IAnotherPublicInterface"

    @builtins.property
    @jsii.member(jsii_name="a")
    def a(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "a"))

    @a.setter
    def a(self, value: builtins.str) -> None:
        jsii.set(self, "a", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAnotherPublicInterface).__jsii_proxy_class__ = lambda : _IAnotherPublicInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IBell")
class IBell(typing_extensions.Protocol):
    @jsii.member(jsii_name="ring")
    def ring(self) -> None:
        ...


class _IBellProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IBell"

    @jsii.member(jsii_name="ring")
    def ring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "ring", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IBell).__jsii_proxy_class__ = lambda : _IBellProxy


@jsii.interface(jsii_type="jsii-calc.IBellRinger")
class IBellRinger(typing_extensions.Protocol):
    '''Takes the object parameter as an interface.'''

    @jsii.member(jsii_name="yourTurn")
    def your_turn(self, bell: IBell) -> None:
        '''
        :param bell: -
        '''
        ...


class _IBellRingerProxy:
    '''Takes the object parameter as an interface.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IBellRinger"

    @jsii.member(jsii_name="yourTurn")
    def your_turn(self, bell: IBell) -> None:
        '''
        :param bell: -
        '''
        return typing.cast(None, jsii.invoke(self, "yourTurn", [bell]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IBellRinger).__jsii_proxy_class__ = lambda : _IBellRingerProxy


@jsii.interface(jsii_type="jsii-calc.IConcreteBellRinger")
class IConcreteBellRinger(typing_extensions.Protocol):
    '''Takes the object parameter as a calss.'''

    @jsii.member(jsii_name="yourTurn")
    def your_turn(self, bell: "Bell") -> None:
        '''
        :param bell: -
        '''
        ...


class _IConcreteBellRingerProxy:
    '''Takes the object parameter as a calss.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IConcreteBellRinger"

    @jsii.member(jsii_name="yourTurn")
    def your_turn(self, bell: "Bell") -> None:
        '''
        :param bell: -
        '''
        return typing.cast(None, jsii.invoke(self, "yourTurn", [bell]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IConcreteBellRinger).__jsii_proxy_class__ = lambda : _IConcreteBellRingerProxy


@jsii.interface(jsii_type="jsii-calc.IDeprecatedInterface")
class IDeprecatedInterface(typing_extensions.Protocol):
    '''
    :deprecated: useless interface

    :stability: deprecated
    '''

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :deprecated: could be better

        :stability: deprecated
        '''
        ...

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        ...

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :deprecated: services no purpose

        :stability: deprecated
        '''
        ...


class _IDeprecatedInterfaceProxy:
    '''
    :deprecated: useless interface

    :stability: deprecated
    '''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IDeprecatedInterface"

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :deprecated: could be better

        :stability: deprecated
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :deprecated: services no purpose

        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDeprecatedInterface).__jsii_proxy_class__ = lambda : _IDeprecatedInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IExperimentalInterface")
class IExperimentalInterface(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        ...

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        ...

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :stability: experimental
        '''
        ...


class _IExperimentalInterfaceProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IExperimentalInterface"

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :stability: experimental
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IExperimentalInterface).__jsii_proxy_class__ = lambda : _IExperimentalInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IExtendsPrivateInterface")
class IExtendsPrivateInterface(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="moreThings")
    def more_things(self) -> typing.List[builtins.str]:
        ...

    @builtins.property
    @jsii.member(jsii_name="private")
    def private(self) -> builtins.str:
        ...

    @private.setter
    def private(self, value: builtins.str) -> None:
        ...


class _IExtendsPrivateInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IExtendsPrivateInterface"

    @builtins.property
    @jsii.member(jsii_name="moreThings")
    def more_things(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "moreThings"))

    @builtins.property
    @jsii.member(jsii_name="private")
    def private(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "private"))

    @private.setter
    def private(self, value: builtins.str) -> None:
        jsii.set(self, "private", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IExtendsPrivateInterface).__jsii_proxy_class__ = lambda : _IExtendsPrivateInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IExternalInterface")
class IExternalInterface(typing_extensions.Protocol):
    '''
    :external: true
    '''

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :external: true
        '''
        ...

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        ...

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :external: true
        '''
        ...


class _IExternalInterfaceProxy:
    '''
    :external: true
    '''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IExternalInterface"

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        '''
        :external: true
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        '''
        :external: true
        '''
        return typing.cast(None, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IExternalInterface).__jsii_proxy_class__ = lambda : _IExternalInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IFriendlier")
class IFriendlier(_scope_jsii_calc_lib_c61f082f.IFriendly, typing_extensions.Protocol):
    '''Even friendlier classes can implement this interface.'''

    @jsii.member(jsii_name="farewell")
    def farewell(self) -> builtins.str:
        '''Say farewell.'''
        ...

    @jsii.member(jsii_name="goodbye")
    def goodbye(self) -> builtins.str:
        '''Say goodbye.

        :return: A goodbye blessing.
        '''
        ...


class _IFriendlierProxy(
    jsii.proxy_for(_scope_jsii_calc_lib_c61f082f.IFriendly), # type: ignore[misc]
):
    '''Even friendlier classes can implement this interface.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IFriendlier"

    @jsii.member(jsii_name="farewell")
    def farewell(self) -> builtins.str:
        '''Say farewell.'''
        return typing.cast(builtins.str, jsii.invoke(self, "farewell", []))

    @jsii.member(jsii_name="goodbye")
    def goodbye(self) -> builtins.str:
        '''Say goodbye.

        :return: A goodbye blessing.
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "goodbye", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFriendlier).__jsii_proxy_class__ = lambda : _IFriendlierProxy


@jsii.interface(jsii_type="jsii-calc.IIndirectlyImplemented")
class IIndirectlyImplemented(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="method")
    def method(self) -> jsii.Number:
        ...


class _IIndirectlyImplementedProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IIndirectlyImplemented"

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))

    @jsii.member(jsii_name="method")
    def method(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IIndirectlyImplemented).__jsii_proxy_class__ = lambda : _IIndirectlyImplementedProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceImplementedByAbstractClass")
class IInterfaceImplementedByAbstractClass(typing_extensions.Protocol):
    '''awslabs/jsii#220 Abstract return type.'''

    @builtins.property
    @jsii.member(jsii_name="propFromInterface")
    def prop_from_interface(self) -> builtins.str:
        ...


class _IInterfaceImplementedByAbstractClassProxy:
    '''awslabs/jsii#220 Abstract return type.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceImplementedByAbstractClass"

    @builtins.property
    @jsii.member(jsii_name="propFromInterface")
    def prop_from_interface(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "propFromInterface"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceImplementedByAbstractClass).__jsii_proxy_class__ = lambda : _IInterfaceImplementedByAbstractClassProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceWithInternal")
class IInterfaceWithInternal(typing_extensions.Protocol):
    @jsii.member(jsii_name="visible")
    def visible(self) -> None:
        ...


class _IInterfaceWithInternalProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceWithInternal"

    @jsii.member(jsii_name="visible")
    def visible(self) -> None:
        return typing.cast(None, jsii.invoke(self, "visible", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithInternal).__jsii_proxy_class__ = lambda : _IInterfaceWithInternalProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceWithMethods")
class IInterfaceWithMethods(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="doThings")
    def do_things(self) -> None:
        ...


class _IInterfaceWithMethodsProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceWithMethods"

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @jsii.member(jsii_name="doThings")
    def do_things(self) -> None:
        return typing.cast(None, jsii.invoke(self, "doThings", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithMethods).__jsii_proxy_class__ = lambda : _IInterfaceWithMethodsProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceWithOptionalMethodArguments")
class IInterfaceWithOptionalMethodArguments(typing_extensions.Protocol):
    '''awslabs/jsii#175 Interface proxies (and builders) do not respect optional arguments in methods.'''

    @jsii.member(jsii_name="hello")
    def hello(
        self,
        arg1: builtins.str,
        arg2: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param arg1: -
        :param arg2: -
        '''
        ...


class _IInterfaceWithOptionalMethodArgumentsProxy:
    '''awslabs/jsii#175 Interface proxies (and builders) do not respect optional arguments in methods.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceWithOptionalMethodArguments"

    @jsii.member(jsii_name="hello")
    def hello(
        self,
        arg1: builtins.str,
        arg2: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param arg1: -
        :param arg2: -
        '''
        return typing.cast(None, jsii.invoke(self, "hello", [arg1, arg2]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithOptionalMethodArguments).__jsii_proxy_class__ = lambda : _IInterfaceWithOptionalMethodArgumentsProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceWithProperties")
class IInterfaceWithProperties(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="readOnlyString")
    def read_only_string(self) -> builtins.str:
        ...

    @builtins.property
    @jsii.member(jsii_name="readWriteString")
    def read_write_string(self) -> builtins.str:
        ...

    @read_write_string.setter
    def read_write_string(self, value: builtins.str) -> None:
        ...


class _IInterfaceWithPropertiesProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceWithProperties"

    @builtins.property
    @jsii.member(jsii_name="readOnlyString")
    def read_only_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readOnlyString"))

    @builtins.property
    @jsii.member(jsii_name="readWriteString")
    def read_write_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readWriteString"))

    @read_write_string.setter
    def read_write_string(self, value: builtins.str) -> None:
        jsii.set(self, "readWriteString", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithProperties).__jsii_proxy_class__ = lambda : _IInterfaceWithPropertiesProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceWithPropertiesExtension")
class IInterfaceWithPropertiesExtension(
    IInterfaceWithProperties,
    typing_extensions.Protocol,
):
    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(self) -> jsii.Number:
        ...

    @foo.setter
    def foo(self, value: jsii.Number) -> None:
        ...


class _IInterfaceWithPropertiesExtensionProxy(
    jsii.proxy_for(IInterfaceWithProperties), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceWithPropertiesExtension"

    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "foo"))

    @foo.setter
    def foo(self, value: jsii.Number) -> None:
        jsii.set(self, "foo", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithPropertiesExtension).__jsii_proxy_class__ = lambda : _IInterfaceWithPropertiesExtensionProxy


@jsii.interface(jsii_type="jsii-calc.IJSII417PublicBaseOfBase")
class IJSII417PublicBaseOfBase(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="hasRoot")
    def has_root(self) -> builtins.bool:
        ...

    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        ...


class _IJSII417PublicBaseOfBaseProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJSII417PublicBaseOfBase"

    @builtins.property
    @jsii.member(jsii_name="hasRoot")
    def has_root(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "hasRoot"))

    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "foo", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJSII417PublicBaseOfBase).__jsii_proxy_class__ = lambda : _IJSII417PublicBaseOfBaseProxy


@jsii.interface(jsii_type="jsii-calc.IJavaReservedWordsInAnInterface")
class IJavaReservedWordsInAnInterface(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="while")
    def while_(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="abstract")
    def abstract(self) -> None:
        ...

    @jsii.member(jsii_name="assert")
    def assert_(self) -> None:
        ...

    @jsii.member(jsii_name="boolean")
    def boolean(self) -> None:
        ...

    @jsii.member(jsii_name="break")
    def break_(self) -> None:
        ...

    @jsii.member(jsii_name="byte")
    def byte(self) -> None:
        ...

    @jsii.member(jsii_name="case")
    def case(self) -> None:
        ...

    @jsii.member(jsii_name="catch")
    def catch(self) -> None:
        ...

    @jsii.member(jsii_name="char")
    def char(self) -> None:
        ...

    @jsii.member(jsii_name="class")
    def class_(self) -> None:
        ...

    @jsii.member(jsii_name="const")
    def const(self) -> None:
        ...

    @jsii.member(jsii_name="continue")
    def continue_(self) -> None:
        ...

    @jsii.member(jsii_name="default")
    def default(self) -> None:
        ...

    @jsii.member(jsii_name="do")
    def do(self) -> None:
        ...

    @jsii.member(jsii_name="double")
    def double(self) -> None:
        ...

    @jsii.member(jsii_name="else")
    def else_(self) -> None:
        ...

    @jsii.member(jsii_name="enum")
    def enum(self) -> None:
        ...

    @jsii.member(jsii_name="extends")
    def extends(self) -> None:
        ...

    @jsii.member(jsii_name="false")
    def false(self) -> None:
        ...

    @jsii.member(jsii_name="final")
    def final(self) -> None:
        ...

    @jsii.member(jsii_name="finally")
    def finally_(self) -> None:
        ...

    @jsii.member(jsii_name="float")
    def float(self) -> None:
        ...

    @jsii.member(jsii_name="for")
    def for_(self) -> None:
        ...

    @jsii.member(jsii_name="goto")
    def goto(self) -> None:
        ...

    @jsii.member(jsii_name="if")
    def if_(self) -> None:
        ...

    @jsii.member(jsii_name="implements")
    def implements(self) -> None:
        ...

    @jsii.member(jsii_name="import")
    def import_(self) -> None:
        ...

    @jsii.member(jsii_name="instanceof")
    def instanceof(self) -> None:
        ...

    @jsii.member(jsii_name="int")
    def int(self) -> None:
        ...

    @jsii.member(jsii_name="interface")
    def interface(self) -> None:
        ...

    @jsii.member(jsii_name="long")
    def long(self) -> None:
        ...

    @jsii.member(jsii_name="native")
    def native(self) -> None:
        ...

    @jsii.member(jsii_name="null")
    def null(self) -> None:
        ...

    @jsii.member(jsii_name="package")
    def package(self) -> None:
        ...

    @jsii.member(jsii_name="private")
    def private(self) -> None:
        ...

    @jsii.member(jsii_name="protected")
    def protected(self) -> None:
        ...

    @jsii.member(jsii_name="public")
    def public(self) -> None:
        ...

    @jsii.member(jsii_name="return")
    def return_(self) -> None:
        ...

    @jsii.member(jsii_name="short")
    def short(self) -> None:
        ...

    @jsii.member(jsii_name="static")
    def static(self) -> None:
        ...

    @jsii.member(jsii_name="strictfp")
    def strictfp(self) -> None:
        ...

    @jsii.member(jsii_name="super")
    def super(self) -> None:
        ...

    @jsii.member(jsii_name="switch")
    def switch(self) -> None:
        ...

    @jsii.member(jsii_name="synchronized")
    def synchronized(self) -> None:
        ...

    @jsii.member(jsii_name="this")
    def this(self) -> None:
        ...

    @jsii.member(jsii_name="throw")
    def throw(self) -> None:
        ...

    @jsii.member(jsii_name="throws")
    def throws(self) -> None:
        ...

    @jsii.member(jsii_name="transient")
    def transient(self) -> None:
        ...

    @jsii.member(jsii_name="true")
    def true(self) -> None:
        ...

    @jsii.member(jsii_name="try")
    def try_(self) -> None:
        ...

    @jsii.member(jsii_name="void")
    def void(self) -> None:
        ...

    @jsii.member(jsii_name="volatile")
    def volatile(self) -> None:
        ...


class _IJavaReservedWordsInAnInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJavaReservedWordsInAnInterface"

    @builtins.property
    @jsii.member(jsii_name="while")
    def while_(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "while"))

    @jsii.member(jsii_name="abstract")
    def abstract(self) -> None:
        return typing.cast(None, jsii.invoke(self, "abstract", []))

    @jsii.member(jsii_name="assert")
    def assert_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "assert", []))

    @jsii.member(jsii_name="boolean")
    def boolean(self) -> None:
        return typing.cast(None, jsii.invoke(self, "boolean", []))

    @jsii.member(jsii_name="break")
    def break_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "break", []))

    @jsii.member(jsii_name="byte")
    def byte(self) -> None:
        return typing.cast(None, jsii.invoke(self, "byte", []))

    @jsii.member(jsii_name="case")
    def case(self) -> None:
        return typing.cast(None, jsii.invoke(self, "case", []))

    @jsii.member(jsii_name="catch")
    def catch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "catch", []))

    @jsii.member(jsii_name="char")
    def char(self) -> None:
        return typing.cast(None, jsii.invoke(self, "char", []))

    @jsii.member(jsii_name="class")
    def class_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "class", []))

    @jsii.member(jsii_name="const")
    def const(self) -> None:
        return typing.cast(None, jsii.invoke(self, "const", []))

    @jsii.member(jsii_name="continue")
    def continue_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "continue", []))

    @jsii.member(jsii_name="default")
    def default(self) -> None:
        return typing.cast(None, jsii.invoke(self, "default", []))

    @jsii.member(jsii_name="do")
    def do(self) -> None:
        return typing.cast(None, jsii.invoke(self, "do", []))

    @jsii.member(jsii_name="double")
    def double(self) -> None:
        return typing.cast(None, jsii.invoke(self, "double", []))

    @jsii.member(jsii_name="else")
    def else_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "else", []))

    @jsii.member(jsii_name="enum")
    def enum(self) -> None:
        return typing.cast(None, jsii.invoke(self, "enum", []))

    @jsii.member(jsii_name="extends")
    def extends(self) -> None:
        return typing.cast(None, jsii.invoke(self, "extends", []))

    @jsii.member(jsii_name="false")
    def false(self) -> None:
        return typing.cast(None, jsii.invoke(self, "false", []))

    @jsii.member(jsii_name="final")
    def final(self) -> None:
        return typing.cast(None, jsii.invoke(self, "final", []))

    @jsii.member(jsii_name="finally")
    def finally_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "finally", []))

    @jsii.member(jsii_name="float")
    def float(self) -> None:
        return typing.cast(None, jsii.invoke(self, "float", []))

    @jsii.member(jsii_name="for")
    def for_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "for", []))

    @jsii.member(jsii_name="goto")
    def goto(self) -> None:
        return typing.cast(None, jsii.invoke(self, "goto", []))

    @jsii.member(jsii_name="if")
    def if_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "if", []))

    @jsii.member(jsii_name="implements")
    def implements(self) -> None:
        return typing.cast(None, jsii.invoke(self, "implements", []))

    @jsii.member(jsii_name="import")
    def import_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "import", []))

    @jsii.member(jsii_name="instanceof")
    def instanceof(self) -> None:
        return typing.cast(None, jsii.invoke(self, "instanceof", []))

    @jsii.member(jsii_name="int")
    def int(self) -> None:
        return typing.cast(None, jsii.invoke(self, "int", []))

    @jsii.member(jsii_name="interface")
    def interface(self) -> None:
        return typing.cast(None, jsii.invoke(self, "interface", []))

    @jsii.member(jsii_name="long")
    def long(self) -> None:
        return typing.cast(None, jsii.invoke(self, "long", []))

    @jsii.member(jsii_name="native")
    def native(self) -> None:
        return typing.cast(None, jsii.invoke(self, "native", []))

    @jsii.member(jsii_name="null")
    def null(self) -> None:
        return typing.cast(None, jsii.invoke(self, "null", []))

    @jsii.member(jsii_name="package")
    def package(self) -> None:
        return typing.cast(None, jsii.invoke(self, "package", []))

    @jsii.member(jsii_name="private")
    def private(self) -> None:
        return typing.cast(None, jsii.invoke(self, "private", []))

    @jsii.member(jsii_name="protected")
    def protected(self) -> None:
        return typing.cast(None, jsii.invoke(self, "protected", []))

    @jsii.member(jsii_name="public")
    def public(self) -> None:
        return typing.cast(None, jsii.invoke(self, "public", []))

    @jsii.member(jsii_name="return")
    def return_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "return", []))

    @jsii.member(jsii_name="short")
    def short(self) -> None:
        return typing.cast(None, jsii.invoke(self, "short", []))

    @jsii.member(jsii_name="static")
    def static(self) -> None:
        return typing.cast(None, jsii.invoke(self, "static", []))

    @jsii.member(jsii_name="strictfp")
    def strictfp(self) -> None:
        return typing.cast(None, jsii.invoke(self, "strictfp", []))

    @jsii.member(jsii_name="super")
    def super(self) -> None:
        return typing.cast(None, jsii.invoke(self, "super", []))

    @jsii.member(jsii_name="switch")
    def switch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "switch", []))

    @jsii.member(jsii_name="synchronized")
    def synchronized(self) -> None:
        return typing.cast(None, jsii.invoke(self, "synchronized", []))

    @jsii.member(jsii_name="this")
    def this(self) -> None:
        return typing.cast(None, jsii.invoke(self, "this", []))

    @jsii.member(jsii_name="throw")
    def throw(self) -> None:
        return typing.cast(None, jsii.invoke(self, "throw", []))

    @jsii.member(jsii_name="throws")
    def throws(self) -> None:
        return typing.cast(None, jsii.invoke(self, "throws", []))

    @jsii.member(jsii_name="transient")
    def transient(self) -> None:
        return typing.cast(None, jsii.invoke(self, "transient", []))

    @jsii.member(jsii_name="true")
    def true(self) -> None:
        return typing.cast(None, jsii.invoke(self, "true", []))

    @jsii.member(jsii_name="try")
    def try_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "try", []))

    @jsii.member(jsii_name="void")
    def void(self) -> None:
        return typing.cast(None, jsii.invoke(self, "void", []))

    @jsii.member(jsii_name="volatile")
    def volatile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "volatile", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJavaReservedWordsInAnInterface).__jsii_proxy_class__ = lambda : _IJavaReservedWordsInAnInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IJsii487External")
class IJsii487External(typing_extensions.Protocol):
    pass


class _IJsii487ExternalProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJsii487External"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJsii487External).__jsii_proxy_class__ = lambda : _IJsii487ExternalProxy


@jsii.interface(jsii_type="jsii-calc.IJsii487External2")
class IJsii487External2(typing_extensions.Protocol):
    pass


class _IJsii487External2Proxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJsii487External2"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJsii487External2).__jsii_proxy_class__ = lambda : _IJsii487External2Proxy


@jsii.interface(jsii_type="jsii-calc.IJsii496")
class IJsii496(typing_extensions.Protocol):
    pass


class _IJsii496Proxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJsii496"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJsii496).__jsii_proxy_class__ = lambda : _IJsii496Proxy


@jsii.interface(jsii_type="jsii-calc.IMutableObjectLiteral")
class IMutableObjectLiteral(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        ...

    @value.setter
    def value(self, value: builtins.str) -> None:
        ...


class _IMutableObjectLiteralProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IMutableObjectLiteral"

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))

    @value.setter
    def value(self, value: builtins.str) -> None:
        jsii.set(self, "value", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IMutableObjectLiteral).__jsii_proxy_class__ = lambda : _IMutableObjectLiteralProxy


@jsii.interface(jsii_type="jsii-calc.INonInternalInterface")
class INonInternalInterface(IAnotherPublicInterface, typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="b")
    def b(self) -> builtins.str:
        ...

    @b.setter
    def b(self, value: builtins.str) -> None:
        ...

    @builtins.property
    @jsii.member(jsii_name="c")
    def c(self) -> builtins.str:
        ...

    @c.setter
    def c(self, value: builtins.str) -> None:
        ...


class _INonInternalInterfaceProxy(
    jsii.proxy_for(IAnotherPublicInterface), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.INonInternalInterface"

    @builtins.property
    @jsii.member(jsii_name="b")
    def b(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "b"))

    @b.setter
    def b(self, value: builtins.str) -> None:
        jsii.set(self, "b", value)

    @builtins.property
    @jsii.member(jsii_name="c")
    def c(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "c"))

    @c.setter
    def c(self, value: builtins.str) -> None:
        jsii.set(self, "c", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, INonInternalInterface).__jsii_proxy_class__ = lambda : _INonInternalInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IObjectWithProperty")
class IObjectWithProperty(typing_extensions.Protocol):
    '''Make sure that setters are properly called on objects with interfaces.'''

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        ...

    @property.setter
    def property(self, value: builtins.str) -> None:
        ...

    @jsii.member(jsii_name="wasSet")
    def was_set(self) -> builtins.bool:
        ...


class _IObjectWithPropertyProxy:
    '''Make sure that setters are properly called on objects with interfaces.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IObjectWithProperty"

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))

    @property.setter
    def property(self, value: builtins.str) -> None:
        jsii.set(self, "property", value)

    @jsii.member(jsii_name="wasSet")
    def was_set(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.invoke(self, "wasSet", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IObjectWithProperty).__jsii_proxy_class__ = lambda : _IObjectWithPropertyProxy


@jsii.interface(jsii_type="jsii-calc.IOptionalMethod")
class IOptionalMethod(typing_extensions.Protocol):
    '''Checks that optional result from interface method code generates correctly.'''

    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Optional[builtins.str]:
        ...


class _IOptionalMethodProxy:
    '''Checks that optional result from interface method code generates correctly.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IOptionalMethod"

    @jsii.member(jsii_name="optional")
    def optional(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "optional", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IOptionalMethod).__jsii_proxy_class__ = lambda : _IOptionalMethodProxy


@jsii.interface(jsii_type="jsii-calc.IPrivatelyImplemented")
class IPrivatelyImplemented(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="success")
    def success(self) -> builtins.bool:
        ...


class _IPrivatelyImplementedProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IPrivatelyImplemented"

    @builtins.property
    @jsii.member(jsii_name="success")
    def success(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "success"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPrivatelyImplemented).__jsii_proxy_class__ = lambda : _IPrivatelyImplementedProxy


@jsii.interface(jsii_type="jsii-calc.IPublicInterface")
class IPublicInterface(typing_extensions.Protocol):
    @jsii.member(jsii_name="bye")
    def bye(self) -> builtins.str:
        ...


class _IPublicInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IPublicInterface"

    @jsii.member(jsii_name="bye")
    def bye(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "bye", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPublicInterface).__jsii_proxy_class__ = lambda : _IPublicInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IPublicInterface2")
class IPublicInterface2(typing_extensions.Protocol):
    @jsii.member(jsii_name="ciao")
    def ciao(self) -> builtins.str:
        ...


class _IPublicInterface2Proxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IPublicInterface2"

    @jsii.member(jsii_name="ciao")
    def ciao(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "ciao", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPublicInterface2).__jsii_proxy_class__ = lambda : _IPublicInterface2Proxy


@jsii.interface(jsii_type="jsii-calc.IRandomNumberGenerator")
class IRandomNumberGenerator(typing_extensions.Protocol):
    '''Generates random numbers.'''

    @jsii.member(jsii_name="next")
    def next(self) -> jsii.Number:
        '''Returns another random number.

        :return: A random number.
        '''
        ...


class _IRandomNumberGeneratorProxy:
    '''Generates random numbers.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IRandomNumberGenerator"

    @jsii.member(jsii_name="next")
    def next(self) -> jsii.Number:
        '''Returns another random number.

        :return: A random number.
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "next", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRandomNumberGenerator).__jsii_proxy_class__ = lambda : _IRandomNumberGeneratorProxy


@jsii.interface(jsii_type="jsii-calc.IReturnJsii976")
class IReturnJsii976(typing_extensions.Protocol):
    '''Returns a subclass of a known class which implements an interface.'''

    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(self) -> jsii.Number:
        ...


class _IReturnJsii976Proxy:
    '''Returns a subclass of a known class which implements an interface.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IReturnJsii976"

    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "foo"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IReturnJsii976).__jsii_proxy_class__ = lambda : _IReturnJsii976Proxy


@jsii.interface(jsii_type="jsii-calc.IReturnsNumber")
class IReturnsNumber(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="numberProp")
    def number_prop(self) -> _scope_jsii_calc_lib_c61f082f.Number:
        ...

    @jsii.member(jsii_name="obtainNumber")
    def obtain_number(self) -> _scope_jsii_calc_lib_c61f082f.IDoublable:
        ...


class _IReturnsNumberProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IReturnsNumber"

    @builtins.property
    @jsii.member(jsii_name="numberProp")
    def number_prop(self) -> _scope_jsii_calc_lib_c61f082f.Number:
        return typing.cast(_scope_jsii_calc_lib_c61f082f.Number, jsii.get(self, "numberProp"))

    @jsii.member(jsii_name="obtainNumber")
    def obtain_number(self) -> _scope_jsii_calc_lib_c61f082f.IDoublable:
        return typing.cast(_scope_jsii_calc_lib_c61f082f.IDoublable, jsii.invoke(self, "obtainNumber", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IReturnsNumber).__jsii_proxy_class__ = lambda : _IReturnsNumberProxy


@jsii.interface(jsii_type="jsii-calc.IStableInterface")
class IStableInterface(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        ...

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        ...

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        ...


class _IStableInterfaceProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IStableInterface"

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "method", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IStableInterface).__jsii_proxy_class__ = lambda : _IStableInterfaceProxy


@jsii.interface(jsii_type="jsii-calc.IStructReturningDelegate")
class IStructReturningDelegate(typing_extensions.Protocol):
    '''Verifies that a "pure" implementation of an interface works correctly.'''

    @jsii.member(jsii_name="returnStruct")
    def return_struct(self) -> "StructB":
        ...


class _IStructReturningDelegateProxy:
    '''Verifies that a "pure" implementation of an interface works correctly.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IStructReturningDelegate"

    @jsii.member(jsii_name="returnStruct")
    def return_struct(self) -> "StructB":
        return typing.cast("StructB", jsii.invoke(self, "returnStruct", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IStructReturningDelegate).__jsii_proxy_class__ = lambda : _IStructReturningDelegateProxy


@jsii.interface(jsii_type="jsii-calc.IWallClock")
class IWallClock(typing_extensions.Protocol):
    '''Implement this interface.'''

    @jsii.member(jsii_name="iso8601Now")
    def iso8601_now(self) -> builtins.str:
        '''Returns the current time, formatted as an ISO-8601 string.'''
        ...


class _IWallClockProxy:
    '''Implement this interface.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IWallClock"

    @jsii.member(jsii_name="iso8601Now")
    def iso8601_now(self) -> builtins.str:
        '''Returns the current time, formatted as an ISO-8601 string.'''
        return typing.cast(builtins.str, jsii.invoke(self, "iso8601Now", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IWallClock).__jsii_proxy_class__ = lambda : _IWallClockProxy


class ImplementInternalInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ImplementInternalInterface",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="prop")
    def prop(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prop"))

    @prop.setter
    def prop(self, value: builtins.str) -> None:
        jsii.set(self, "prop", value)


class Implementation(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Implementation"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "value"))


@jsii.implements(IInterfaceWithInternal)
class ImplementsInterfaceWithInternal(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ImplementsInterfaceWithInternal",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="visible")
    def visible(self) -> None:
        return typing.cast(None, jsii.invoke(self, "visible", []))


class ImplementsInterfaceWithInternalSubclass(
    ImplementsInterfaceWithInternal,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ImplementsInterfaceWithInternalSubclass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


class ImplementsPrivateInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ImplementsPrivateInterface",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="private")
    def private(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "private"))

    @private.setter
    def private(self, value: builtins.str) -> None:
        jsii.set(self, "private", value)


@jsii.data_type(
    jsii_type="jsii-calc.ImplictBaseOfBase",
    jsii_struct_bases=[_scope_jsii_calc_base_734f0262.BaseProps],
    name_mapping={"foo": "foo", "bar": "bar", "goo": "goo"},
)
class ImplictBaseOfBase(_scope_jsii_calc_base_734f0262.BaseProps):
    def __init__(
        self,
        *,
        foo: _scope_jsii_calc_base_of_base_49fa37fe.Very,
        bar: builtins.str,
        goo: datetime.datetime,
    ) -> None:
        '''
        :param foo: -
        :param bar: -
        :param goo: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
            "bar": bar,
            "goo": goo,
        }

    @builtins.property
    def foo(self) -> _scope_jsii_calc_base_of_base_49fa37fe.Very:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(_scope_jsii_calc_base_of_base_49fa37fe.Very, result)

    @builtins.property
    def bar(self) -> builtins.str:
        result = self._values.get("bar")
        assert result is not None, "Required property 'bar' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def goo(self) -> datetime.datetime:
        result = self._values.get("goo")
        assert result is not None, "Required property 'goo' is missing"
        return typing.cast(datetime.datetime, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ImplictBaseOfBase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InterfaceCollections(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.InterfaceCollections",
):
    '''Verifies that collections of interfaces or structs are correctly handled.

    See: https://github.com/aws/jsii/issues/1196
    '''

    @jsii.member(jsii_name="listOfInterfaces")
    @builtins.classmethod
    def list_of_interfaces(cls) -> typing.List[IBell]:
        return typing.cast(typing.List[IBell], jsii.sinvoke(cls, "listOfInterfaces", []))

    @jsii.member(jsii_name="listOfStructs")
    @builtins.classmethod
    def list_of_structs(cls) -> typing.List["StructA"]:
        return typing.cast(typing.List["StructA"], jsii.sinvoke(cls, "listOfStructs", []))

    @jsii.member(jsii_name="mapOfInterfaces")
    @builtins.classmethod
    def map_of_interfaces(cls) -> typing.Mapping[builtins.str, IBell]:
        return typing.cast(typing.Mapping[builtins.str, IBell], jsii.sinvoke(cls, "mapOfInterfaces", []))

    @jsii.member(jsii_name="mapOfStructs")
    @builtins.classmethod
    def map_of_structs(cls) -> typing.Mapping[builtins.str, "StructA"]:
        return typing.cast(typing.Mapping[builtins.str, "StructA"], jsii.sinvoke(cls, "mapOfStructs", []))


class InterfacesMaker(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.InterfacesMaker"):
    '''We can return arrays of interfaces See aws/aws-cdk#2362.'''

    @jsii.member(jsii_name="makeInterfaces")
    @builtins.classmethod
    def make_interfaces(
        cls,
        count: jsii.Number,
    ) -> typing.List[_scope_jsii_calc_lib_c61f082f.IDoublable]:
        '''
        :param count: -
        '''
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.IDoublable], jsii.sinvoke(cls, "makeInterfaces", [count]))


class Isomorphism(metaclass=jsii.JSIIAbstractClass, jsii_type="jsii-calc.Isomorphism"):
    '''Checks the "same instance" isomorphism is preserved within the constructor.

    Create a subclass of this, and assert that \`\`this.myself()\`\` actually returns
    \`\`this\`\` from within the constructor.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="myself")
    def myself(self) -> "Isomorphism":
        return typing.cast("Isomorphism", jsii.invoke(self, "myself", []))


class _IsomorphismProxy(Isomorphism):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Isomorphism).__jsii_proxy_class__ = lambda : _IsomorphismProxy


class Issue2638(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Issue2638"):
    '''Docstrings with period.

    :see: https://github.com/aws/jsii/issues/2638
    '''

    def __init__(self) -> None:
        '''First sentence.

        Second sentence. Third sentence.
        '''
        jsii.create(self.__class__, self, [])


class Issue2638B(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Issue2638B"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


class JSII417PublicBaseOfBase(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JSII417PublicBaseOfBase",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="makeInstance")
    @builtins.classmethod
    def make_instance(cls) -> "JSII417PublicBaseOfBase":
        return typing.cast("JSII417PublicBaseOfBase", jsii.sinvoke(cls, "makeInstance", []))

    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "foo", []))

    @builtins.property
    @jsii.member(jsii_name="hasRoot")
    def has_root(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "hasRoot"))


class JSObjectLiteralForInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JSObjectLiteralForInterface",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="giveMeFriendly")
    def give_me_friendly(self) -> _scope_jsii_calc_lib_c61f082f.IFriendly:
        return typing.cast(_scope_jsii_calc_lib_c61f082f.IFriendly, jsii.invoke(self, "giveMeFriendly", []))

    @jsii.member(jsii_name="giveMeFriendlyGenerator")
    def give_me_friendly_generator(self) -> "IFriendlyRandomGenerator":
        return typing.cast("IFriendlyRandomGenerator", jsii.invoke(self, "giveMeFriendlyGenerator", []))


class JSObjectLiteralToNative(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JSObjectLiteralToNative",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="returnLiteral")
    def return_literal(self) -> "JSObjectLiteralToNativeClass":
        return typing.cast("JSObjectLiteralToNativeClass", jsii.invoke(self, "returnLiteral", []))


class JSObjectLiteralToNativeClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JSObjectLiteralToNativeClass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="propA")
    def prop_a(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "propA"))

    @prop_a.setter
    def prop_a(self, value: builtins.str) -> None:
        jsii.set(self, "propA", value)

    @builtins.property
    @jsii.member(jsii_name="propB")
    def prop_b(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "propB"))

    @prop_b.setter
    def prop_b(self, value: jsii.Number) -> None:
        jsii.set(self, "propB", value)


class JavaReservedWords(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JavaReservedWords",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="abstract")
    def abstract(self) -> None:
        return typing.cast(None, jsii.invoke(self, "abstract", []))

    @jsii.member(jsii_name="assert")
    def assert_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "assert", []))

    @jsii.member(jsii_name="boolean")
    def boolean(self) -> None:
        return typing.cast(None, jsii.invoke(self, "boolean", []))

    @jsii.member(jsii_name="break")
    def break_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "break", []))

    @jsii.member(jsii_name="byte")
    def byte(self) -> None:
        return typing.cast(None, jsii.invoke(self, "byte", []))

    @jsii.member(jsii_name="case")
    def case(self) -> None:
        return typing.cast(None, jsii.invoke(self, "case", []))

    @jsii.member(jsii_name="catch")
    def catch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "catch", []))

    @jsii.member(jsii_name="char")
    def char(self) -> None:
        return typing.cast(None, jsii.invoke(self, "char", []))

    @jsii.member(jsii_name="class")
    def class_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "class", []))

    @jsii.member(jsii_name="const")
    def const(self) -> None:
        return typing.cast(None, jsii.invoke(self, "const", []))

    @jsii.member(jsii_name="continue")
    def continue_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "continue", []))

    @jsii.member(jsii_name="default")
    def default(self) -> None:
        return typing.cast(None, jsii.invoke(self, "default", []))

    @jsii.member(jsii_name="do")
    def do(self) -> None:
        return typing.cast(None, jsii.invoke(self, "do", []))

    @jsii.member(jsii_name="double")
    def double(self) -> None:
        return typing.cast(None, jsii.invoke(self, "double", []))

    @jsii.member(jsii_name="else")
    def else_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "else", []))

    @jsii.member(jsii_name="enum")
    def enum(self) -> None:
        return typing.cast(None, jsii.invoke(self, "enum", []))

    @jsii.member(jsii_name="extends")
    def extends(self) -> None:
        return typing.cast(None, jsii.invoke(self, "extends", []))

    @jsii.member(jsii_name="false")
    def false(self) -> None:
        return typing.cast(None, jsii.invoke(self, "false", []))

    @jsii.member(jsii_name="final")
    def final(self) -> None:
        return typing.cast(None, jsii.invoke(self, "final", []))

    @jsii.member(jsii_name="finally")
    def finally_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "finally", []))

    @jsii.member(jsii_name="float")
    def float(self) -> None:
        return typing.cast(None, jsii.invoke(self, "float", []))

    @jsii.member(jsii_name="for")
    def for_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "for", []))

    @jsii.member(jsii_name="goto")
    def goto(self) -> None:
        return typing.cast(None, jsii.invoke(self, "goto", []))

    @jsii.member(jsii_name="if")
    def if_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "if", []))

    @jsii.member(jsii_name="implements")
    def implements(self) -> None:
        return typing.cast(None, jsii.invoke(self, "implements", []))

    @jsii.member(jsii_name="import")
    def import_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "import", []))

    @jsii.member(jsii_name="instanceof")
    def instanceof(self) -> None:
        return typing.cast(None, jsii.invoke(self, "instanceof", []))

    @jsii.member(jsii_name="int")
    def int(self) -> None:
        return typing.cast(None, jsii.invoke(self, "int", []))

    @jsii.member(jsii_name="interface")
    def interface(self) -> None:
        return typing.cast(None, jsii.invoke(self, "interface", []))

    @jsii.member(jsii_name="long")
    def long(self) -> None:
        return typing.cast(None, jsii.invoke(self, "long", []))

    @jsii.member(jsii_name="native")
    def native(self) -> None:
        return typing.cast(None, jsii.invoke(self, "native", []))

    @jsii.member(jsii_name="new")
    def new(self) -> None:
        return typing.cast(None, jsii.invoke(self, "new", []))

    @jsii.member(jsii_name="null")
    def null(self) -> None:
        return typing.cast(None, jsii.invoke(self, "null", []))

    @jsii.member(jsii_name="package")
    def package(self) -> None:
        return typing.cast(None, jsii.invoke(self, "package", []))

    @jsii.member(jsii_name="private")
    def private(self) -> None:
        return typing.cast(None, jsii.invoke(self, "private", []))

    @jsii.member(jsii_name="protected")
    def protected(self) -> None:
        return typing.cast(None, jsii.invoke(self, "protected", []))

    @jsii.member(jsii_name="public")
    def public(self) -> None:
        return typing.cast(None, jsii.invoke(self, "public", []))

    @jsii.member(jsii_name="return")
    def return_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "return", []))

    @jsii.member(jsii_name="short")
    def short(self) -> None:
        return typing.cast(None, jsii.invoke(self, "short", []))

    @jsii.member(jsii_name="static")
    def static(self) -> None:
        return typing.cast(None, jsii.invoke(self, "static", []))

    @jsii.member(jsii_name="strictfp")
    def strictfp(self) -> None:
        return typing.cast(None, jsii.invoke(self, "strictfp", []))

    @jsii.member(jsii_name="super")
    def super(self) -> None:
        return typing.cast(None, jsii.invoke(self, "super", []))

    @jsii.member(jsii_name="switch")
    def switch(self) -> None:
        return typing.cast(None, jsii.invoke(self, "switch", []))

    @jsii.member(jsii_name="synchronized")
    def synchronized(self) -> None:
        return typing.cast(None, jsii.invoke(self, "synchronized", []))

    @jsii.member(jsii_name="this")
    def this(self) -> None:
        return typing.cast(None, jsii.invoke(self, "this", []))

    @jsii.member(jsii_name="throw")
    def throw(self) -> None:
        return typing.cast(None, jsii.invoke(self, "throw", []))

    @jsii.member(jsii_name="throws")
    def throws(self) -> None:
        return typing.cast(None, jsii.invoke(self, "throws", []))

    @jsii.member(jsii_name="transient")
    def transient(self) -> None:
        return typing.cast(None, jsii.invoke(self, "transient", []))

    @jsii.member(jsii_name="true")
    def true(self) -> None:
        return typing.cast(None, jsii.invoke(self, "true", []))

    @jsii.member(jsii_name="try")
    def try_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "try", []))

    @jsii.member(jsii_name="void")
    def void(self) -> None:
        return typing.cast(None, jsii.invoke(self, "void", []))

    @jsii.member(jsii_name="volatile")
    def volatile(self) -> None:
        return typing.cast(None, jsii.invoke(self, "volatile", []))

    @builtins.property
    @jsii.member(jsii_name="while")
    def while_(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "while"))

    @while_.setter
    def while_(self, value: builtins.str) -> None:
        jsii.set(self, "while", value)


@jsii.implements(IJsii487External2, IJsii487External)
class Jsii487Derived(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Jsii487Derived"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


@jsii.implements(IJsii496)
class Jsii496Derived(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Jsii496Derived"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


class JsiiAgent(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.JsiiAgent"):
    '''Host runtime version should be set via JSII_AGENT.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="value")
    def value(cls) -> typing.Optional[builtins.str]:
        '''Returns the value of the JSII_AGENT environment variable.'''
        return typing.cast(typing.Optional[builtins.str], jsii.sget(cls, "value"))


class JsonFormatter(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.JsonFormatter"):
    '''Make sure structs are un-decorated on the way in.

    :see: https://github.com/aws/aws-cdk/issues/5066
    '''

    @jsii.member(jsii_name="anyArray")
    @builtins.classmethod
    def any_array(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyArray", []))

    @jsii.member(jsii_name="anyBooleanFalse")
    @builtins.classmethod
    def any_boolean_false(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyBooleanFalse", []))

    @jsii.member(jsii_name="anyBooleanTrue")
    @builtins.classmethod
    def any_boolean_true(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyBooleanTrue", []))

    @jsii.member(jsii_name="anyDate")
    @builtins.classmethod
    def any_date(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyDate", []))

    @jsii.member(jsii_name="anyEmptyString")
    @builtins.classmethod
    def any_empty_string(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyEmptyString", []))

    @jsii.member(jsii_name="anyFunction")
    @builtins.classmethod
    def any_function(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyFunction", []))

    @jsii.member(jsii_name="anyHash")
    @builtins.classmethod
    def any_hash(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyHash", []))

    @jsii.member(jsii_name="anyNull")
    @builtins.classmethod
    def any_null(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyNull", []))

    @jsii.member(jsii_name="anyNumber")
    @builtins.classmethod
    def any_number(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyNumber", []))

    @jsii.member(jsii_name="anyRef")
    @builtins.classmethod
    def any_ref(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyRef", []))

    @jsii.member(jsii_name="anyString")
    @builtins.classmethod
    def any_string(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyString", []))

    @jsii.member(jsii_name="anyUndefined")
    @builtins.classmethod
    def any_undefined(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyUndefined", []))

    @jsii.member(jsii_name="anyZero")
    @builtins.classmethod
    def any_zero(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "anyZero", []))

    @jsii.member(jsii_name="stringify")
    @builtins.classmethod
    def stringify(cls, value: typing.Any = None) -> typing.Optional[builtins.str]:
        '''
        :param value: -
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.sinvoke(cls, "stringify", [value]))


class LevelOne(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.LevelOne"):
    '''Validates that nested classes get correct code generation for the occasional forward reference.'''

    def __init__(
        self,
        *,
        prop: typing.Union["LevelOne.PropProperty", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param prop: 
        '''
        props = LevelOneProps(prop=prop)

        jsii.create(self.__class__, self, [props])

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "LevelOneProps":
        return typing.cast("LevelOneProps", jsii.get(self, "props"))

    @jsii.data_type(
        jsii_type="jsii-calc.LevelOne.PropBooleanValue",
        jsii_struct_bases=[],
        name_mapping={"value": "value"},
    )
    class PropBooleanValue:
        def __init__(self, *, value: builtins.bool) -> None:
            '''
            :param value: 
            '''
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "value": value,
            }

        @builtins.property
        def value(self) -> builtins.bool:
            result = self._values.get("value")
            assert result is not None, "Required property 'value' is missing"
            return typing.cast(builtins.bool, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PropBooleanValue(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="jsii-calc.LevelOne.PropProperty",
        jsii_struct_bases=[],
        name_mapping={"prop": "prop"},
    )
    class PropProperty:
        def __init__(
            self,
            *,
            prop: typing.Union["LevelOne.PropBooleanValue", typing.Dict[builtins.str, typing.Any]],
        ) -> None:
            '''
            :param prop: 
            '''
            if isinstance(prop, dict):
                prop = LevelOne.PropBooleanValue(**prop)
            self._values: typing.Dict[builtins.str, typing.Any] = {
                "prop": prop,
            }

        @builtins.property
        def prop(self) -> "LevelOne.PropBooleanValue":
            result = self._values.get("prop")
            assert result is not None, "Required property 'prop' is missing"
            return typing.cast("LevelOne.PropBooleanValue", result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PropProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="jsii-calc.LevelOneProps",
    jsii_struct_bases=[],
    name_mapping={"prop": "prop"},
)
class LevelOneProps:
    def __init__(
        self,
        *,
        prop: typing.Union[LevelOne.PropProperty, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param prop: 
        '''
        if isinstance(prop, dict):
            prop = LevelOne.PropProperty(**prop)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "prop": prop,
        }

    @builtins.property
    def prop(self) -> LevelOne.PropProperty:
        result = self._values.get("prop")
        assert result is not None, "Required property 'prop' is missing"
        return typing.cast(LevelOne.PropProperty, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LevelOneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.LoadBalancedFargateServiceProps",
    jsii_struct_bases=[],
    name_mapping={
        "container_port": "containerPort",
        "cpu": "cpu",
        "memory_mib": "memoryMiB",
        "public_load_balancer": "publicLoadBalancer",
        "public_tasks": "publicTasks",
    },
)
class LoadBalancedFargateServiceProps:
    def __init__(
        self,
        *,
        container_port: typing.Optional[jsii.Number] = None,
        cpu: typing.Optional[builtins.str] = None,
        memory_mib: typing.Optional[builtins.str] = None,
        public_load_balancer: typing.Optional[builtins.bool] = None,
        public_tasks: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''jsii#298: show default values in sphinx documentation, and respect newlines.

        :param container_port: The container port of the application load balancer attached to your Fargate service. Corresponds to container port mapping. Default: 80
        :param cpu: The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256
        :param memory_mib: The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU) 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU) 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU) Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU) Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512
        :param public_load_balancer: Determines whether the Application Load Balancer will be internet-facing. Default: true
        :param public_tasks: Determines whether your Fargate Service will be assigned a public IP address. Default: false
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_port is not None:
            self._values["container_port"] = container_port
        if cpu is not None:
            self._values["cpu"] = cpu
        if memory_mib is not None:
            self._values["memory_mib"] = memory_mib
        if public_load_balancer is not None:
            self._values["public_load_balancer"] = public_load_balancer
        if public_tasks is not None:
            self._values["public_tasks"] = public_tasks

    @builtins.property
    def container_port(self) -> typing.Optional[jsii.Number]:
        '''The container port of the application load balancer attached to your Fargate service.

        Corresponds to container port mapping.

        :default: 80
        '''
        result = self._values.get("container_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def cpu(self) -> typing.Optional[builtins.str]:
        '''The number of cpu units used by the task.

        Valid values, which determines your range of valid values for the memory parameter:
        256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB
        512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB
        1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB
        2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments
        4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments

        This default is set in the underlying FargateTaskDefinition construct.

        :default: 256
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_mib(self) -> typing.Optional[builtins.str]:
        '''The amount (in MiB) of memory used by the task.

        This field is required and you must use one of the following values, which determines your range of valid values
        for the cpu parameter:

        0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU)

        1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU)

        2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU)

        Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU)

        Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU)

        This default is set in the underlying FargateTaskDefinition construct.

        :default: 512
        '''
        result = self._values.get("memory_mib")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_load_balancer(self) -> typing.Optional[builtins.bool]:
        '''Determines whether the Application Load Balancer will be internet-facing.

        :default: true
        '''
        result = self._values.get("public_load_balancer")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def public_tasks(self) -> typing.Optional[builtins.bool]:
        '''Determines whether your Fargate Service will be assigned a public IP address.

        :default: false
        '''
        result = self._values.get("public_tasks")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LoadBalancedFargateServiceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MethodNamedProperty(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.MethodNamedProperty",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "property", []))

    @builtins.property
    @jsii.member(jsii_name="elite")
    def elite(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "elite"))


@jsii.implements(IFriendlier, IRandomNumberGenerator)
class Multiply(
    BinaryOperation,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.Multiply",
):
    '''The "*" binary operation.'''

    def __init__(
        self,
        lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
        rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
    ) -> None:
        '''Creates a BinaryOperation.

        :param lhs: Left-hand side operand.
        :param rhs: Right-hand side operand.
        '''
        jsii.create(self.__class__, self, [lhs, rhs])

    @jsii.member(jsii_name="farewell")
    def farewell(self) -> builtins.str:
        '''Say farewell.'''
        return typing.cast(builtins.str, jsii.invoke(self, "farewell", []))

    @jsii.member(jsii_name="goodbye")
    def goodbye(self) -> builtins.str:
        '''Say goodbye.'''
        return typing.cast(builtins.str, jsii.invoke(self, "goodbye", []))

    @jsii.member(jsii_name="next")
    def next(self) -> jsii.Number:
        '''Returns another random number.'''
        return typing.cast(jsii.Number, jsii.invoke(self, "next", []))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''String representation of the value.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''The value.'''
        return typing.cast(jsii.Number, jsii.get(self, "value"))


class NestedClassInstance(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.NestedClassInstance",
):
    @jsii.member(jsii_name="makeInstance")
    @builtins.classmethod
    def make_instance(
        cls,
    ) -> _scope_jsii_calc_lib_custom_submodule_name_c61f082f.NestingClass.NestedClass:
        return typing.cast(_scope_jsii_calc_lib_custom_submodule_name_c61f082f.NestingClass.NestedClass, jsii.sinvoke(cls, "makeInstance", []))


@jsii.data_type(
    jsii_type="jsii-calc.NestedStruct",
    jsii_struct_bases=[],
    name_mapping={"number_prop": "numberProp"},
)
class NestedStruct:
    def __init__(self, *, number_prop: jsii.Number) -> None:
        '''
        :param number_prop: When provided, must be > 0.
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "number_prop": number_prop,
        }

    @builtins.property
    def number_prop(self) -> jsii.Number:
        '''When provided, must be > 0.'''
        result = self._values.get("number_prop")
        assert result is not None, "Required property 'number_prop' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NestedStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NodeStandardLibrary(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.NodeStandardLibrary",
):
    '''Test fixture to verify that jsii modules can use the node standard library.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="cryptoSha256")
    def crypto_sha256(self) -> builtins.str:
        '''Uses node.js "crypto" module to calculate sha256 of a string.

        :return: "6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50"
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "cryptoSha256", []))

    @jsii.member(jsii_name="fsReadFile")
    def fs_read_file(self) -> builtins.str:
        '''Reads a local resource file (resource.txt) asynchronously.

        :return: "Hello, resource!"
        '''
        return typing.cast(builtins.str, jsii.ainvoke(self, "fsReadFile", []))

    @jsii.member(jsii_name="fsReadFileSync")
    def fs_read_file_sync(self) -> builtins.str:
        '''Sync version of fsReadFile.

        :return: "Hello, resource! SYNC!"
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "fsReadFileSync", []))

    @builtins.property
    @jsii.member(jsii_name="osPlatform")
    def os_platform(self) -> builtins.str:
        '''Returns the current os.platform() from the "os" node module.'''
        return typing.cast(builtins.str, jsii.get(self, "osPlatform"))


class NullShouldBeTreatedAsUndefined(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.NullShouldBeTreatedAsUndefined",
):
    '''jsii#282, aws-cdk#157: null should be treated as "undefined".'''

    def __init__(self, _param1: builtins.str, optional: typing.Any = None) -> None:
        '''
        :param _param1: -
        :param optional: -
        '''
        jsii.create(self.__class__, self, [_param1, optional])

    @jsii.member(jsii_name="giveMeUndefined")
    def give_me_undefined(self, value: typing.Any = None) -> None:
        '''
        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "giveMeUndefined", [value]))

    @jsii.member(jsii_name="giveMeUndefinedInsideAnObject")
    def give_me_undefined_inside_an_object(
        self,
        *,
        array_with_three_elements_and_undefined_as_second_argument: typing.Sequence[typing.Any],
        this_should_be_undefined: typing.Any = None,
    ) -> None:
        '''
        :param array_with_three_elements_and_undefined_as_second_argument: 
        :param this_should_be_undefined: 
        '''
        input = NullShouldBeTreatedAsUndefinedData(
            array_with_three_elements_and_undefined_as_second_argument=array_with_three_elements_and_undefined_as_second_argument,
            this_should_be_undefined=this_should_be_undefined,
        )

        return typing.cast(None, jsii.invoke(self, "giveMeUndefinedInsideAnObject", [input]))

    @jsii.member(jsii_name="verifyPropertyIsUndefined")
    def verify_property_is_undefined(self) -> None:
        return typing.cast(None, jsii.invoke(self, "verifyPropertyIsUndefined", []))

    @builtins.property
    @jsii.member(jsii_name="changeMeToUndefined")
    def change_me_to_undefined(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "changeMeToUndefined"))

    @change_me_to_undefined.setter
    def change_me_to_undefined(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "changeMeToUndefined", value)


@jsii.data_type(
    jsii_type="jsii-calc.NullShouldBeTreatedAsUndefinedData",
    jsii_struct_bases=[],
    name_mapping={
        "array_with_three_elements_and_undefined_as_second_argument": "arrayWithThreeElementsAndUndefinedAsSecondArgument",
        "this_should_be_undefined": "thisShouldBeUndefined",
    },
)
class NullShouldBeTreatedAsUndefinedData:
    def __init__(
        self,
        *,
        array_with_three_elements_and_undefined_as_second_argument: typing.Sequence[typing.Any],
        this_should_be_undefined: typing.Any = None,
    ) -> None:
        '''
        :param array_with_three_elements_and_undefined_as_second_argument: 
        :param this_should_be_undefined: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "array_with_three_elements_and_undefined_as_second_argument": array_with_three_elements_and_undefined_as_second_argument,
        }
        if this_should_be_undefined is not None:
            self._values["this_should_be_undefined"] = this_should_be_undefined

    @builtins.property
    def array_with_three_elements_and_undefined_as_second_argument(
        self,
    ) -> typing.List[typing.Any]:
        result = self._values.get("array_with_three_elements_and_undefined_as_second_argument")
        assert result is not None, "Required property 'array_with_three_elements_and_undefined_as_second_argument' is missing"
        return typing.cast(typing.List[typing.Any], result)

    @builtins.property
    def this_should_be_undefined(self) -> typing.Any:
        result = self._values.get("this_should_be_undefined")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NullShouldBeTreatedAsUndefinedData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NumberGenerator(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.NumberGenerator"):
    '''This allows us to test that a reference can be stored for objects that implement interfaces.'''

    def __init__(self, generator: IRandomNumberGenerator) -> None:
        '''
        :param generator: -
        '''
        jsii.create(self.__class__, self, [generator])

    @jsii.member(jsii_name="isSameGenerator")
    def is_same_generator(self, gen: IRandomNumberGenerator) -> builtins.bool:
        '''
        :param gen: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "isSameGenerator", [gen]))

    @jsii.member(jsii_name="nextTimes100")
    def next_times100(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "nextTimes100", []))

    @builtins.property
    @jsii.member(jsii_name="generator")
    def generator(self) -> IRandomNumberGenerator:
        return typing.cast(IRandomNumberGenerator, jsii.get(self, "generator"))

    @generator.setter
    def generator(self, value: IRandomNumberGenerator) -> None:
        jsii.set(self, "generator", value)


class ObjectRefsInCollections(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ObjectRefsInCollections",
):
    '''Verify that object references can be passed inside collections.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sumFromArray")
    def sum_from_array(
        self,
        values: typing.Sequence[_scope_jsii_calc_lib_c61f082f.NumericValue],
    ) -> jsii.Number:
        '''Returns the sum of all values.

        :param values: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "sumFromArray", [values]))

    @jsii.member(jsii_name="sumFromMap")
    def sum_from_map(
        self,
        values: typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue],
    ) -> jsii.Number:
        '''Returns the sum of all values in a map.

        :param values: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "sumFromMap", [values]))


class ObjectWithPropertyProvider(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ObjectWithPropertyProvider",
):
    @jsii.member(jsii_name="provide")
    @builtins.classmethod
    def provide(cls) -> IObjectWithProperty:
        return typing.cast(IObjectWithProperty, jsii.sinvoke(cls, "provide", []))


class Old(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Old"):
    '''(deprecated) Old class.

    :deprecated:

    Use the new class or the old class whatever you want because
    whatever you like is always the best

    :stability: deprecated
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="doAThing")
    def do_a_thing(self) -> None:
        '''(deprecated) Doo wop that thing.

        :stability: deprecated
        '''
        return typing.cast(None, jsii.invoke(self, "doAThing", []))


class OptionalArgumentInvoker(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.OptionalArgumentInvoker",
):
    def __init__(self, delegate: IInterfaceWithOptionalMethodArguments) -> None:
        '''
        :param delegate: -
        '''
        jsii.create(self.__class__, self, [delegate])

    @jsii.member(jsii_name="invokeWithOptional")
    def invoke_with_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "invokeWithOptional", []))

    @jsii.member(jsii_name="invokeWithoutOptional")
    def invoke_without_optional(self) -> None:
        return typing.cast(None, jsii.invoke(self, "invokeWithoutOptional", []))


class OptionalConstructorArgument(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.OptionalConstructorArgument",
):
    def __init__(
        self,
        arg1: jsii.Number,
        arg2: builtins.str,
        arg3: typing.Optional[datetime.datetime] = None,
    ) -> None:
        '''
        :param arg1: -
        :param arg2: -
        :param arg3: -
        '''
        jsii.create(self.__class__, self, [arg1, arg2, arg3])

    @builtins.property
    @jsii.member(jsii_name="arg1")
    def arg1(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "arg1"))

    @builtins.property
    @jsii.member(jsii_name="arg2")
    def arg2(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "arg2"))

    @builtins.property
    @jsii.member(jsii_name="arg3")
    def arg3(self) -> typing.Optional[datetime.datetime]:
        return typing.cast(typing.Optional[datetime.datetime], jsii.get(self, "arg3"))


@jsii.data_type(
    jsii_type="jsii-calc.OptionalStruct",
    jsii_struct_bases=[],
    name_mapping={"field": "field"},
)
class OptionalStruct:
    def __init__(self, *, field: typing.Optional[builtins.str] = None) -> None:
        '''
        :param field: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if field is not None:
            self._values["field"] = field

    @builtins.property
    def field(self) -> typing.Optional[builtins.str]:
        result = self._values.get("field")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OptionalStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OptionalStructConsumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.OptionalStructConsumer",
):
    def __init__(self, *, field: typing.Optional[builtins.str] = None) -> None:
        '''
        :param field: 
        '''
        optional_struct = OptionalStruct(field=field)

        jsii.create(self.__class__, self, [optional_struct])

    @builtins.property
    @jsii.member(jsii_name="parameterWasUndefined")
    def parameter_was_undefined(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "parameterWasUndefined"))

    @builtins.property
    @jsii.member(jsii_name="fieldValue")
    def field_value(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "fieldValue"))


class OverridableProtectedMember(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.OverridableProtectedMember",
):
    '''
    :see: https://github.com/aws/jsii/issues/903
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="overrideMe")
    def _override_me(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "overrideMe", []))

    @jsii.member(jsii_name="switchModes")
    def switch_modes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "switchModes", []))

    @jsii.member(jsii_name="valueFromProtected")
    def value_from_protected(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "valueFromProtected", []))

    @builtins.property
    @jsii.member(jsii_name="overrideReadOnly")
    def _override_read_only(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "overrideReadOnly"))

    @builtins.property
    @jsii.member(jsii_name="overrideReadWrite")
    def _override_read_write(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "overrideReadWrite"))

    @_override_read_write.setter
    def _override_read_write(self, value: builtins.str) -> None:
        jsii.set(self, "overrideReadWrite", value)


class OverrideReturnsObject(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.OverrideReturnsObject",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="test")
    def test(self, obj: IReturnsNumber) -> jsii.Number:
        '''
        :param obj: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "test", [obj]))


class ParamShadowsBuiltins(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ParamShadowsBuiltins",
):
    '''Validate that parameters named "str" or "builtins" do not shadow the actual type names in Python.'''

    def __init__(
        self,
        builtins: builtins.str,
        str: builtins.str,
        *,
        boolean_property: builtins.bool,
        string_property: builtins.str,
        struct_property: typing.Union["StructA", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param builtins: should be set to something that is NOT a valid expression in Python (e.g: "\${NOPE}"").
        :param str: should be set to something that is NOT a valid expression in Python (e.g: "\${NOPE}"").
        :param boolean_property: 
        :param string_property: 
        :param struct_property: 
        '''
        props = ParamShadowsBuiltinsProps(
            boolean_property=boolean_property,
            string_property=string_property,
            struct_property=struct_property,
        )

        jsii.create(self.__class__, self, [builtins, str, props])


@jsii.data_type(
    jsii_type="jsii-calc.ParamShadowsBuiltinsProps",
    jsii_struct_bases=[],
    name_mapping={
        "boolean_property": "booleanProperty",
        "string_property": "stringProperty",
        "struct_property": "structProperty",
    },
)
class ParamShadowsBuiltinsProps:
    def __init__(
        self,
        *,
        boolean_property: builtins.bool,
        string_property: builtins.str,
        struct_property: typing.Union["StructA", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param boolean_property: 
        :param string_property: 
        :param struct_property: 
        '''
        if isinstance(struct_property, dict):
            struct_property = StructA(**struct_property)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "boolean_property": boolean_property,
            "string_property": string_property,
            "struct_property": struct_property,
        }

    @builtins.property
    def boolean_property(self) -> builtins.bool:
        result = self._values.get("boolean_property")
        assert result is not None, "Required property 'boolean_property' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def string_property(self) -> builtins.str:
        result = self._values.get("string_property")
        assert result is not None, "Required property 'string_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def struct_property(self) -> "StructA":
        result = self._values.get("struct_property")
        assert result is not None, "Required property 'struct_property' is missing"
        return typing.cast("StructA", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParamShadowsBuiltinsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ParamShadowsScope(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ParamShadowsScope",
):
    '''Validate that namespaces being shadowed by local variables does not cause type checking issues.

    :see: https://github.com/aws/aws-cdk/issues/22975
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="useScope")
    def use_scope(
        self,
        scope: _scope_jsii_calc_lib_c61f082f.Number,
    ) -> _scope_jsii_calc_lib_c61f082f.Number:
        '''
        :param scope: -
        '''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.Number, jsii.invoke(self, "useScope", [scope]))


@jsii.data_type(
    jsii_type="jsii-calc.ParentStruct982",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo"},
)
class ParentStruct982:
    def __init__(self, *, foo: builtins.str) -> None:
        '''https://github.com/aws/jsii/issues/982.

        :param foo: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }

    @builtins.property
    def foo(self) -> builtins.str:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParentStruct982(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PartiallyInitializedThisConsumer(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.PartiallyInitializedThisConsumer",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="consumePartiallyInitializedThis")
    @abc.abstractmethod
    def consume_partially_initialized_this(
        self,
        obj: ConstructorPassesThisOut,
        dt: datetime.datetime,
        ev: AllTypesEnum,
    ) -> builtins.str:
        '''
        :param obj: -
        :param dt: -
        :param ev: -
        '''
        ...


class _PartiallyInitializedThisConsumerProxy(PartiallyInitializedThisConsumer):
    @jsii.member(jsii_name="consumePartiallyInitializedThis")
    def consume_partially_initialized_this(
        self,
        obj: ConstructorPassesThisOut,
        dt: datetime.datetime,
        ev: AllTypesEnum,
    ) -> builtins.str:
        '''
        :param obj: -
        :param dt: -
        :param ev: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "consumePartiallyInitializedThis", [obj, dt, ev]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, PartiallyInitializedThisConsumer).__jsii_proxy_class__ = lambda : _PartiallyInitializedThisConsumerProxy


class Polymorphism(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Polymorphism"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sayHello")
    def say_hello(
        self,
        friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
    ) -> builtins.str:
        '''
        :param friendly: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "sayHello", [friendly]))


class Power(
    _CompositeOperation_1c4d123b,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.Power",
):
    '''The power operation.'''

    def __init__(
        self,
        base: _scope_jsii_calc_lib_c61f082f.NumericValue,
        pow: _scope_jsii_calc_lib_c61f082f.NumericValue,
    ) -> None:
        '''Creates a Power operation.

        :param base: The base of the power.
        :param pow: The number of times to multiply.
        '''
        jsii.create(self.__class__, self, [base, pow])

    @builtins.property
    @jsii.member(jsii_name="base")
    def base(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The base of the power.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "base"))

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The expression that this operation consists of.

        Must be implemented by derived classes.
        '''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "expression"))

    @builtins.property
    @jsii.member(jsii_name="pow")
    def pow(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The number of times to multiply.'''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "pow"))


class PromiseNothing(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.PromiseNothing"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="promiseIt")
    @builtins.classmethod
    def promise_it(cls) -> None:
        return typing.cast(None, jsii.sinvoke(cls, "promiseIt", []))

    @jsii.member(jsii_name="instancePromiseIt")
    def instance_promise_it(self) -> None:
        return typing.cast(None, jsii.ainvoke(self, "instancePromiseIt", []))


class PropertyNamedProperty(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.PropertyNamedProperty",
):
    '''Reproduction for https://github.com/aws/jsii/issues/1113 Where a method or property named "property" would result in impossible to load Python code.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))

    @builtins.property
    @jsii.member(jsii_name="yetAnoterOne")
    def yet_anoter_one(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "yetAnoterOne"))


class PublicClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.PublicClass"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="hello")
    def hello(self) -> None:
        return typing.cast(None, jsii.invoke(self, "hello", []))


class PythonReservedWords(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.PythonReservedWords",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="and")
    def and_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "and", []))

    @jsii.member(jsii_name="as")
    def as_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "as", []))

    @jsii.member(jsii_name="assert")
    def assert_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "assert", []))

    @jsii.member(jsii_name="async")
    def async_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "async", []))

    @jsii.member(jsii_name="await")
    def await_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "await", []))

    @jsii.member(jsii_name="break")
    def break_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "break", []))

    @jsii.member(jsii_name="class")
    def class_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "class", []))

    @jsii.member(jsii_name="continue")
    def continue_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "continue", []))

    @jsii.member(jsii_name="def")
    def def_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "def", []))

    @jsii.member(jsii_name="del")
    def del_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "del", []))

    @jsii.member(jsii_name="elif")
    def elif_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "elif", []))

    @jsii.member(jsii_name="else")
    def else_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "else", []))

    @jsii.member(jsii_name="except")
    def except_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "except", []))

    @jsii.member(jsii_name="finally")
    def finally_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "finally", []))

    @jsii.member(jsii_name="for")
    def for_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "for", []))

    @jsii.member(jsii_name="from")
    def from_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "from", []))

    @jsii.member(jsii_name="global")
    def global_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "global", []))

    @jsii.member(jsii_name="if")
    def if_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "if", []))

    @jsii.member(jsii_name="import")
    def import_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "import", []))

    @jsii.member(jsii_name="in")
    def in_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "in", []))

    @jsii.member(jsii_name="is")
    def is_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "is", []))

    @jsii.member(jsii_name="lambda")
    def lambda_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "lambda", []))

    @jsii.member(jsii_name="nonlocal")
    def nonlocal_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "nonlocal", []))

    @jsii.member(jsii_name="not")
    def not_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "not", []))

    @jsii.member(jsii_name="or")
    def or_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "or", []))

    @jsii.member(jsii_name="pass")
    def pass_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "pass", []))

    @jsii.member(jsii_name="raise")
    def raise_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "raise", []))

    @jsii.member(jsii_name="return")
    def return_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "return", []))

    @jsii.member(jsii_name="try")
    def try_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "try", []))

    @jsii.member(jsii_name="while")
    def while_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "while", []))

    @jsii.member(jsii_name="with")
    def with_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "with", []))

    @jsii.member(jsii_name="yield")
    def yield_(self) -> None:
        return typing.cast(None, jsii.invoke(self, "yield", []))


class ReferenceEnumFromScopedPackage(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ReferenceEnumFromScopedPackage",
):
    '''See awslabs/jsii#138.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="loadFoo")
    def load_foo(
        self,
    ) -> typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule]:
        return typing.cast(typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule], jsii.invoke(self, "loadFoo", []))

    @jsii.member(jsii_name="saveFoo")
    def save_foo(
        self,
        value: _scope_jsii_calc_lib_c61f082f.EnumFromScopedModule,
    ) -> None:
        '''
        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "saveFoo", [value]))

    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(
        self,
    ) -> typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule]:
        return typing.cast(typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule], jsii.get(self, "foo"))

    @foo.setter
    def foo(
        self,
        value: typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule],
    ) -> None:
        jsii.set(self, "foo", value)


class ReturnsPrivateImplementationOfInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ReturnsPrivateImplementationOfInterface",
):
    '''Helps ensure the JSII kernel & runtime cooperate correctly when an un-exported instance of a class is returned with a declared type that is an exported interface, and the instance inherits from an exported class.

    :return: an instance of an un-exported class that extends \`\`ExportedBaseClass\`\`, declared as \`\`IPrivatelyImplemented\`\`.

    :see: https://github.com/aws/jsii/issues/320
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="privateImplementation")
    def private_implementation(self) -> IPrivatelyImplemented:
        return typing.cast(IPrivatelyImplemented, jsii.get(self, "privateImplementation"))


@jsii.data_type(
    jsii_type="jsii-calc.RootStruct",
    jsii_struct_bases=[],
    name_mapping={"string_prop": "stringProp", "nested_struct": "nestedStruct"},
)
class RootStruct:
    def __init__(
        self,
        *,
        string_prop: builtins.str,
        nested_struct: typing.Optional[typing.Union[NestedStruct, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''This is here to check that we can pass a nested struct into a kwargs by specifying it as an in-line dictionary.

        This is cheating with the (current) declared types, but this is the "more
        idiomatic" way for Pythonists.

        :param string_prop: May not be empty.
        :param nested_struct: 
        '''
        if isinstance(nested_struct, dict):
            nested_struct = NestedStruct(**nested_struct)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "string_prop": string_prop,
        }
        if nested_struct is not None:
            self._values["nested_struct"] = nested_struct

    @builtins.property
    def string_prop(self) -> builtins.str:
        '''May not be empty.'''
        result = self._values.get("string_prop")
        assert result is not None, "Required property 'string_prop' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def nested_struct(self) -> typing.Optional[NestedStruct]:
        result = self._values.get("nested_struct")
        return typing.cast(typing.Optional[NestedStruct], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RootStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RootStructValidator(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.RootStructValidator",
):
    @jsii.member(jsii_name="validate")
    @builtins.classmethod
    def validate(
        cls,
        *,
        string_prop: builtins.str,
        nested_struct: typing.Optional[typing.Union[NestedStruct, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param string_prop: May not be empty.
        :param nested_struct: 
        '''
        struct = RootStruct(string_prop=string_prop, nested_struct=nested_struct)

        return typing.cast(None, jsii.sinvoke(cls, "validate", [struct]))


class RuntimeTypeChecking(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.RuntimeTypeChecking",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="methodWithDefaultedArguments")
    def method_with_defaulted_arguments(
        self,
        arg1: typing.Optional[jsii.Number] = None,
        arg2: typing.Optional[builtins.str] = None,
        arg3: typing.Optional[datetime.datetime] = None,
    ) -> None:
        '''
        :param arg1: -
        :param arg2: -
        :param arg3: -
        '''
        return typing.cast(None, jsii.invoke(self, "methodWithDefaultedArguments", [arg1, arg2, arg3]))

    @jsii.member(jsii_name="methodWithOptionalAnyArgument")
    def method_with_optional_any_argument(self, arg: typing.Any = None) -> None:
        '''
        :param arg: -
        '''
        return typing.cast(None, jsii.invoke(self, "methodWithOptionalAnyArgument", [arg]))

    @jsii.member(jsii_name="methodWithOptionalArguments")
    def method_with_optional_arguments(
        self,
        arg1: jsii.Number,
        arg2: builtins.str,
        arg3: typing.Optional[datetime.datetime] = None,
    ) -> None:
        '''Used to verify verification of number of method arguments.

        :param arg1: -
        :param arg2: -
        :param arg3: -
        '''
        return typing.cast(None, jsii.invoke(self, "methodWithOptionalArguments", [arg1, arg2, arg3]))


@jsii.data_type(
    jsii_type="jsii-calc.SecondLevelStruct",
    jsii_struct_bases=[],
    name_mapping={
        "deeper_required_prop": "deeperRequiredProp",
        "deeper_optional_prop": "deeperOptionalProp",
    },
)
class SecondLevelStruct:
    def __init__(
        self,
        *,
        deeper_required_prop: builtins.str,
        deeper_optional_prop: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param deeper_required_prop: It's long and required.
        :param deeper_optional_prop: It's long, but you'll almost never pass it.
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "deeper_required_prop": deeper_required_prop,
        }
        if deeper_optional_prop is not None:
            self._values["deeper_optional_prop"] = deeper_optional_prop

    @builtins.property
    def deeper_required_prop(self) -> builtins.str:
        '''It's long and required.'''
        result = self._values.get("deeper_required_prop")
        assert result is not None, "Required property 'deeper_required_prop' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deeper_optional_prop(self) -> typing.Optional[builtins.str]:
        '''It's long, but you'll almost never pass it.'''
        result = self._values.get("deeper_optional_prop")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecondLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SingleInstanceTwoTypes(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.SingleInstanceTwoTypes",
):
    '''Test that a single instance can be returned under two different FQNs.

    JSII clients can instantiate 2 different strongly-typed wrappers for the same
    object. Unfortunately, this will break object equality, but if we didn't do
    this it would break runtime type checks in the JVM or CLR.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="interface1")
    def interface1(self) -> "InbetweenClass":
        return typing.cast("InbetweenClass", jsii.invoke(self, "interface1", []))

    @jsii.member(jsii_name="interface2")
    def interface2(self) -> IPublicInterface:
        return typing.cast(IPublicInterface, jsii.invoke(self, "interface2", []))


class SingletonInt(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.SingletonInt"):
    '''Verifies that singleton enums are handled correctly.

    https://github.com/aws/jsii/issues/231
    '''

    @jsii.member(jsii_name="isSingletonInt")
    def is_singleton_int(self, value: jsii.Number) -> builtins.bool:
        '''
        :param value: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "isSingletonInt", [value]))


@jsii.enum(jsii_type="jsii-calc.SingletonIntEnum")
class SingletonIntEnum(enum.Enum):
    '''A singleton integer.'''

    SINGLETON_INT = "SINGLETON_INT"
    '''Elite!'''


class SingletonString(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.SingletonString"):
    '''Verifies that singleton enums are handled correctly.

    https://github.com/aws/jsii/issues/231
    '''

    @jsii.member(jsii_name="isSingletonString")
    def is_singleton_string(self, value: builtins.str) -> builtins.bool:
        '''
        :param value: -
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "isSingletonString", [value]))


@jsii.enum(jsii_type="jsii-calc.SingletonStringEnum")
class SingletonStringEnum(enum.Enum):
    '''A singleton string.'''

    SINGLETON_STRING = "SINGLETON_STRING"
    '''1337.'''


@jsii.data_type(
    jsii_type="jsii-calc.SmellyStruct",
    jsii_struct_bases=[],
    name_mapping={"property": "property", "yet_anoter_one": "yetAnoterOne"},
)
class SmellyStruct:
    def __init__(
        self,
        *,
        property: builtins.str,
        yet_anoter_one: builtins.bool,
    ) -> None:
        '''
        :param property: 
        :param yet_anoter_one: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "property": property,
            "yet_anoter_one": yet_anoter_one,
        }

    @builtins.property
    def property(self) -> builtins.str:
        result = self._values.get("property")
        assert result is not None, "Required property 'property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def yet_anoter_one(self) -> builtins.bool:
        result = self._values.get("yet_anoter_one")
        assert result is not None, "Required property 'yet_anoter_one' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SmellyStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SomeTypeJsii976(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.SomeTypeJsii976"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="returnAnonymous")
    @builtins.classmethod
    def return_anonymous(cls) -> typing.Any:
        return typing.cast(typing.Any, jsii.sinvoke(cls, "returnAnonymous", []))

    @jsii.member(jsii_name="returnReturn")
    @builtins.classmethod
    def return_return(cls) -> IReturnJsii976:
        return typing.cast(IReturnJsii976, jsii.sinvoke(cls, "returnReturn", []))


class StableClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.StableClass"):
    def __init__(
        self,
        readonly_string: builtins.str,
        mutable_number: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param readonly_string: -
        :param mutable_number: -
        '''
        jsii.create(self.__class__, self, [readonly_string, mutable_number])

    @jsii.member(jsii_name="method")
    def method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "method", []))

    @builtins.property
    @jsii.member(jsii_name="readonlyProperty")
    def readonly_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readonlyProperty"))

    @builtins.property
    @jsii.member(jsii_name="mutableProperty")
    def mutable_property(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))

    @mutable_property.setter
    def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "mutableProperty", value)


@jsii.enum(jsii_type="jsii-calc.StableEnum")
class StableEnum(enum.Enum):
    OPTION_A = "OPTION_A"
    OPTION_B = "OPTION_B"


@jsii.data_type(
    jsii_type="jsii-calc.StableStruct",
    jsii_struct_bases=[],
    name_mapping={"readonly_property": "readonlyProperty"},
)
class StableStruct:
    def __init__(self, *, readonly_property: builtins.str) -> None:
        '''
        :param readonly_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "readonly_property": readonly_property,
        }

    @builtins.property
    def readonly_property(self) -> builtins.str:
        result = self._values.get("readonly_property")
        assert result is not None, "Required property 'readonly_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StableStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StaticContext(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.StaticContext"):
    '''This is used to validate the ability to use \`\`this\`\` from within a static context.

    https://github.com/awslabs/aws-cdk/issues/2304
    '''

    @jsii.member(jsii_name="canAccessStaticContext")
    @builtins.classmethod
    def can_access_static_context(cls) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "canAccessStaticContext", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="staticVariable")
    def static_variable(cls) -> builtins.bool:  # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(builtins.bool, jsii.sget(cls, "staticVariable"))

    @static_variable.setter # type: ignore[no-redef]
    def static_variable(cls, value: builtins.bool) -> None:
        jsii.sset(cls, "staticVariable", value)


class StaticHelloParent(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.StaticHelloParent",
):
    '''Static methods that override parent class are technically overrides (the inheritance of statics is part of the ES6 specification), but certain other languages such as Java do not carry statics in the inheritance chain at all, so they cannot be overridden, only hidden.

    The difference is fairly minor (for typical use-cases, the end result is the
    same), however this has implications on what the generated code should look
    like.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="method")
    @builtins.classmethod
    def method(cls) -> None:
        return typing.cast(None, jsii.sinvoke(cls, "method", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="property")
    def property(cls) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.sget(cls, "property"))


class Statics(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Statics"):
    def __init__(self, value: builtins.str) -> None:
        '''
        :param value: -
        '''
        jsii.create(self.__class__, self, [value])

    @jsii.member(jsii_name="staticMethod")
    @builtins.classmethod
    def static_method(cls, name: builtins.str) -> builtins.str:
        '''Jsdocs for static method.

        :param name: The name of the person to say hello to.
        '''
        return typing.cast(builtins.str, jsii.sinvoke(cls, "staticMethod", [name]))

    @jsii.member(jsii_name="justMethod")
    def just_method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "justMethod", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BAR")
    def BAR(cls) -> jsii.Number:
        '''Constants may also use all-caps.'''
        return typing.cast(jsii.Number, jsii.sget(cls, "BAR"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ConstObj")
    def CONST_OBJ(cls) -> "DoubleTrouble":
        return typing.cast("DoubleTrouble", jsii.sget(cls, "ConstObj"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="Foo")
    def FOO(cls) -> builtins.str:
        '''Jsdocs for static property.'''
        return typing.cast(builtins.str, jsii.sget(cls, "Foo"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="zooBar")
    def ZOO_BAR(cls) -> typing.Mapping[builtins.str, builtins.str]:
        '''Constants can also use camelCase.'''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.sget(cls, "zooBar"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="instance")
    def instance(cls) -> "Statics":  # pyright: ignore [reportGeneralTypeIssues]
        '''Jsdocs for static getter.

        Jsdocs for static setter.
        '''
        return typing.cast("Statics", jsii.sget(cls, "instance"))

    @instance.setter # type: ignore[no-redef]
    def instance(cls, value: "Statics") -> None:
        jsii.sset(cls, "instance", value)

    @jsii.python.classproperty
    @jsii.member(jsii_name="nonConstStatic")
    def non_const_static(cls) -> jsii.Number:  # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(jsii.Number, jsii.sget(cls, "nonConstStatic"))

    @non_const_static.setter # type: ignore[no-redef]
    def non_const_static(cls, value: jsii.Number) -> None:
        jsii.sset(cls, "nonConstStatic", value)

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "value"))


@jsii.enum(jsii_type="jsii-calc.StringEnum")
class StringEnum(enum.Enum):
    A = "A"
    B = "B"
    C = "C"


class StripInternal(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.StripInternal"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="youSeeMe")
    def you_see_me(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "youSeeMe"))

    @you_see_me.setter
    def you_see_me(self, value: builtins.str) -> None:
        jsii.set(self, "youSeeMe", value)


@jsii.data_type(
    jsii_type="jsii-calc.StructA",
    jsii_struct_bases=[],
    name_mapping={
        "required_string": "requiredString",
        "optional_number": "optionalNumber",
        "optional_string": "optionalString",
    },
)
class StructA:
    def __init__(
        self,
        *,
        required_string: builtins.str,
        optional_number: typing.Optional[jsii.Number] = None,
        optional_string: typing.Optional[builtins.str] = None,
    ) -> None:
        '''We can serialize and deserialize structs without silently ignoring optional fields.

        :param required_string: 
        :param optional_number: 
        :param optional_string: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "required_string": required_string,
        }
        if optional_number is not None:
            self._values["optional_number"] = optional_number
        if optional_string is not None:
            self._values["optional_string"] = optional_string

    @builtins.property
    def required_string(self) -> builtins.str:
        result = self._values.get("required_string")
        assert result is not None, "Required property 'required_string' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional_number(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("optional_number")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def optional_string(self) -> typing.Optional[builtins.str]:
        result = self._values.get("optional_string")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructA(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.StructB",
    jsii_struct_bases=[],
    name_mapping={
        "required_string": "requiredString",
        "optional_boolean": "optionalBoolean",
        "optional_struct_a": "optionalStructA",
    },
)
class StructB:
    def __init__(
        self,
        *,
        required_string: builtins.str,
        optional_boolean: typing.Optional[builtins.bool] = None,
        optional_struct_a: typing.Optional[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''This intentionally overlaps with StructA (where only requiredString is provided) to test htat the kernel properly disambiguates those.

        :param required_string: 
        :param optional_boolean: 
        :param optional_struct_a: 
        '''
        if isinstance(optional_struct_a, dict):
            optional_struct_a = StructA(**optional_struct_a)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "required_string": required_string,
        }
        if optional_boolean is not None:
            self._values["optional_boolean"] = optional_boolean
        if optional_struct_a is not None:
            self._values["optional_struct_a"] = optional_struct_a

    @builtins.property
    def required_string(self) -> builtins.str:
        result = self._values.get("required_string")
        assert result is not None, "Required property 'required_string' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def optional_boolean(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("optional_boolean")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def optional_struct_a(self) -> typing.Optional[StructA]:
        result = self._values.get("optional_struct_a")
        return typing.cast(typing.Optional[StructA], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructB(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.StructParameterType",
    jsii_struct_bases=[],
    name_mapping={"scope": "scope", "props": "props"},
)
class StructParameterType:
    def __init__(
        self,
        *,
        scope: builtins.str,
        props: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Verifies that, in languages that do keyword lifting (e.g: Python), having a struct member with the same name as a positional parameter results in the correct code being emitted.

        See: https://github.com/aws/aws-cdk/issues/4302

        :param scope: 
        :param props: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "scope": scope,
        }
        if props is not None:
            self._values["props"] = props

    @builtins.property
    def scope(self) -> builtins.str:
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def props(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("props")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructParameterType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StructPassing(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.StructPassing"):
    '''Just because we can.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="howManyVarArgsDidIPass")
    @builtins.classmethod
    def how_many_var_args_did_i_pass(
        cls,
        _positional: jsii.Number,
        *inputs: "TopLevelStruct",
    ) -> jsii.Number:
        '''
        :param _positional: -
        :param inputs: -
        '''
        return typing.cast(jsii.Number, jsii.sinvoke(cls, "howManyVarArgsDidIPass", [_positional, *inputs]))

    @jsii.member(jsii_name="roundTrip")
    @builtins.classmethod
    def round_trip(
        cls,
        _positional: jsii.Number,
        *,
        required: builtins.str,
        second_level: typing.Union[jsii.Number, typing.Union[SecondLevelStruct, typing.Dict[builtins.str, typing.Any]]],
        optional: typing.Optional[builtins.str] = None,
    ) -> "TopLevelStruct":
        '''
        :param _positional: -
        :param required: This is a required field.
        :param second_level: A union to really stress test our serialization.
        :param optional: You don't have to pass this.
        '''
        input = TopLevelStruct(
            required=required, second_level=second_level, optional=optional
        )

        return typing.cast("TopLevelStruct", jsii.sinvoke(cls, "roundTrip", [_positional, input]))


class StructUnionConsumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.StructUnionConsumer",
):
    @jsii.member(jsii_name="isStructA")
    @builtins.classmethod
    def is_struct_a(
        cls,
        struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
    ) -> builtins.bool:
        '''
        :param struct: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "isStructA", [struct]))

    @jsii.member(jsii_name="isStructB")
    @builtins.classmethod
    def is_struct_b(
        cls,
        struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
    ) -> builtins.bool:
        '''
        :param struct: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "isStructB", [struct]))

    @jsii.member(jsii_name="provideStruct")
    @builtins.classmethod
    def provide_struct(cls, which: builtins.str) -> typing.Union[StructA, StructB]:
        '''
        :param which: -
        '''
        return typing.cast(typing.Union[StructA, StructB], jsii.sinvoke(cls, "provideStruct", [which]))


@jsii.data_type(
    jsii_type="jsii-calc.StructWithCollectionOfUnionts",
    jsii_struct_bases=[],
    name_mapping={"union_property": "unionProperty"},
)
class StructWithCollectionOfUnionts:
    def __init__(
        self,
        *,
        union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]]],
    ) -> None:
        '''
        :param union_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "union_property": union_property,
        }

    @builtins.property
    def union_property(
        self,
    ) -> typing.List[typing.Mapping[builtins.str, typing.Union[StructA, StructB]]]:
        result = self._values.get("union_property")
        assert result is not None, "Required property 'union_property' is missing"
        return typing.cast(typing.List[typing.Mapping[builtins.str, typing.Union[StructA, StructB]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructWithCollectionOfUnionts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.StructWithEnum",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo", "bar": "bar"},
)
class StructWithEnum:
    def __init__(
        self,
        *,
        foo: StringEnum,
        bar: typing.Optional[AllTypesEnum] = None,
    ) -> None:
        '''
        :param foo: An enum value.
        :param bar: Optional enum value (of type integer). Default: AllTypesEnum.YOUR_ENUM_VALUE
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }
        if bar is not None:
            self._values["bar"] = bar

    @builtins.property
    def foo(self) -> StringEnum:
        '''An enum value.'''
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(StringEnum, result)

    @builtins.property
    def bar(self) -> typing.Optional[AllTypesEnum]:
        '''Optional enum value (of type integer).

        :default: AllTypesEnum.YOUR_ENUM_VALUE
        '''
        result = self._values.get("bar")
        return typing.cast(typing.Optional[AllTypesEnum], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructWithEnum(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.StructWithJavaReservedWords",
    jsii_struct_bases=[],
    name_mapping={
        "default": "default",
        "assert_": "assert",
        "result": "result",
        "that": "that",
    },
)
class StructWithJavaReservedWords:
    def __init__(
        self,
        *,
        default: builtins.str,
        assert_: typing.Optional[builtins.str] = None,
        result: typing.Optional[builtins.str] = None,
        that: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param default: 
        :param assert_: 
        :param result: 
        :param that: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "default": default,
        }
        if assert_ is not None:
            self._values["assert_"] = assert_
        if result is not None:
            self._values["result"] = result
        if that is not None:
            self._values["that"] = that

    @builtins.property
    def default(self) -> builtins.str:
        result = self._values.get("default")
        assert result is not None, "Required property 'default' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def assert_(self) -> typing.Optional[builtins.str]:
        result = self._values.get("assert_")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def result(self) -> typing.Optional[builtins.str]:
        result = self._values.get("result")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def that(self) -> typing.Optional[builtins.str]:
        result = self._values.get("that")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructWithJavaReservedWords(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Sum(
    _CompositeOperation_1c4d123b,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.Sum",
):
    '''An operation that sums multiple values.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The expression that this operation consists of.

        Must be implemented by derived classes.
        '''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "expression"))

    @builtins.property
    @jsii.member(jsii_name="parts")
    def parts(self) -> typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue]:
        '''The parts to sum.'''
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue], jsii.get(self, "parts"))

    @parts.setter
    def parts(
        self,
        value: typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue],
    ) -> None:
        jsii.set(self, "parts", value)


@jsii.data_type(
    jsii_type="jsii-calc.SupportsNiceJavaBuilderProps",
    jsii_struct_bases=[],
    name_mapping={"bar": "bar", "id": "id"},
)
class SupportsNiceJavaBuilderProps:
    def __init__(
        self,
        *,
        bar: jsii.Number,
        id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param bar: Some number, like 42.
        :param id: An \`\`id\`\` field here is terrible API design, because the constructor of \`\`SupportsNiceJavaBuilder\`\` already has a parameter named \`\`id\`\`. But here we are, doing it like we didn't care.
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bar": bar,
        }
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def bar(self) -> jsii.Number:
        '''Some number, like 42.'''
        result = self._values.get("bar")
        assert result is not None, "Required property 'bar' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        '''An \`\`id\`\` field here is terrible API design, because the constructor of \`\`SupportsNiceJavaBuilder\`\` already has a parameter named \`\`id\`\`.

        But here we are, doing it like we didn't care.
        '''
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SupportsNiceJavaBuilderProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SupportsNiceJavaBuilderWithRequiredProps(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.SupportsNiceJavaBuilderWithRequiredProps",
):
    '''We can generate fancy builders in Java for classes which take a mix of positional & struct parameters.'''

    def __init__(
        self,
        id_: jsii.Number,
        *,
        bar: jsii.Number,
        id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param id_: some identifier of your choice.
        :param bar: Some number, like 42.
        :param id: An \`\`id\`\` field here is terrible API design, because the constructor of \`\`SupportsNiceJavaBuilder\`\` already has a parameter named \`\`id\`\`. But here we are, doing it like we didn't care.
        '''
        props = SupportsNiceJavaBuilderProps(bar=bar, id=id)

        jsii.create(self.__class__, self, [id_, props])

    @builtins.property
    @jsii.member(jsii_name="bar")
    def bar(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "bar"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> jsii.Number:
        '''some identifier of your choice.'''
        return typing.cast(jsii.Number, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="propId")
    def prop_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "propId"))


class SyncVirtualMethods(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.SyncVirtualMethods",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="callerIsAsync")
    def caller_is_async(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.ainvoke(self, "callerIsAsync", []))

    @jsii.member(jsii_name="callerIsMethod")
    def caller_is_method(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "callerIsMethod", []))

    @jsii.member(jsii_name="modifyOtherProperty")
    def modify_other_property(self, value: builtins.str) -> None:
        '''
        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "modifyOtherProperty", [value]))

    @jsii.member(jsii_name="modifyValueOfTheProperty")
    def modify_value_of_the_property(self, value: builtins.str) -> None:
        '''
        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "modifyValueOfTheProperty", [value]))

    @jsii.member(jsii_name="readA")
    def read_a(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "readA", []))

    @jsii.member(jsii_name="retrieveOtherProperty")
    def retrieve_other_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "retrieveOtherProperty", []))

    @jsii.member(jsii_name="retrieveReadOnlyProperty")
    def retrieve_read_only_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "retrieveReadOnlyProperty", []))

    @jsii.member(jsii_name="retrieveValueOfTheProperty")
    def retrieve_value_of_the_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "retrieveValueOfTheProperty", []))

    @jsii.member(jsii_name="virtualMethod")
    def virtual_method(self, n: jsii.Number) -> jsii.Number:
        '''
        :param n: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "virtualMethod", [n]))

    @jsii.member(jsii_name="writeA")
    def write_a(self, value: jsii.Number) -> None:
        '''
        :param value: -
        '''
        return typing.cast(None, jsii.invoke(self, "writeA", [value]))

    @builtins.property
    @jsii.member(jsii_name="readonlyProperty")
    def readonly_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readonlyProperty"))

    @builtins.property
    @jsii.member(jsii_name="a")
    def a(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "a"))

    @a.setter
    def a(self, value: jsii.Number) -> None:
        jsii.set(self, "a", value)

    @builtins.property
    @jsii.member(jsii_name="callerIsProperty")
    def caller_is_property(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "callerIsProperty"))

    @caller_is_property.setter
    def caller_is_property(self, value: jsii.Number) -> None:
        jsii.set(self, "callerIsProperty", value)

    @builtins.property
    @jsii.member(jsii_name="otherProperty")
    def other_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "otherProperty"))

    @other_property.setter
    def other_property(self, value: builtins.str) -> None:
        jsii.set(self, "otherProperty", value)

    @builtins.property
    @jsii.member(jsii_name="theProperty")
    def the_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "theProperty"))

    @the_property.setter
    def the_property(self, value: builtins.str) -> None:
        jsii.set(self, "theProperty", value)

    @builtins.property
    @jsii.member(jsii_name="valueOfOtherProperty")
    def value_of_other_property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "valueOfOtherProperty"))

    @value_of_other_property.setter
    def value_of_other_property(self, value: builtins.str) -> None:
        jsii.set(self, "valueOfOtherProperty", value)


class TestStructWithEnum(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.TestStructWithEnum",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="isStringEnumA")
    def is_string_enum_a(
        self,
        *,
        foo: StringEnum,
        bar: typing.Optional[AllTypesEnum] = None,
    ) -> builtins.bool:
        '''Returns true if \`\`foo\`\` is \`\`StringEnum.A\`\`.

        :param foo: An enum value.
        :param bar: Optional enum value (of type integer). Default: AllTypesEnum.YOUR_ENUM_VALUE
        '''
        input = StructWithEnum(foo=foo, bar=bar)

        return typing.cast(builtins.bool, jsii.invoke(self, "isStringEnumA", [input]))

    @jsii.member(jsii_name="isStringEnumB")
    def is_string_enum_b(
        self,
        *,
        foo: StringEnum,
        bar: typing.Optional[AllTypesEnum] = None,
    ) -> builtins.bool:
        '''Returns true if \`\`foo\`\` is \`\`StringEnum.B\`\` and \`\`bar\`\` is \`\`AllTypesEnum.THIS_IS_GREAT\`\`.

        :param foo: An enum value.
        :param bar: Optional enum value (of type integer). Default: AllTypesEnum.YOUR_ENUM_VALUE
        '''
        input = StructWithEnum(foo=foo, bar=bar)

        return typing.cast(builtins.bool, jsii.invoke(self, "isStringEnumB", [input]))

    @builtins.property
    @jsii.member(jsii_name="structWithFoo")
    def struct_with_foo(self) -> StructWithEnum:
        '''Returns \`\`foo: StringEnum.A\`\`.'''
        return typing.cast(StructWithEnum, jsii.get(self, "structWithFoo"))

    @builtins.property
    @jsii.member(jsii_name="structWithFooBar")
    def struct_with_foo_bar(self) -> StructWithEnum:
        '''Returns \`\`foo: StringEnum.C\`\` and \`\`bar: AllTypesEnum.MY_ENUM_VALUE\`\`.'''
        return typing.cast(StructWithEnum, jsii.get(self, "structWithFooBar"))


class Thrower(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Thrower"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="throwError")
    def throw_error(self) -> None:
        return typing.cast(None, jsii.invoke(self, "throwError", []))


@jsii.data_type(
    jsii_type="jsii-calc.TopLevelStruct",
    jsii_struct_bases=[],
    name_mapping={
        "required": "required",
        "second_level": "secondLevel",
        "optional": "optional",
    },
)
class TopLevelStruct:
    def __init__(
        self,
        *,
        required: builtins.str,
        second_level: typing.Union[jsii.Number, typing.Union[SecondLevelStruct, typing.Dict[builtins.str, typing.Any]]],
        optional: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param required: This is a required field.
        :param second_level: A union to really stress test our serialization.
        :param optional: You don't have to pass this.
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "required": required,
            "second_level": second_level,
        }
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def required(self) -> builtins.str:
        '''This is a required field.'''
        result = self._values.get("required")
        assert result is not None, "Required property 'required' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def second_level(self) -> typing.Union[jsii.Number, SecondLevelStruct]:
        '''A union to really stress test our serialization.'''
        result = self._values.get("second_level")
        assert result is not None, "Required property 'second_level' is missing"
        return typing.cast(typing.Union[jsii.Number, SecondLevelStruct], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.str]:
        '''You don't have to pass this.'''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TopLevelStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TwoMethodsWithSimilarCapitalization(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.TwoMethodsWithSimilarCapitalization",
):
    '''In TypeScript it is possible to have two methods with the same name but different capitalization.

    :see: https://github.com/aws/jsii/issues/2508
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toIsoString")
    def to_iso_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toIsoString", []))

    @jsii.member(jsii_name="toIsOString")
    def to_is_o_string(self) -> builtins.str:
        '''
        :deprecated: python requires that all alternatives are deprecated

        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "toIsOString", []))

    @builtins.property
    @jsii.member(jsii_name="fooBar")
    def foo_bar(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "fooBar"))


class UmaskCheck(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.UmaskCheck"):
    '''Checks the current file permissions are cool (no funky UMASK down-scoping happened).

    :see: https://github.com/aws/jsii/issues/1765
    '''

    @jsii.member(jsii_name="mode")
    @builtins.classmethod
    def mode(cls) -> jsii.Number:
        '''This should return 0o644 (-rw-r--r--).'''
        return typing.cast(jsii.Number, jsii.sinvoke(cls, "mode", []))


class UnaryOperation(
    _scope_jsii_calc_lib_c61f082f.Operation,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.UnaryOperation",
):
    '''An operation on a single operand.'''

    def __init__(self, operand: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
        '''
        :param operand: -
        '''
        jsii.create(self.__class__, self, [operand])

    @builtins.property
    @jsii.member(jsii_name="operand")
    def operand(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "operand"))


class _UnaryOperationProxy(
    UnaryOperation,
    jsii.proxy_for(_scope_jsii_calc_lib_c61f082f.Operation), # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, UnaryOperation).__jsii_proxy_class__ = lambda : _UnaryOperationProxy


@jsii.data_type(
    jsii_type="jsii-calc.UnionProperties",
    jsii_struct_bases=[],
    name_mapping={"bar": "bar", "foo": "foo"},
)
class UnionProperties:
    def __init__(
        self,
        *,
        bar: typing.Union[builtins.str, jsii.Number, AllTypes],
        foo: typing.Optional[typing.Union[builtins.str, jsii.Number]] = None,
    ) -> None:
        '''
        :param bar: 
        :param foo: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bar": bar,
        }
        if foo is not None:
            self._values["foo"] = foo

    @builtins.property
    def bar(self) -> typing.Union[builtins.str, jsii.Number, AllTypes]:
        result = self._values.get("bar")
        assert result is not None, "Required property 'bar' is missing"
        return typing.cast(typing.Union[builtins.str, jsii.Number, AllTypes], result)

    @builtins.property
    def foo(self) -> typing.Optional[typing.Union[builtins.str, jsii.Number]]:
        result = self._values.get("foo")
        return typing.cast(typing.Optional[typing.Union[builtins.str, jsii.Number]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UnionProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_scope_jsii_calc_lib_custom_submodule_name_c61f082f.IReflectable)
class UpcasingReflectable(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.UpcasingReflectable",
):
    '''Ensures submodule-imported types from dependencies can be used correctly.'''

    def __init__(self, delegate: typing.Mapping[builtins.str, typing.Any]) -> None:
        '''
        :param delegate: -
        '''
        jsii.create(self.__class__, self, [delegate])

    @jsii.python.classproperty
    @jsii.member(jsii_name="reflector")
    def REFLECTOR(cls) -> _scope_jsii_calc_lib_custom_submodule_name_c61f082f.Reflector:
        return typing.cast(_scope_jsii_calc_lib_custom_submodule_name_c61f082f.Reflector, jsii.sget(cls, "reflector"))

    @builtins.property
    @jsii.member(jsii_name="entries")
    def entries(
        self,
    ) -> typing.List[_scope_jsii_calc_lib_custom_submodule_name_c61f082f.ReflectableEntry]:
        return typing.cast(typing.List[_scope_jsii_calc_lib_custom_submodule_name_c61f082f.ReflectableEntry], jsii.get(self, "entries"))


class UseBundledDependency(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.UseBundledDependency",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.invoke(self, "value", []))


class UseCalcBase(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.UseCalcBase"):
    '''Depend on a type from jsii-calc-base as a test for awslabs/jsii#128.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="hello")
    def hello(self) -> _scope_jsii_calc_base_734f0262.Base:
        return typing.cast(_scope_jsii_calc_base_734f0262.Base, jsii.invoke(self, "hello", []))


class UsesInterfaceWithProperties(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.UsesInterfaceWithProperties",
):
    def __init__(self, obj: IInterfaceWithProperties) -> None:
        '''
        :param obj: -
        '''
        jsii.create(self.__class__, self, [obj])

    @jsii.member(jsii_name="justRead")
    def just_read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "justRead", []))

    @jsii.member(jsii_name="readStringAndNumber")
    def read_string_and_number(
        self,
        ext: IInterfaceWithPropertiesExtension,
    ) -> builtins.str:
        '''
        :param ext: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "readStringAndNumber", [ext]))

    @jsii.member(jsii_name="writeAndRead")
    def write_and_read(self, value: builtins.str) -> builtins.str:
        '''
        :param value: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "writeAndRead", [value]))

    @builtins.property
    @jsii.member(jsii_name="obj")
    def obj(self) -> IInterfaceWithProperties:
        return typing.cast(IInterfaceWithProperties, jsii.get(self, "obj"))


class VariadicInvoker(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.VariadicInvoker"):
    def __init__(self, method: "VariadicMethod") -> None:
        '''
        :param method: -
        '''
        jsii.create(self.__class__, self, [method])

    @jsii.member(jsii_name="asArray")
    def as_array(self, *values: jsii.Number) -> typing.List[jsii.Number]:
        '''
        :param values: -
        '''
        return typing.cast(typing.List[jsii.Number], jsii.invoke(self, "asArray", [*values]))


class VariadicMethod(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.VariadicMethod"):
    def __init__(self, *prefix: jsii.Number) -> None:
        '''
        :param prefix: a prefix that will be use for all values returned by \`\`#asArray\`\`.
        '''
        jsii.create(self.__class__, self, [*prefix])

    @jsii.member(jsii_name="asArray")
    def as_array(
        self,
        first: jsii.Number,
        *others: jsii.Number,
    ) -> typing.List[jsii.Number]:
        '''
        :param first: the first element of the array to be returned (after the \`\`prefix\`\` provided at construction time).
        :param others: other elements to be included in the array.
        '''
        return typing.cast(typing.List[jsii.Number], jsii.invoke(self, "asArray", [first, *others]))


class VariadicTypeUnion(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.VariadicTypeUnion",
):
    def __init__(self, *union: typing.Union[StructA, StructB]) -> None:
        '''
        :param union: -
        '''
        jsii.create(self.__class__, self, [*union])

    @builtins.property
    @jsii.member(jsii_name="union")
    def union(self) -> typing.List[typing.Union[StructA, StructB]]:
        return typing.cast(typing.List[typing.Union[StructA, StructB]], jsii.get(self, "union"))

    @union.setter
    def union(self, value: typing.List[typing.Union[StructA, StructB]]) -> None:
        jsii.set(self, "union", value)


class VirtualMethodPlayground(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.VirtualMethodPlayground",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="overrideMeAsync")
    def override_me_async(self, index: jsii.Number) -> jsii.Number:
        '''
        :param index: -
        '''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMeAsync", [index]))

    @jsii.member(jsii_name="overrideMeSync")
    def override_me_sync(self, index: jsii.Number) -> jsii.Number:
        '''
        :param index: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "overrideMeSync", [index]))

    @jsii.member(jsii_name="parallelSumAsync")
    def parallel_sum_async(self, count: jsii.Number) -> jsii.Number:
        '''
        :param count: -
        '''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "parallelSumAsync", [count]))

    @jsii.member(jsii_name="serialSumAsync")
    def serial_sum_async(self, count: jsii.Number) -> jsii.Number:
        '''
        :param count: -
        '''
        return typing.cast(jsii.Number, jsii.ainvoke(self, "serialSumAsync", [count]))

    @jsii.member(jsii_name="sumSync")
    def sum_sync(self, count: jsii.Number) -> jsii.Number:
        '''
        :param count: -
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "sumSync", [count]))


class VoidCallback(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.VoidCallback",
):
    '''This test is used to validate the runtimes can return correctly from a void callback.

    - Implement \`\`overrideMe\`\` (method does not have to do anything).
    - Invoke \`\`callMe\`\`
    - Verify that \`\`methodWasCalled\`\` is \`\`true\`\`.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="callMe")
    def call_me(self) -> None:
        return typing.cast(None, jsii.invoke(self, "callMe", []))

    @jsii.member(jsii_name="overrideMe")
    @abc.abstractmethod
    def _override_me(self) -> None:
        ...

    @builtins.property
    @jsii.member(jsii_name="methodWasCalled")
    def method_was_called(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "methodWasCalled"))


class _VoidCallbackProxy(VoidCallback):
    @jsii.member(jsii_name="overrideMe")
    def _override_me(self) -> None:
        return typing.cast(None, jsii.invoke(self, "overrideMe", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, VoidCallback).__jsii_proxy_class__ = lambda : _VoidCallbackProxy


class WithPrivatePropertyInConstructor(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.WithPrivatePropertyInConstructor",
):
    '''Verifies that private property declarations in constructor arguments are hidden.'''

    def __init__(self, private_field: typing.Optional[builtins.str] = None) -> None:
        '''
        :param private_field: -
        '''
        jsii.create(self.__class__, self, [private_field])

    @builtins.property
    @jsii.member(jsii_name="success")
    def success(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "success"))


@jsii.implements(IInterfaceImplementedByAbstractClass)
class AbstractClass(
    AbstractClassBase,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.AbstractClass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="abstractMethod")
    @abc.abstractmethod
    def abstract_method(self, name: builtins.str) -> builtins.str:
        '''
        :param name: -
        '''
        ...

    @jsii.member(jsii_name="nonAbstractMethod")
    def non_abstract_method(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.invoke(self, "nonAbstractMethod", []))

    @builtins.property
    @jsii.member(jsii_name="propFromInterface")
    def prop_from_interface(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "propFromInterface"))


class _AbstractClassProxy(
    AbstractClass,
    jsii.proxy_for(AbstractClassBase), # type: ignore[misc]
):
    @jsii.member(jsii_name="abstractMethod")
    def abstract_method(self, name: builtins.str) -> builtins.str:
        '''
        :param name: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "abstractMethod", [name]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AbstractClass).__jsii_proxy_class__ = lambda : _AbstractClassProxy


class Add(BinaryOperation, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Add"):
    '''The "+" binary operation.'''

    def __init__(
        self,
        lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
        rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
    ) -> None:
        '''Creates a BinaryOperation.

        :param lhs: Left-hand side operand.
        :param rhs: Right-hand side operand.
        '''
        jsii.create(self.__class__, self, [lhs, rhs])

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''String representation of the value.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''The value.'''
        return typing.cast(jsii.Number, jsii.get(self, "value"))


@jsii.implements(IAnonymousImplementationProvider)
class AnonymousImplementationProvider(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.AnonymousImplementationProvider",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="provideAsClass")
    def provide_as_class(self) -> Implementation:
        return typing.cast(Implementation, jsii.invoke(self, "provideAsClass", []))

    @jsii.member(jsii_name="provideAsInterface")
    def provide_as_interface(self) -> IAnonymouslyImplementMe:
        return typing.cast(IAnonymouslyImplementMe, jsii.invoke(self, "provideAsInterface", []))


@jsii.implements(IBell)
class Bell(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Bell"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ring")
    def ring(self) -> None:
        return typing.cast(None, jsii.invoke(self, "ring", []))

    @builtins.property
    @jsii.member(jsii_name="rung")
    def rung(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "rung"))

    @rung.setter
    def rung(self, value: builtins.bool) -> None:
        jsii.set(self, "rung", value)


@jsii.data_type(
    jsii_type="jsii-calc.ChildStruct982",
    jsii_struct_bases=[ParentStruct982],
    name_mapping={"foo": "foo", "bar": "bar"},
)
class ChildStruct982(ParentStruct982):
    def __init__(self, *, foo: builtins.str, bar: jsii.Number) -> None:
        '''
        :param foo: 
        :param bar: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
            "bar": bar,
        }

    @builtins.property
    def foo(self) -> builtins.str:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def bar(self) -> jsii.Number:
        result = self._values.get("bar")
        assert result is not None, "Required property 'bar' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ChildStruct982(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(INonInternalInterface)
class ClassThatImplementsTheInternalInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassThatImplementsTheInternalInterface",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="a")
    def a(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "a"))

    @a.setter
    def a(self, value: builtins.str) -> None:
        jsii.set(self, "a", value)

    @builtins.property
    @jsii.member(jsii_name="b")
    def b(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "b"))

    @b.setter
    def b(self, value: builtins.str) -> None:
        jsii.set(self, "b", value)

    @builtins.property
    @jsii.member(jsii_name="c")
    def c(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "c"))

    @c.setter
    def c(self, value: builtins.str) -> None:
        jsii.set(self, "c", value)

    @builtins.property
    @jsii.member(jsii_name="d")
    def d(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "d"))

    @d.setter
    def d(self, value: builtins.str) -> None:
        jsii.set(self, "d", value)


@jsii.implements(INonInternalInterface)
class ClassThatImplementsThePrivateInterface(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassThatImplementsThePrivateInterface",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="a")
    def a(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "a"))

    @a.setter
    def a(self, value: builtins.str) -> None:
        jsii.set(self, "a", value)

    @builtins.property
    @jsii.member(jsii_name="b")
    def b(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "b"))

    @b.setter
    def b(self, value: builtins.str) -> None:
        jsii.set(self, "b", value)

    @builtins.property
    @jsii.member(jsii_name="c")
    def c(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "c"))

    @c.setter
    def c(self, value: builtins.str) -> None:
        jsii.set(self, "c", value)

    @builtins.property
    @jsii.member(jsii_name="e")
    def e(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "e"))

    @e.setter
    def e(self, value: builtins.str) -> None:
        jsii.set(self, "e", value)


@jsii.implements(IInterfaceWithProperties)
class ClassWithPrivateConstructorAndAutomaticProperties(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.ClassWithPrivateConstructorAndAutomaticProperties",
):
    '''Class that implements interface properties automatically, but using a private constructor.'''

    @jsii.member(jsii_name="create")
    @builtins.classmethod
    def create(
        cls,
        read_only_string: builtins.str,
        read_write_string: builtins.str,
    ) -> "ClassWithPrivateConstructorAndAutomaticProperties":
        '''
        :param read_only_string: -
        :param read_write_string: -
        '''
        return typing.cast("ClassWithPrivateConstructorAndAutomaticProperties", jsii.sinvoke(cls, "create", [read_only_string, read_write_string]))

    @builtins.property
    @jsii.member(jsii_name="readOnlyString")
    def read_only_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readOnlyString"))

    @builtins.property
    @jsii.member(jsii_name="readWriteString")
    def read_write_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "readWriteString"))

    @read_write_string.setter
    def read_write_string(self, value: builtins.str) -> None:
        jsii.set(self, "readWriteString", value)


@jsii.implements(IIndirectlyImplemented)
class FullCombo(BaseClass, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.FullCombo"):
    pass


@jsii.interface(jsii_type="jsii-calc.IFriendlyRandomGenerator")
class IFriendlyRandomGenerator(
    IRandomNumberGenerator,
    _scope_jsii_calc_lib_c61f082f.IFriendly,
    typing_extensions.Protocol,
):
    pass


class _IFriendlyRandomGeneratorProxy(
    jsii.proxy_for(IRandomNumberGenerator), # type: ignore[misc]
    jsii.proxy_for(_scope_jsii_calc_lib_c61f082f.IFriendly), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IFriendlyRandomGenerator"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFriendlyRandomGenerator).__jsii_proxy_class__ = lambda : _IFriendlyRandomGeneratorProxy


@jsii.interface(jsii_type="jsii-calc.IInterfaceThatShouldNotBeADataType")
class IInterfaceThatShouldNotBeADataType(
    IInterfaceWithMethods,
    typing_extensions.Protocol,
):
    '''Even though this interface has only properties, it is disqualified from being a datatype because it inherits from an interface that is not a datatype.'''

    @builtins.property
    @jsii.member(jsii_name="otherValue")
    def other_value(self) -> builtins.str:
        ...


class _IInterfaceThatShouldNotBeADataTypeProxy(
    jsii.proxy_for(IInterfaceWithMethods), # type: ignore[misc]
):
    '''Even though this interface has only properties, it is disqualified from being a datatype because it inherits from an interface that is not a datatype.'''

    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IInterfaceThatShouldNotBeADataType"

    @builtins.property
    @jsii.member(jsii_name="otherValue")
    def other_value(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "otherValue"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceThatShouldNotBeADataType).__jsii_proxy_class__ = lambda : _IInterfaceThatShouldNotBeADataTypeProxy


@jsii.interface(jsii_type="jsii-calc.IJSII417Derived")
class IJSII417Derived(IJSII417PublicBaseOfBase, typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        ...

    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        ...

    @jsii.member(jsii_name="baz")
    def baz(self) -> None:
        ...


class _IJSII417DerivedProxy(
    jsii.proxy_for(IJSII417PublicBaseOfBase), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.IJSII417Derived"

    @builtins.property
    @jsii.member(jsii_name="property")
    def property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))

    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bar", []))

    @jsii.member(jsii_name="baz")
    def baz(self) -> None:
        return typing.cast(None, jsii.invoke(self, "baz", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IJSII417Derived).__jsii_proxy_class__ = lambda : _IJSII417DerivedProxy


@jsii.implements(IPublicInterface2)
class InbetweenClass(
    PublicClass,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.InbetweenClass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="ciao")
    def ciao(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "ciao", []))


class JSII417Derived(
    JSII417PublicBaseOfBase,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.JSII417Derived",
):
    def __init__(self, property: builtins.str) -> None:
        '''
        :param property: -
        '''
        jsii.create(self.__class__, self, [property])

    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bar", []))

    @jsii.member(jsii_name="baz")
    def baz(self) -> None:
        return typing.cast(None, jsii.invoke(self, "baz", []))

    @builtins.property
    @jsii.member(jsii_name="property")
    def _property(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "property"))


@jsii.implements(IFriendlier)
class Negate(UnaryOperation, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Negate"):
    '''The negation operation ("-value").'''

    def __init__(self, operand: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
        '''
        :param operand: -
        '''
        jsii.create(self.__class__, self, [operand])

    @jsii.member(jsii_name="farewell")
    def farewell(self) -> builtins.str:
        '''Say farewell.'''
        return typing.cast(builtins.str, jsii.invoke(self, "farewell", []))

    @jsii.member(jsii_name="goodbye")
    def goodbye(self) -> builtins.str:
        '''Say goodbye.'''
        return typing.cast(builtins.str, jsii.invoke(self, "goodbye", []))

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''Say hello!'''
        return typing.cast(builtins.str, jsii.invoke(self, "hello", []))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''String representation of the value.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''The value.'''
        return typing.cast(jsii.Number, jsii.get(self, "value"))


class StaticHelloChild(
    StaticHelloParent,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.StaticHelloChild",
):
    @jsii.member(jsii_name="method")
    @builtins.classmethod
    def method(cls) -> None:
        return typing.cast(None, jsii.sinvoke(cls, "method", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="property")
    def property(cls) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.sget(cls, "property"))


class SupportsNiceJavaBuilder(
    SupportsNiceJavaBuilderWithRequiredProps,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.SupportsNiceJavaBuilder",
):
    def __init__(
        self,
        id: jsii.Number,
        default_bar: typing.Optional[jsii.Number] = None,
        props: typing.Optional[typing.Union[SupportsNiceJavaBuilderProps, typing.Dict[builtins.str, typing.Any]]] = None,
        *rest: builtins.str,
    ) -> None:
        '''
        :param id: some identifier.
        :param default_bar: the default value of \`\`bar\`\`.
        :param props: some props once can provide.
        :param rest: a variadic continuation.
        '''
        jsii.create(self.__class__, self, [id, default_bar, props, *rest])

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> jsii.Number:
        '''some identifier.'''
        return typing.cast(jsii.Number, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="rest")
    def rest(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "rest"))


@jsii.implements(IFriendlyRandomGenerator)
class DoubleTrouble(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.DoubleTrouble"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''Say hello!'''
        return typing.cast(builtins.str, jsii.invoke(self, "hello", []))

    @jsii.member(jsii_name="next")
    def next(self) -> jsii.Number:
        '''Returns another random number.'''
        return typing.cast(jsii.Number, jsii.invoke(self, "next", []))


__all__ = [
    "AbstractClass",
    "AbstractClassBase",
    "AbstractClassReturner",
    "AbstractSuite",
    "Add",
    "AllTypes",
    "AllTypesEnum",
    "AllowedMethodNames",
    "AmbiguousParameters",
    "AnonymousImplementationProvider",
    "AsyncVirtualMethods",
    "AugmentableClass",
    "BaseClass",
    "BaseJsii976",
    "Bell",
    "BinaryOperation",
    "BurriedAnonymousObject",
    "Calculator",
    "CalculatorProps",
    "ChildStruct982",
    "ClassThatImplementsTheInternalInterface",
    "ClassThatImplementsThePrivateInterface",
    "ClassWithCollectionOfUnions",
    "ClassWithCollections",
    "ClassWithContainerTypes",
    "ClassWithDocs",
    "ClassWithJavaReservedWords",
    "ClassWithMutableObjectLiteralProperty",
    "ClassWithNestedUnion",
    "ClassWithPrivateConstructorAndAutomaticProperties",
    "ConfusingToJackson",
    "ConfusingToJacksonStruct",
    "ConstructorPassesThisOut",
    "Constructors",
    "ConsumePureInterface",
    "ConsumerCanRingBell",
    "ConsumersOfThisCrazyTypeSystem",
    "ContainerProps",
    "DataRenderer",
    "Default",
    "DefaultedConstructorArgument",
    "Demonstrate982",
    "DeprecatedClass",
    "DeprecatedEnum",
    "DeprecatedStruct",
    "DerivedStruct",
    "DiamondBottom",
    "DiamondInheritanceBaseLevelStruct",
    "DiamondInheritanceFirstMidLevelStruct",
    "DiamondInheritanceSecondMidLevelStruct",
    "DiamondInheritanceTopLevelStruct",
    "DisappointingCollectionSource",
    "DoNotOverridePrivates",
    "DoNotRecognizeAnyAsOptional",
    "DocumentedClass",
    "DontComplainAboutVariadicAfterOptional",
    "DoubleTrouble",
    "DummyObj",
    "DynamicPropertyBearer",
    "DynamicPropertyBearerChild",
    "Entropy",
    "EnumDispenser",
    "EraseUndefinedHashValues",
    "EraseUndefinedHashValuesOptions",
    "ExperimentalClass",
    "ExperimentalEnum",
    "ExperimentalStruct",
    "ExportedBaseClass",
    "ExtendsInternalInterface",
    "ExternalClass",
    "ExternalEnum",
    "ExternalStruct",
    "FullCombo",
    "GiveMeStructs",
    "Greetee",
    "GreetingAugmenter",
    "IAnonymousImplementationProvider",
    "IAnonymouslyImplementMe",
    "IAnotherPublicInterface",
    "IBell",
    "IBellRinger",
    "IConcreteBellRinger",
    "IDeprecatedInterface",
    "IExperimentalInterface",
    "IExtendsPrivateInterface",
    "IExternalInterface",
    "IFriendlier",
    "IFriendlyRandomGenerator",
    "IIndirectlyImplemented",
    "IInterfaceImplementedByAbstractClass",
    "IInterfaceThatShouldNotBeADataType",
    "IInterfaceWithInternal",
    "IInterfaceWithMethods",
    "IInterfaceWithOptionalMethodArguments",
    "IInterfaceWithProperties",
    "IInterfaceWithPropertiesExtension",
    "IJSII417Derived",
    "IJSII417PublicBaseOfBase",
    "IJavaReservedWordsInAnInterface",
    "IJsii487External",
    "IJsii487External2",
    "IJsii496",
    "IMutableObjectLiteral",
    "INonInternalInterface",
    "IObjectWithProperty",
    "IOptionalMethod",
    "IPrivatelyImplemented",
    "IPublicInterface",
    "IPublicInterface2",
    "IRandomNumberGenerator",
    "IReturnJsii976",
    "IReturnsNumber",
    "IStableInterface",
    "IStructReturningDelegate",
    "IWallClock",
    "ImplementInternalInterface",
    "Implementation",
    "ImplementsInterfaceWithInternal",
    "ImplementsInterfaceWithInternalSubclass",
    "ImplementsPrivateInterface",
    "ImplictBaseOfBase",
    "InbetweenClass",
    "InterfaceCollections",
    "InterfacesMaker",
    "Isomorphism",
    "Issue2638",
    "Issue2638B",
    "JSII417Derived",
    "JSII417PublicBaseOfBase",
    "JSObjectLiteralForInterface",
    "JSObjectLiteralToNative",
    "JSObjectLiteralToNativeClass",
    "JavaReservedWords",
    "Jsii487Derived",
    "Jsii496Derived",
    "JsiiAgent",
    "JsonFormatter",
    "LevelOne",
    "LevelOneProps",
    "LoadBalancedFargateServiceProps",
    "MethodNamedProperty",
    "Multiply",
    "Negate",
    "NestedClassInstance",
    "NestedStruct",
    "NodeStandardLibrary",
    "NullShouldBeTreatedAsUndefined",
    "NullShouldBeTreatedAsUndefinedData",
    "NumberGenerator",
    "ObjectRefsInCollections",
    "ObjectWithPropertyProvider",
    "Old",
    "OptionalArgumentInvoker",
    "OptionalConstructorArgument",
    "OptionalStruct",
    "OptionalStructConsumer",
    "OverridableProtectedMember",
    "OverrideReturnsObject",
    "ParamShadowsBuiltins",
    "ParamShadowsBuiltinsProps",
    "ParamShadowsScope",
    "ParentStruct982",
    "PartiallyInitializedThisConsumer",
    "Polymorphism",
    "Power",
    "PromiseNothing",
    "PropertyNamedProperty",
    "PublicClass",
    "PythonReservedWords",
    "ReferenceEnumFromScopedPackage",
    "ReturnsPrivateImplementationOfInterface",
    "RootStruct",
    "RootStructValidator",
    "RuntimeTypeChecking",
    "SecondLevelStruct",
    "SingleInstanceTwoTypes",
    "SingletonInt",
    "SingletonIntEnum",
    "SingletonString",
    "SingletonStringEnum",
    "SmellyStruct",
    "SomeTypeJsii976",
    "StableClass",
    "StableEnum",
    "StableStruct",
    "StaticContext",
    "StaticHelloChild",
    "StaticHelloParent",
    "Statics",
    "StringEnum",
    "StripInternal",
    "StructA",
    "StructB",
    "StructParameterType",
    "StructPassing",
    "StructUnionConsumer",
    "StructWithCollectionOfUnionts",
    "StructWithEnum",
    "StructWithJavaReservedWords",
    "Sum",
    "SupportsNiceJavaBuilder",
    "SupportsNiceJavaBuilderProps",
    "SupportsNiceJavaBuilderWithRequiredProps",
    "SyncVirtualMethods",
    "TestStructWithEnum",
    "Thrower",
    "TopLevelStruct",
    "TwoMethodsWithSimilarCapitalization",
    "UmaskCheck",
    "UnaryOperation",
    "UnionProperties",
    "UpcasingReflectable",
    "UseBundledDependency",
    "UseCalcBase",
    "UsesInterfaceWithProperties",
    "VariadicInvoker",
    "VariadicMethod",
    "VariadicTypeUnion",
    "VirtualMethodPlayground",
    "VoidCallback",
    "WithPrivatePropertyInConstructor",
    "anonymous",
    "cdk16625",
    "cdk22369",
    "composition",
    "derived_class_has_no_properties",
    "homonymous_forward_references",
    "interface_in_namespace_includes_classes",
    "interface_in_namespace_only_interface",
    "jsii3656",
    "module2530",
    "module2617",
    "module2647",
    "module2689",
    "module2692",
    "module2700",
    "module2702",
    "nodirect",
    "onlystatic",
    "python_self",
    "submodule",
    "union",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import anonymous
from . import cdk16625
from . import cdk22369
from . import composition
from . import derived_class_has_no_properties
from . import homonymous_forward_references
from . import interface_in_namespace_includes_classes
from . import interface_in_namespace_only_interface
from . import jsii3656
from . import module2530
from . import module2617
from . import module2647
from . import module2689
from . import module2692
from . import module2700
from . import module2702
from . import nodirect
from . import onlystatic
from . import python_self
from . import submodule
from . import union

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/_jsii/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

import scope.jsii_calc_base._jsii
import scope.jsii_calc_lib._jsii

__jsii_assembly__ = jsii.JSIIAssembly.load(
    "jsii-calc", "3.20.120", __name__[0:-6], "jsii-calc@3.20.120.jsii.tgz"
)

__all__ = [
    "__jsii_assembly__",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/_jsii/bin/calc 1`] = `
#!/usr/bin/env python

import jsii
import sys

__jsii_assembly__ = jsii.JSIIAssembly.load(
    "jsii-calc", "3.20.120", "jsii_calc", "jsii-calc@3.20.120.jsii.tgz"
)

exit_code = __jsii_assembly__.invokeBinScript("jsii-calc", "calc", sys.argv[1:])
exit(exit_code)

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/_jsii/jsii-calc@3.20.120.jsii.tgz 1`] = `python/src/jsii_calc/_jsii/jsii-calc@3.20.120.jsii.tgz is a tarball`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/anonymous/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.interface(jsii_type="jsii-calc.anonymous.IOptionA")
class IOptionA(typing_extensions.Protocol):
    @jsii.member(jsii_name="doSomething")
    def do_something(self) -> builtins.str:
        ...


class _IOptionAProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.anonymous.IOptionA"

    @jsii.member(jsii_name="doSomething")
    def do_something(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "doSomething", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IOptionA).__jsii_proxy_class__ = lambda : _IOptionAProxy


@jsii.interface(jsii_type="jsii-calc.anonymous.IOptionB")
class IOptionB(typing_extensions.Protocol):
    @jsii.member(jsii_name="doSomethingElse")
    def do_something_else(self) -> builtins.str:
        ...


class _IOptionBProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.anonymous.IOptionB"

    @jsii.member(jsii_name="doSomethingElse")
    def do_something_else(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "doSomethingElse", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IOptionB).__jsii_proxy_class__ = lambda : _IOptionBProxy


class UseOptions(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.anonymous.UseOptions"):
    @jsii.member(jsii_name="consume")
    @builtins.classmethod
    def consume(cls, option: typing.Union[IOptionA, IOptionB]) -> builtins.str:
        '''
        :param option: -
        '''
        return typing.cast(builtins.str, jsii.sinvoke(cls, "consume", [option]))

    @jsii.member(jsii_name="privideAsAny")
    @builtins.classmethod
    def privide_as_any(cls, which: builtins.str) -> typing.Any:
        '''
        :param which: -
        '''
        return typing.cast(typing.Any, jsii.sinvoke(cls, "privideAsAny", [which]))

    @jsii.member(jsii_name="provide")
    @builtins.classmethod
    def provide(cls, which: builtins.str) -> typing.Union[IOptionA, IOptionB]:
        '''
        :param which: -
        '''
        return typing.cast(typing.Union[IOptionA, IOptionB], jsii.sinvoke(cls, "provide", [which]))


__all__ = [
    "IOptionA",
    "IOptionB",
    "UseOptions",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/cdk16625/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

from .. import IRandomNumberGenerator as _IRandomNumberGenerator_9643a8b9


class Cdk16625(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.cdk16625.Cdk16625",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="test")
    def test(self) -> None:
        '''Run this function to verify that everything is working as it should.'''
        return typing.cast(None, jsii.invoke(self, "test", []))

    @jsii.member(jsii_name="unwrap")
    @abc.abstractmethod
    def _unwrap(self, gen: _IRandomNumberGenerator_9643a8b9) -> jsii.Number:
        '''Implement this functin to return \`\`gen.next()\`\`. It is extremely important that the \`\`donotimport\`\` submodule is NEVER explicitly loaded in the testing application (otherwise this test is void).

        :param gen: a VERY pseudo random number generator.
        '''
        ...


class _Cdk16625Proxy(Cdk16625):
    @jsii.member(jsii_name="unwrap")
    def _unwrap(self, gen: _IRandomNumberGenerator_9643a8b9) -> jsii.Number:
        '''Implement this functin to return \`\`gen.next()\`\`. It is extremely important that the \`\`donotimport\`\` submodule is NEVER explicitly loaded in the testing application (otherwise this test is void).

        :param gen: a VERY pseudo random number generator.
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "unwrap", [gen]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Cdk16625).__jsii_proxy_class__ = lambda : _Cdk16625Proxy


__all__ = [
    "Cdk16625",
    "donotimport",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import donotimport

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/cdk16625/donotimport/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from ... import IRandomNumberGenerator as _IRandomNumberGenerator_9643a8b9


@jsii.implements(_IRandomNumberGenerator_9643a8b9)
class UnimportedSubmoduleType(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.cdk16625.donotimport.UnimportedSubmoduleType",
):
    '''This type demonstrates the ability to receive a callback argument that has a type from a submodule not explicitly imported in the user's code.

    This checks
    that all types available in the assembly can be resolved by the runtime
    library, regardless of whether they were explicitly referenced or not.

    :see: https://github.com/aws/aws-cdk/issues/16625
    '''

    def __init__(self, value: jsii.Number) -> None:
        '''
        :param value: -
        '''
        jsii.create(self.__class__, self, [value])

    @jsii.member(jsii_name="next")
    def next(self) -> jsii.Number:
        '''Not quite random, but it'll do.

        :return: 1337
        '''
        return typing.cast(jsii.Number, jsii.invoke(self, "next", []))


__all__ = [
    "UnimportedSubmoduleType",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/cdk22369/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class AcceptsPath(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.cdk22369.AcceptsPath"):
    def __init__(self, *, source_path: builtins.str) -> None:
        '''
        :param source_path: A path that doesn't exist.
        '''
        props = AcceptsPathProps(source_path=source_path)

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="jsii-calc.cdk22369.AcceptsPathProps",
    jsii_struct_bases=[],
    name_mapping={"source_path": "sourcePath"},
)
class AcceptsPathProps:
    def __init__(self, *, source_path: builtins.str) -> None:
        '''
        :param source_path: A path that doesn't exist.
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source_path": source_path,
        }

    @builtins.property
    def source_path(self) -> builtins.str:
        '''A path that doesn't exist.'''
        result = self._values.get("source_path")
        assert result is not None, "Required property 'source_path' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AcceptsPathProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "AcceptsPath",
    "AcceptsPathProps",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/composition/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


class CompositeOperation(
    _scope_jsii_calc_lib_c61f082f.Operation,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.composition.CompositeOperation",
):
    '''Abstract operation composed from an expression of other operations.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''String representation of the value.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property
    @jsii.member(jsii_name="expression")
    @abc.abstractmethod
    def expression(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The expression that this operation consists of.

        Must be implemented by derived classes.
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="value")
    def value(self) -> jsii.Number:
        '''The value.'''
        return typing.cast(jsii.Number, jsii.get(self, "value"))

    @builtins.property
    @jsii.member(jsii_name="decorationPostfixes")
    def decoration_postfixes(self) -> typing.List[builtins.str]:
        '''A set of postfixes to include in a decorated .toString().'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "decorationPostfixes"))

    @decoration_postfixes.setter
    def decoration_postfixes(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "decorationPostfixes", value)

    @builtins.property
    @jsii.member(jsii_name="decorationPrefixes")
    def decoration_prefixes(self) -> typing.List[builtins.str]:
        '''A set of prefixes to include in a decorated .toString().'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "decorationPrefixes"))

    @decoration_prefixes.setter
    def decoration_prefixes(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "decorationPrefixes", value)

    @builtins.property
    @jsii.member(jsii_name="stringStyle")
    def string_style(self) -> "CompositeOperation.CompositionStringStyle":
        '''The .toString() style.'''
        return typing.cast("CompositeOperation.CompositionStringStyle", jsii.get(self, "stringStyle"))

    @string_style.setter
    def string_style(self, value: "CompositeOperation.CompositionStringStyle") -> None:
        jsii.set(self, "stringStyle", value)

    @jsii.enum(
        jsii_type="jsii-calc.composition.CompositeOperation.CompositionStringStyle"
    )
    class CompositionStringStyle(enum.Enum):
        '''Style of .toString() output for CompositeOperation.'''

        NORMAL = "NORMAL"
        '''Normal string expression.'''
        DECORATED = "DECORATED"
        '''Decorated string expression.'''


class _CompositeOperationProxy(
    CompositeOperation,
    jsii.proxy_for(_scope_jsii_calc_lib_c61f082f.Operation), # type: ignore[misc]
):
    @builtins.property
    @jsii.member(jsii_name="expression")
    def expression(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
        '''The expression that this operation consists of.

        Must be implemented by derived classes.
        '''
        return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "expression"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, CompositeOperation).__jsii_proxy_class__ = lambda : _CompositeOperationProxy


__all__ = [
    "CompositeOperation",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/derived_class_has_no_properties/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class Base(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DerivedClassHasNoProperties.Base",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="prop")
    def prop(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "prop"))

    @prop.setter
    def prop(self, value: builtins.str) -> None:
        jsii.set(self, "prop", value)


class Derived(
    Base,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.DerivedClassHasNoProperties.Derived",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


__all__ = [
    "Base",
    "Derived",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/homonymous_forward_references/__init__.py 1`] = `
'''
Verifies homonymous forward references don't trip the Python type checker

This has been an issue when stub functions were introduced to create a reliable source for type checking
information, which was reported in https://github.com/aws/jsii/issues/3818.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

__all__ = [
    "bar",
    "foo",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import bar
from . import foo

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/homonymous_forward_references/bar/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


class Consumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.homonymousForwardReferences.bar.Consumer",
):
    @jsii.member(jsii_name="consume")
    @builtins.classmethod
    def consume(
        cls,
        *,
        homonymous: typing.Union["Homonymous", typing.Dict[builtins.str, typing.Any]],
    ) -> "Homonymous":
        '''
        :param homonymous: 
        '''
        props = ConsumerProps(homonymous=homonymous)

        return typing.cast("Homonymous", jsii.sinvoke(cls, "consume", [props]))


@jsii.data_type(
    jsii_type="jsii-calc.homonymousForwardReferences.bar.ConsumerProps",
    jsii_struct_bases=[],
    name_mapping={"homonymous": "homonymous"},
)
class ConsumerProps:
    def __init__(
        self,
        *,
        homonymous: typing.Union["Homonymous", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param homonymous: 
        '''
        if isinstance(homonymous, dict):
            homonymous = Homonymous(**homonymous)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "homonymous": homonymous,
        }

    @builtins.property
    def homonymous(self) -> "Homonymous":
        result = self._values.get("homonymous")
        assert result is not None, "Required property 'homonymous' is missing"
        return typing.cast("Homonymous", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConsumerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.homonymousForwardReferences.bar.Homonymous",
    jsii_struct_bases=[],
    name_mapping={"numeric_property": "numericProperty"},
)
class Homonymous:
    def __init__(self, *, numeric_property: jsii.Number) -> None:
        '''
        :param numeric_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "numeric_property": numeric_property,
        }

    @builtins.property
    def numeric_property(self) -> jsii.Number:
        result = self._values.get("numeric_property")
        assert result is not None, "Required property 'numeric_property' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Homonymous(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Consumer",
    "ConsumerProps",
    "Homonymous",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/homonymous_forward_references/foo/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


class Consumer(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.homonymousForwardReferences.foo.Consumer",
):
    @jsii.member(jsii_name="consume")
    @builtins.classmethod
    def consume(
        cls,
        *,
        homonymous: typing.Union["Homonymous", typing.Dict[builtins.str, typing.Any]],
    ) -> "Homonymous":
        '''
        :param homonymous: 
        '''
        props = ConsumerProps(homonymous=homonymous)

        return typing.cast("Homonymous", jsii.sinvoke(cls, "consume", [props]))


@jsii.data_type(
    jsii_type="jsii-calc.homonymousForwardReferences.foo.ConsumerProps",
    jsii_struct_bases=[],
    name_mapping={"homonymous": "homonymous"},
)
class ConsumerProps:
    def __init__(
        self,
        *,
        homonymous: typing.Union["Homonymous", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param homonymous: 
        '''
        if isinstance(homonymous, dict):
            homonymous = Homonymous(**homonymous)
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "homonymous": homonymous,
        }

    @builtins.property
    def homonymous(self) -> "Homonymous":
        result = self._values.get("homonymous")
        assert result is not None, "Required property 'homonymous' is missing"
        return typing.cast("Homonymous", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConsumerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.homonymousForwardReferences.foo.Homonymous",
    jsii_struct_bases=[],
    name_mapping={"string_property": "stringProperty"},
)
class Homonymous:
    def __init__(self, *, string_property: builtins.str) -> None:
        '''
        :param string_property: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "string_property": string_property,
        }

    @builtins.property
    def string_property(self) -> builtins.str:
        result = self._values.get("string_property")
        assert result is not None, "Required property 'string_property' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Homonymous(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Consumer",
    "ConsumerProps",
    "Homonymous",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/interface_in_namespace_includes_classes/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class Foo(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.InterfaceInNamespaceIncludesClasses.Foo",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="bar")
    def bar(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bar"))

    @bar.setter
    def bar(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "bar", value)


@jsii.data_type(
    jsii_type="jsii-calc.InterfaceInNamespaceIncludesClasses.Hello",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo"},
)
class Hello:
    def __init__(self, *, foo: jsii.Number) -> None:
        '''
        :param foo: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }

    @builtins.property
    def foo(self) -> jsii.Number:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Hello(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Foo",
    "Hello",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/interface_in_namespace_only_interface/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.data_type(
    jsii_type="jsii-calc.InterfaceInNamespaceOnlyInterface.Hello",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo"},
)
class Hello:
    def __init__(self, *, foo: jsii.Number) -> None:
        '''
        :param foo: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }

    @builtins.property
    def foo(self) -> jsii.Number:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Hello(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Hello",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/jsii3656/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.data_type(
    jsii_type="jsii-calc.jsii3656.ImplementMeOpts",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "count": "count"},
)
class ImplementMeOpts:
    def __init__(
        self,
        *,
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param name: 
        :param count: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if count is not None:
            self._values["count"] = count

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ImplementMeOpts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OverrideMe(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.jsii3656.OverrideMe",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="callAbstract")
    @builtins.classmethod
    def call_abstract(cls, receiver: "OverrideMe") -> builtins.bool:
        '''
        :param receiver: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "callAbstract", [receiver]))

    @jsii.member(jsii_name="implementMe")
    @abc.abstractmethod
    def implement_me(
        self,
        *,
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
    ) -> builtins.bool:
        '''
        :param name: 
        :param count: 
        '''
        ...


class _OverrideMeProxy(OverrideMe):
    @jsii.member(jsii_name="implementMe")
    def implement_me(
        self,
        *,
        name: builtins.str,
        count: typing.Optional[jsii.Number] = None,
    ) -> builtins.bool:
        '''
        :param name: 
        :param count: 
        '''
        opts = ImplementMeOpts(name=name, count=count)

        return typing.cast(builtins.bool, jsii.invoke(self, "implementMe", [opts]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, OverrideMe).__jsii_proxy_class__ = lambda : _OverrideMeProxy


__all__ = [
    "ImplementMeOpts",
    "OverrideMe",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2530/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class MyClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2530.MyClass"):
    '''Verifies a method with parameters "_" can be generated.

    :see: https://github.com/aws/jsii/issues/2530
    '''

    def __init__(self, _: jsii.Number) -> None:
        '''
        :param _: -
        '''
        jsii.create(self.__class__, self, [_])

    @jsii.member(jsii_name="bar")
    @builtins.classmethod
    def bar(cls, _: builtins.bool) -> None:
        '''
        :param _: -
        '''
        return typing.cast(None, jsii.sinvoke(cls, "bar", [_]))

    @jsii.member(jsii_name="foo")
    def foo(self, _: builtins.str) -> None:
        '''
        :param _: -
        '''
        return typing.cast(None, jsii.invoke(self, "foo", [_]))


__all__ = [
    "MyClass",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2617/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class OnlyStatics(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.module2617.OnlyStatics",
):
    @jsii.member(jsii_name="bar")
    @builtins.classmethod
    def bar(cls) -> None:
        return typing.cast(None, jsii.sinvoke(cls, "bar", []))

    @jsii.member(jsii_name="foo")
    @builtins.classmethod
    def foo(cls) -> None:
        return typing.cast(None, jsii.sinvoke(cls, "foo", []))


__all__ = [
    "OnlyStatics",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2647/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import scope.jsii_calc_base_of_base as _scope_jsii_calc_base_of_base_49fa37fe
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


@jsii.implements(_scope_jsii_calc_lib_c61f082f.IFriendly)
class ExtendAndImplement(
    _scope_jsii_calc_lib_c61f082f.BaseFor2647,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.module2647.ExtendAndImplement",
):
    '''This class falls into the category of "multiple bases" from a different module from a go code gen perspective.

    :see: https://github.com/aws/jsii/issues/2647
    '''

    def __init__(self, very: _scope_jsii_calc_base_of_base_49fa37fe.Very) -> None:
        '''
        :param very: -

        :stability: deprecated
        '''
        jsii.create(self.__class__, self, [very])

    @jsii.member(jsii_name="hello")
    def hello(self) -> builtins.str:
        '''Say hello!'''
        return typing.cast(builtins.str, jsii.invoke(self, "hello", []))

    @jsii.member(jsii_name="localMethod")
    def local_method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "localMethod", []))


__all__ = [
    "ExtendAndImplement",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2689/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

__all__ = [
    "methods",
    "props",
    "retval",
    "structs",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import methods
from . import props
from . import retval
from . import structs

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2689/methods/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


class MyClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.module2689.methods.MyClass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="bar")
    def bar(
        self,
        _bar: typing.Mapping[builtins.str, typing.Union[_scope_jsii_calc_base_734f0262.BaseProps, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''
        :param _bar: -
        '''
        return typing.cast(None, jsii.invoke(self, "bar", [_bar]))

    @jsii.member(jsii_name="foo")
    def foo(
        self,
        _values: typing.Sequence[_scope_jsii_calc_lib_c61f082f.Number],
    ) -> None:
        '''
        :param _values: -
        '''
        return typing.cast(None, jsii.invoke(self, "foo", [_values]))


__all__ = [
    "MyClass",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2689/props/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


class MyClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2689.props.MyClass"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="bar")
    def bar(
        self,
    ) -> typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps]:
        return typing.cast(typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps], jsii.get(self, "bar"))

    @builtins.property
    @jsii.member(jsii_name="foo")
    def foo(self) -> typing.List[_scope_jsii_calc_lib_c61f082f.Number]:
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.Number], jsii.get(self, "foo"))


__all__ = [
    "MyClass",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2689/retval/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


class MyClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2689.retval.MyClass"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="bar")
    def bar(
        self,
    ) -> typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps]:
        return typing.cast(typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps], jsii.invoke(self, "bar", []))

    @jsii.member(jsii_name="foo")
    def foo(self) -> typing.List[_scope_jsii_calc_lib_c61f082f.Number]:
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.Number], jsii.invoke(self, "foo", []))


__all__ = [
    "MyClass",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2689/structs/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262
import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


@jsii.data_type(
    jsii_type="jsii-calc.module2689.structs.MyStruct",
    jsii_struct_bases=[],
    name_mapping={"base_map": "baseMap", "numbers": "numbers"},
)
class MyStruct:
    def __init__(
        self,
        *,
        base_map: typing.Mapping[builtins.str, typing.Union[_scope_jsii_calc_base_734f0262.BaseProps, typing.Dict[builtins.str, typing.Any]]],
        numbers: typing.Sequence[_scope_jsii_calc_lib_c61f082f.Number],
    ) -> None:
        '''
        :param base_map: 
        :param numbers: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "base_map": base_map,
            "numbers": numbers,
        }

    @builtins.property
    def base_map(
        self,
    ) -> typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps]:
        result = self._values.get("base_map")
        assert result is not None, "Required property 'base_map' is missing"
        return typing.cast(typing.Mapping[builtins.str, _scope_jsii_calc_base_734f0262.BaseProps], result)

    @builtins.property
    def numbers(self) -> typing.List[_scope_jsii_calc_lib_c61f082f.Number]:
        result = self._values.get("numbers")
        assert result is not None, "Required property 'numbers' is missing"
        return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MyStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "MyStruct",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2692/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

__all__ = [
    "submodule1",
    "submodule2",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import submodule1
from . import submodule2

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2692/submodule1/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


@jsii.data_type(
    jsii_type="jsii-calc.module2692.submodule1.Bar",
    jsii_struct_bases=[],
    name_mapping={"bar1": "bar1"},
)
class Bar:
    def __init__(self, *, bar1: builtins.str) -> None:
        '''
        :param bar1: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bar1": bar1,
        }

    @builtins.property
    def bar1(self) -> builtins.str:
        result = self._values.get("bar1")
        assert result is not None, "Required property 'bar1' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Bar(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Bar",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2692/submodule2/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from ..submodule1 import Bar as _Bar_ec7eccad


@jsii.data_type(
    jsii_type="jsii-calc.module2692.submodule2.Bar",
    jsii_struct_bases=[],
    name_mapping={"bar2": "bar2"},
)
class Bar:
    def __init__(self, *, bar2: builtins.str) -> None:
        '''
        :param bar2: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bar2": bar2,
        }

    @builtins.property
    def bar2(self) -> builtins.str:
        result = self._values.get("bar2")
        assert result is not None, "Required property 'bar2' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Bar(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.module2692.submodule2.Foo",
    jsii_struct_bases=[Bar, _Bar_ec7eccad],
    name_mapping={"bar2": "bar2", "bar1": "bar1", "foo2": "foo2"},
)
class Foo(Bar, _Bar_ec7eccad):
    def __init__(
        self,
        *,
        bar2: builtins.str,
        bar1: builtins.str,
        foo2: builtins.str,
    ) -> None:
        '''
        :param bar2: 
        :param bar1: 
        :param foo2: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bar2": bar2,
            "bar1": bar1,
            "foo2": foo2,
        }

    @builtins.property
    def bar2(self) -> builtins.str:
        result = self._values.get("bar2")
        assert result is not None, "Required property 'bar2' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def bar1(self) -> builtins.str:
        result = self._values.get("bar1")
        assert result is not None, "Required property 'bar1' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def foo2(self) -> builtins.str:
        result = self._values.get("foo2")
        assert result is not None, "Required property 'foo2' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Foo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Bar",
    "Foo",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2700/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


@jsii.interface(jsii_type="jsii-calc.module2700.IFoo")
class IFoo(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="baz")
    def baz(self) -> jsii.Number:
        ...

    @jsii.member(jsii_name="bar")
    def bar(self) -> builtins.str:
        ...


class _IFooProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2700.IFoo"

    @builtins.property
    @jsii.member(jsii_name="baz")
    def baz(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "baz"))

    @jsii.member(jsii_name="bar")
    def bar(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "bar", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFoo).__jsii_proxy_class__ = lambda : _IFooProxy


@jsii.implements(IFoo)
class Base(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2700.Base"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="bar")
    def bar(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "bar", []))

    @builtins.property
    @jsii.member(jsii_name="baz")
    def baz(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "baz"))


@jsii.implements(IFoo)
class Derived(Base, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2700.Derived"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="zoo")
    def zoo(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "zoo", []))


__all__ = [
    "Base",
    "Derived",
    "IFoo",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/module2702/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import scope.jsii_calc_base as _scope_jsii_calc_base_734f0262


class Class1(
    _scope_jsii_calc_base_734f0262.Base,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.module2702.Class1",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="base")
    def base(self) -> None:
        return typing.cast(None, jsii.invoke(self, "base", []))


class Class2(
    _scope_jsii_calc_base_734f0262.Base,
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.module2702.Class2",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="base")
    def base(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "base"))


@jsii.implements(_scope_jsii_calc_base_734f0262.IBaseInterface)
class Class3(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2702.Class3"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="bar")
    def bar(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bar", []))

    @jsii.member(jsii_name="foo")
    def foo(self) -> None:
        return typing.cast(None, jsii.invoke(self, "foo", []))

    @jsii.member(jsii_name="iBaseInterface")
    def i_base_interface(self) -> None:
        return typing.cast(None, jsii.invoke(self, "iBaseInterface", []))


@jsii.interface(jsii_type="jsii-calc.module2702.IBaz")
class IBaz(_scope_jsii_calc_base_734f0262.IBaseInterface, typing_extensions.Protocol):
    @jsii.member(jsii_name="bazMethod")
    def baz_method(self) -> None:
        ...


class _IBazProxy(
    jsii.proxy_for(_scope_jsii_calc_base_734f0262.IBaseInterface), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2702.IBaz"

    @jsii.member(jsii_name="bazMethod")
    def baz_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bazMethod", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IBaz).__jsii_proxy_class__ = lambda : _IBazProxy


@jsii.interface(jsii_type="jsii-calc.module2702.IConstruct")
class IConstruct(typing_extensions.Protocol):
    @jsii.member(jsii_name="constructMethod")
    def construct_method(self) -> None:
        ...


class _IConstructProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2702.IConstruct"

    @jsii.member(jsii_name="constructMethod")
    def construct_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "constructMethod", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IConstruct).__jsii_proxy_class__ = lambda : _IConstructProxy


@jsii.interface(jsii_type="jsii-calc.module2702.IFoo")
class IFoo(_scope_jsii_calc_base_734f0262.IBaseInterface, typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="iBaseInterface")
    def i_base_interface(self) -> builtins.str:
        ...


class _IFooProxy(
    jsii.proxy_for(_scope_jsii_calc_base_734f0262.IBaseInterface), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2702.IFoo"

    @builtins.property
    @jsii.member(jsii_name="iBaseInterface")
    def i_base_interface(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "iBaseInterface"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFoo).__jsii_proxy_class__ = lambda : _IFooProxy


@jsii.interface(jsii_type="jsii-calc.module2702.IResource")
class IResource(IConstruct, typing_extensions.Protocol):
    @jsii.member(jsii_name="resourceMethod")
    def resource_method(self) -> None:
        ...


class _IResourceProxy(
    jsii.proxy_for(IConstruct), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2702.IResource"

    @jsii.member(jsii_name="resourceMethod")
    def resource_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resourceMethod", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IResource).__jsii_proxy_class__ = lambda : _IResourceProxy


@jsii.interface(jsii_type="jsii-calc.module2702.IVpc")
class IVpc(IResource, typing_extensions.Protocol):
    @jsii.member(jsii_name="vpcMethod")
    def vpc_method(self) -> None:
        ...


class _IVpcProxy(
    jsii.proxy_for(IResource), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.module2702.IVpc"

    @jsii.member(jsii_name="vpcMethod")
    def vpc_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "vpcMethod", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpc).__jsii_proxy_class__ = lambda : _IVpcProxy


@jsii.implements(IBaz)
class Baz(Class3, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2702.Baz"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="bazMethod")
    def baz_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "bazMethod", []))


@jsii.implements(IConstruct)
class Construct(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2702.Construct"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="constructMethod")
    def construct_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "constructMethod", []))


@jsii.implements(IResource)
class Resource(
    Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.module2702.Resource",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="resourceMethod")
    def resource_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resourceMethod", []))


class _ResourceProxy(Resource):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Resource).__jsii_proxy_class__ = lambda : _ResourceProxy


@jsii.implements(IVpc)
class Vpc(Resource, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.module2702.Vpc"):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="vpcMethod")
    def vpc_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "vpcMethod", []))


__all__ = [
    "Baz",
    "Class1",
    "Class2",
    "Class3",
    "Construct",
    "IBaz",
    "IConstruct",
    "IFoo",
    "IResource",
    "IVpc",
    "Resource",
    "Vpc",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/nodirect/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

__all__ = [
    "sub1",
    "sub2",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import sub1
from . import sub2

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/nodirect/sub1/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


class TypeFromSub1(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.nodirect.sub1.TypeFromSub1",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sub1")
    def sub1(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "sub1", []))


__all__ = [
    "TypeFromSub1",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/nodirect/sub2/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


class TypeFromSub2(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.nodirect.sub2.TypeFromSub2",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="sub2")
    def sub2(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "sub2", []))


__all__ = [
    "TypeFromSub2",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/onlystatic/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class OnlyStaticMethods(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.onlystatic.OnlyStaticMethods",
):
    '''Test for https://github.com/aws/jsii/issues/2617.'''

    @jsii.member(jsii_name="staticMethod")
    @builtins.classmethod
    def static_method(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sinvoke(cls, "staticMethod", []))


__all__ = [
    "OnlyStaticMethods",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/py.typed 1`] = `


`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/python_self/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *


class ClassWithSelf(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.PythonSelf.ClassWithSelf",
):
    def __init__(self_, self: builtins.str) -> None:
        '''
        :param self: -
        '''
        jsii.create(self_.__class__, self_, [self])

    @jsii.member(jsii_name="method")
    def method(self_, self: jsii.Number) -> builtins.str:
        '''
        :param self: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self_, "method", [self]))

    @builtins.property
    @jsii.member(jsii_name="self")
    def self(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "self"))


class ClassWithSelfKwarg(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.PythonSelf.ClassWithSelfKwarg",
):
    def __init__(self_, *, self: builtins.str) -> None:
        '''
        :param self: 
        '''
        props = StructWithSelf(self=self)

        jsii.create(self_.__class__, self_, [props])

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "StructWithSelf":
        return typing.cast("StructWithSelf", jsii.get(self, "props"))


@jsii.interface(jsii_type="jsii-calc.PythonSelf.IInterfaceWithSelf")
class IInterfaceWithSelf(typing_extensions.Protocol):
    @jsii.member(jsii_name="method")
    def method(self_, self: jsii.Number) -> builtins.str:
        '''
        :param self: -
        '''
        ...


class _IInterfaceWithSelfProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.PythonSelf.IInterfaceWithSelf"

    @jsii.member(jsii_name="method")
    def method(self_, self: jsii.Number) -> builtins.str:
        '''
        :param self: -
        '''
        return typing.cast(builtins.str, jsii.invoke(self_, "method", [self]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceWithSelf).__jsii_proxy_class__ = lambda : _IInterfaceWithSelfProxy


@jsii.data_type(
    jsii_type="jsii-calc.PythonSelf.StructWithSelf",
    jsii_struct_bases=[],
    name_mapping={"self": "self"},
)
class StructWithSelf:
    def __init__(self_, *, self: builtins.str) -> None:
        '''
        :param self: 
        '''
        self_._values: typing.Dict[builtins.str, typing.Any] = {
            "self": self,
        }

    @builtins.property
    def self(self) -> builtins.str:
        result = self._values.get("self")
        assert result is not None, "Required property 'self' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StructWithSelf(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "ClassWithSelf",
    "ClassWithSelfKwarg",
    "IInterfaceWithSelf",
    "StructWithSelf",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/__init__.py 1`] = `
'''
# Read you, read me

This is the readme of the \`jsii-calc.submodule\` module.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

from .. import AllTypes as _AllTypes_b08307c5
from .child import (
    Awesomeness as _Awesomeness_d37a24df,
    Goodness as _Goodness_2df26737,
    SomeEnum as _SomeEnum_b2e41d92,
    SomeStruct as _SomeStruct_91627123,
)
from .nested_submodule.deeply_nested import INamespaced as _INamespaced_e2f386ad
from .param import SpecialParameter as _SpecialParameter_5bbf34a2


@jsii.data_type(
    jsii_type="jsii-calc.submodule.Default",
    jsii_struct_bases=[],
    name_mapping={"foo": "foo"},
)
class Default:
    def __init__(self, *, foo: jsii.Number) -> None:
        '''A struct named "Default".

        :param foo: 

        :see: https://github.com/aws/jsii/issues/2637
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "foo": foo,
        }

    @builtins.property
    def foo(self) -> jsii.Number:
        result = self._values.get("foo")
        assert result is not None, "Required property 'foo' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Default(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_INamespaced_e2f386ad)
class MyClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.submodule.MyClass"):
    def __init__(self, *, prop: _SomeEnum_b2e41d92) -> None:
        '''
        :param prop: 
        '''
        props = _SomeStruct_91627123(prop=prop)

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="methodWithSpecialParam")
    def method_with_special_param(self, *, value: builtins.str) -> builtins.str:
        '''
        :param value: 
        '''
        param = _SpecialParameter_5bbf34a2(value=value)

        return typing.cast(builtins.str, jsii.invoke(self, "methodWithSpecialParam", [param]))

    @builtins.property
    @jsii.member(jsii_name="awesomeness")
    def awesomeness(self) -> _Awesomeness_d37a24df:
        return typing.cast(_Awesomeness_d37a24df, jsii.get(self, "awesomeness"))

    @builtins.property
    @jsii.member(jsii_name="definedAt")
    def defined_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "definedAt"))

    @builtins.property
    @jsii.member(jsii_name="goodness")
    def goodness(self) -> _Goodness_2df26737:
        return typing.cast(_Goodness_2df26737, jsii.get(self, "goodness"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _SomeStruct_91627123:
        return typing.cast(_SomeStruct_91627123, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="allTypes")
    def all_types(self) -> typing.Optional[_AllTypes_b08307c5]:
        return typing.cast(typing.Optional[_AllTypes_b08307c5], jsii.get(self, "allTypes"))

    @all_types.setter
    def all_types(self, value: typing.Optional[_AllTypes_b08307c5]) -> None:
        jsii.set(self, "allTypes", value)


__all__ = [
    "Default",
    "MyClass",
    "back_references",
    "child",
    "isolated",
    "nested_submodule",
    "param",
    "returnsparam",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import back_references
from . import child
from . import isolated
from . import nested_submodule
from . import param
from . import returnsparam

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/back_references/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from .. import MyClass as _MyClass_a2fdc0b6


@jsii.data_type(
    jsii_type="jsii-calc.submodule.back_references.MyClassReference",
    jsii_struct_bases=[],
    name_mapping={"reference": "reference"},
)
class MyClassReference:
    def __init__(self, *, reference: _MyClass_a2fdc0b6) -> None:
        '''
        :param reference: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "reference": reference,
        }

    @builtins.property
    def reference(self) -> _MyClass_a2fdc0b6:
        result = self._values.get("reference")
        assert result is not None, "Required property 'reference' is missing"
        return typing.cast(_MyClass_a2fdc0b6, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MyClassReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "MyClassReference",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/child/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


@jsii.enum(jsii_type="jsii-calc.submodule.child.Awesomeness")
class Awesomeness(enum.Enum):
    AWESOME = "AWESOME"
    '''It was awesome!'''


@jsii.enum(jsii_type="jsii-calc.submodule.child.Goodness")
class Goodness(enum.Enum):
    PRETTY_GOOD = "PRETTY_GOOD"
    '''It's pretty good.'''
    REALLY_GOOD = "REALLY_GOOD"
    '''It's really good.'''
    AMAZINGLY_GOOD = "AMAZINGLY_GOOD"
    '''It's amazingly good.'''


class InnerClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.submodule.child.InnerClass",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="staticProp")
    def STATIC_PROP(cls) -> "SomeStruct":
        return typing.cast("SomeStruct", jsii.sget(cls, "staticProp"))


class OuterClass(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.submodule.child.OuterClass",
):
    '''Checks that classes can self-reference during initialization.

    :see: : https://github.com/aws/jsii/pull/1706
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property
    @jsii.member(jsii_name="innerClass")
    def inner_class(self) -> InnerClass:
        return typing.cast(InnerClass, jsii.get(self, "innerClass"))


@jsii.enum(jsii_type="jsii-calc.submodule.child.SomeEnum")
class SomeEnum(enum.Enum):
    SOME = "SOME"


@jsii.data_type(
    jsii_type="jsii-calc.submodule.child.SomeStruct",
    jsii_struct_bases=[],
    name_mapping={"prop": "prop"},
)
class SomeStruct:
    def __init__(self, *, prop: SomeEnum) -> None:
        '''
        :param prop: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "prop": prop,
        }

    @builtins.property
    def prop(self) -> SomeEnum:
        result = self._values.get("prop")
        assert result is not None, "Required property 'prop' is missing"
        return typing.cast(SomeEnum, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SomeStruct(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.submodule.child.Structure",
    jsii_struct_bases=[],
    name_mapping={"bool": "bool"},
)
class Structure:
    def __init__(self, *, bool: builtins.bool) -> None:
        '''
        :param bool: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bool": bool,
        }

    @builtins.property
    def bool(self) -> builtins.bool:
        result = self._values.get("bool")
        assert result is not None, "Required property 'bool' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Structure(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="jsii-calc.submodule.child.KwargsProps",
    jsii_struct_bases=[SomeStruct],
    name_mapping={"prop": "prop", "extra": "extra"},
)
class KwargsProps(SomeStruct):
    def __init__(
        self,
        *,
        prop: SomeEnum,
        extra: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param prop: 
        :param extra: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "prop": prop,
        }
        if extra is not None:
            self._values["extra"] = extra

    @builtins.property
    def prop(self) -> SomeEnum:
        result = self._values.get("prop")
        assert result is not None, "Required property 'prop' is missing"
        return typing.cast(SomeEnum, result)

    @builtins.property
    def extra(self) -> typing.Optional[builtins.str]:
        result = self._values.get("extra")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KwargsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Awesomeness",
    "Goodness",
    "InnerClass",
    "KwargsProps",
    "OuterClass",
    "SomeEnum",
    "SomeStruct",
    "Structure",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/isolated/__init__.py 1`] = `
'''
# Read you, read me

This is the readme of the \`jsii-calc.submodule.isolated\` module.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from ..child import (
    KwargsProps as _KwargsProps_c7855dcf, SomeEnum as _SomeEnum_b2e41d92
)


class Kwargs(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.submodule.isolated.Kwargs"):
    '''Ensures imports are correctly registered for kwargs lifted properties from super-structs.'''

    @jsii.member(jsii_name="method")
    @builtins.classmethod
    def method(
        cls,
        *,
        extra: typing.Optional[builtins.str] = None,
        prop: _SomeEnum_b2e41d92,
    ) -> builtins.bool:
        '''
        :param extra: 
        :param prop: 
        '''
        props = _KwargsProps_c7855dcf(extra=extra, prop=prop)

        return typing.cast(builtins.bool, jsii.sinvoke(cls, "method", [props]))


__all__ = [
    "Kwargs",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/nested_submodule/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from ..child import Goodness as _Goodness_2df26737
from .deeply_nested import INamespaced as _INamespaced_e2f386ad


@jsii.implements(_INamespaced_e2f386ad)
class Namespaced(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="jsii-calc.submodule.nested_submodule.Namespaced",
):
    @builtins.property
    @jsii.member(jsii_name="definedAt")
    def defined_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "definedAt"))

    @builtins.property
    @jsii.member(jsii_name="goodness")
    @abc.abstractmethod
    def goodness(self) -> _Goodness_2df26737:
        ...


class _NamespacedProxy(Namespaced):
    @builtins.property
    @jsii.member(jsii_name="goodness")
    def goodness(self) -> _Goodness_2df26737:
        return typing.cast(_Goodness_2df26737, jsii.get(self, "goodness"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Namespaced).__jsii_proxy_class__ = lambda : _NamespacedProxy


__all__ = [
    "Namespaced",
    "deeply_nested",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import deeply_nested

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/nested_submodule/deeply_nested/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ...._jsii import *


@jsii.interface(
    jsii_type="jsii-calc.submodule.nested_submodule.deeplyNested.INamespaced"
)
class INamespaced(typing_extensions.Protocol):
    @builtins.property
    @jsii.member(jsii_name="definedAt")
    def defined_at(self) -> builtins.str:
        ...


class _INamespacedProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.submodule.nested_submodule.deeplyNested.INamespaced"

    @builtins.property
    @jsii.member(jsii_name="definedAt")
    def defined_at(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "definedAt"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, INamespaced).__jsii_proxy_class__ = lambda : _INamespacedProxy


__all__ = [
    "INamespaced",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/param/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *


@jsii.data_type(
    jsii_type="jsii-calc.submodule.param.SpecialParameter",
    jsii_struct_bases=[],
    name_mapping={"value": "value"},
)
class SpecialParameter:
    def __init__(self, *, value: builtins.str) -> None:
        '''
        :param value: 
        '''
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "value": value,
        }

    @builtins.property
    def value(self) -> builtins.str:
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SpecialParameter(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "SpecialParameter",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/submodule/returnsparam/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ..._jsii import *

from ..param import SpecialParameter as _SpecialParameter_5bbf34a2


class ReturnsSpecialParameter(
    metaclass=jsii.JSIIMeta,
    jsii_type="jsii-calc.submodule.returnsparam.ReturnsSpecialParameter",
):
    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="returnsSpecialParam")
    def returns_special_param(self) -> _SpecialParameter_5bbf34a2:
        return typing.cast(_SpecialParameter_5bbf34a2, jsii.invoke(self, "returnsSpecialParam", []))


__all__ = [
    "ReturnsSpecialParameter",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <outDir>/python/src/jsii_calc/union/__init__.py 1`] = `
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import scope.jsii_calc_lib as _scope_jsii_calc_lib_c61f082f


class ConsumesUnion(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.union.ConsumesUnion"):
    @jsii.member(jsii_name="unionType")
    @builtins.classmethod
    def union_type(
        cls,
        param: typing.Union["IResolvable", "Resolvable", _scope_jsii_calc_lib_c61f082f.IFriendly],
    ) -> None:
        '''
        :param param: -
        '''
        return typing.cast(None, jsii.sinvoke(cls, "unionType", [param]))


@jsii.interface(jsii_type="jsii-calc.union.IResolvable")
class IResolvable(typing_extensions.Protocol):
    @jsii.member(jsii_name="resolve")
    def resolve(self) -> typing.Any:
        ...


class _IResolvableProxy:
    __jsii_type__: typing.ClassVar[str] = "jsii-calc.union.IResolvable"

    @jsii.member(jsii_name="resolve")
    def resolve(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IResolvable).__jsii_proxy_class__ = lambda : _IResolvableProxy


@jsii.implements(IResolvable)
class Resolvable(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.union.Resolvable"):
    @jsii.member(jsii_name="resolve")
    def resolve(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.invoke(self, "resolve", []))


__all__ = [
    "ConsumesUnion",
    "IResolvable",
    "Resolvable",
]

publication.publish()

`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/ 1`] = `
<runtime-type-check-diff>
 ‚îó‚îÅ üìÅ python
    ‚îó‚îÅ üìÅ src
       ‚îó‚îÅ üìÅ jsii_calc
          ‚î£‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ anonymous
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ cdk16625
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚îó‚îÅ üìÅ donotimport
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ cdk22369
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ composition
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ derived_class_has_no_properties
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ homonymous_forward_references
          ‚îÉ  ‚î£‚îÅ üìÅ bar
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚îó‚îÅ üìÅ foo
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ interface_in_namespace_includes_classes
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ interface_in_namespace_only_interface
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ jsii3656
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ module2530
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ module2647
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ module2689
          ‚îÉ  ‚î£‚îÅ üìÅ methods
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚îó‚îÅ üìÅ structs
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ module2692
          ‚îÉ  ‚î£‚îÅ üìÅ submodule1
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚îó‚îÅ üìÅ submodule2
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ python_self
          ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚î£‚îÅ üìÅ submodule
          ‚îÉ  ‚î£‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚î£‚îÅ üìÅ back_references
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚î£‚îÅ üìÅ child
          ‚îÉ  ‚îÉ  ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îÉ  ‚îó‚îÅ üìÅ param
          ‚îÉ     ‚îó‚îÅ üìÑ __init__.py.diff
          ‚îó‚îÅ üìÅ union
             ‚îó‚îÅ üìÑ __init__.py.diff
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/__init__.py.diff 1`] = `
--- python/src/jsii_calc/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/__init__.py	--runtime-type-checking
@@ -111,10 +111,13 @@
     def work_it_all(self, seed: builtins.str) -> builtins.str:
         '''Sets \`\`seed\`\` to \`\`this.property\`\`, then calls \`\`someMethod\`\` with \`\`this.property\`\` and returns the result.
 
         :param seed: a \`\`string\`\`.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8348af6419fc01178f78ba59cea59d0c7437626169866d772f4e957d09e6e13a)
+            check_type(argname="argument seed", value=seed, expected_type=type_hints["seed"])
         return typing.cast(builtins.str, jsii.invoke(self, "workItAll", [seed]))
 
     @builtins.property
     @jsii.member(jsii_name="property")
     @abc.abstractmethod
@@ -131,19 +134,25 @@
     @jsii.member(jsii_name="someMethod")
     def _some_method(self, str: builtins.str) -> builtins.str:
         '''
         :param str: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__06c06b97e36be962012901c4c1f542b3f51b377154f91bf1154d1bd475221829)
+            check_type(argname="argument str", value=str, expected_type=type_hints["str"])
         return typing.cast(builtins.str, jsii.invoke(self, "someMethod", [str]))
 
     @builtins.property
     @jsii.member(jsii_name="property")
     def _property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "property"))
 
     @_property.setter
     def _property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0f076015f51de68c2d0e6902c0d199c9058ad0bff9c11f58b2aae99578ece6ae)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "property", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, AbstractSuite).__jsii_proxy_class__ = lambda : _AbstractSuiteProxy
 
@@ -161,10 +170,13 @@
     @jsii.member(jsii_name="anyIn")
     def any_in(self, inp: typing.Any) -> None:
         '''
         :param inp: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__81a2d86a9598fa10dde4af8bd70d369967edc6febb332dc788702f6aea07f33c)
+            check_type(argname="argument inp", value=inp, expected_type=type_hints["inp"])
         return typing.cast(None, jsii.invoke(self, "anyIn", [inp]))
 
     @jsii.member(jsii_name="anyOut")
     def any_out(self) -> typing.Any:
         return typing.cast(typing.Any, jsii.invoke(self, "anyOut", []))
@@ -172,10 +184,13 @@
     @jsii.member(jsii_name="enumMethod")
     def enum_method(self, value: "StringEnum") -> "StringEnum":
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__56056c33132184bd4ad46f69c534777112c49b9a987cc7b962d4026cf550998c)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast("StringEnum", jsii.invoke(self, "enumMethod", [value]))
 
     @builtins.property
     @jsii.member(jsii_name="enumPropertyValue")
     def enum_property_value(self) -> jsii.Number:
@@ -186,73 +201,97 @@
     def any_array_property(self) -> typing.List[typing.Any]:
         return typing.cast(typing.List[typing.Any], jsii.get(self, "anyArrayProperty"))
 
     @any_array_property.setter
     def any_array_property(self, value: typing.List[typing.Any]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1ab9ae75c746f751d2bf2ac254bcd1bee8eae7281ec936e222c9f29765fdcfa4)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "anyArrayProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="anyMapProperty")
     def any_map_property(self) -> typing.Mapping[builtins.str, typing.Any]:
         return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "anyMapProperty"))
 
     @any_map_property.setter
     def any_map_property(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f88e356a91a703923e622c02850435cc7f632a66f49ca79f00d42590d2928a5e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "anyMapProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="anyProperty")
     def any_property(self) -> typing.Any:
         return typing.cast(typing.Any, jsii.get(self, "anyProperty"))
 
     @any_property.setter
     def any_property(self, value: typing.Any) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d81f1a89ccd850ccdb0b96a43000dfcde30f3542bf797051c754610d641f2316)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "anyProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="arrayProperty")
     def array_property(self) -> typing.List[builtins.str]:
         return typing.cast(typing.List[builtins.str], jsii.get(self, "arrayProperty"))
 
     @array_property.setter
     def array_property(self, value: typing.List[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0c663902e9a8a1db9aff59eb8642a68c944dc2e3385744098d2b51ecf2e2e11f)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "arrayProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="booleanProperty")
     def boolean_property(self) -> builtins.bool:
         return typing.cast(builtins.bool, jsii.get(self, "booleanProperty"))
 
     @boolean_property.setter
     def boolean_property(self, value: builtins.bool) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__106a83d3c77dbb6dbc6fcd706bca888d57ec37cd4beedf7dcc9d7d4428f44845)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "booleanProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="dateProperty")
     def date_property(self) -> datetime.datetime:
         return typing.cast(datetime.datetime, jsii.get(self, "dateProperty"))
 
     @date_property.setter
     def date_property(self, value: datetime.datetime) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5e62ea2f9629943c1138cad77629f47906644279c178b9436e4303e5a5f74c8a)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "dateProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="enumProperty")
     def enum_property(self) -> "AllTypesEnum":
         return typing.cast("AllTypesEnum", jsii.get(self, "enumProperty"))
 
     @enum_property.setter
     def enum_property(self, value: "AllTypesEnum") -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f0d83d5dde352e12690bd34359b2272194b20ad0d4585d4cd235a62a68413cc7)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "enumProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="jsonProperty")
     def json_property(self) -> typing.Mapping[typing.Any, typing.Any]:
         return typing.cast(typing.Mapping[typing.Any, typing.Any], jsii.get(self, "jsonProperty"))
 
     @json_property.setter
     def json_property(self, value: typing.Mapping[typing.Any, typing.Any]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8cddc5c03b0b87366a7bf274aedf92ced502b23fe811780c7f8c3da532cba3fc)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "jsonProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="mapProperty")
     def map_property(
@@ -263,28 +302,37 @@
     @map_property.setter
     def map_property(
         self,
         value: typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.Number],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ce34799b1443789feb28cffe434f5bcbb9cb940065992aa75dbb30eb89cd78e6)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mapProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="numberProperty")
     def number_property(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.get(self, "numberProperty"))
 
     @number_property.setter
     def number_property(self, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c8fb4d044e2e7432d7e661aafdb286ebf21dfe5a82b9908dee57945f6892a63e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "numberProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="stringProperty")
     def string_property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "stringProperty"))
 
     @string_property.setter
     def string_property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4e3dc199e54a9fbd40ceb20cecf887aa2aeca670e9ba223707466d9670eec9b9)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "stringProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unionArrayProperty")
     def union_array_property(
@@ -295,10 +343,13 @@
     @union_array_property.setter
     def union_array_property(
         self,
         value: typing.List[typing.Union[jsii.Number, _scope_jsii_calc_lib_c61f082f.NumericValue]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4a9e87035008a2c1b649b911c8cfc02f2723230d8ced957948b2948c76caf61a)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionArrayProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unionMapProperty")
     def union_map_property(
@@ -309,10 +360,13 @@
     @union_map_property.setter
     def union_map_property(
         self,
         value: typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__62ebee42e1871545bc2e82cfb9c7fe43b5a607c8f662caff89dda0f0ed99a3df)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionMapProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unionProperty")
     def union_property(
@@ -323,19 +377,25 @@
     @union_property.setter
     def union_property(
         self,
         value: typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number, "Multiply"],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c9be2756a18e8a40eb03cf55231201574f76abf02996a73d0d75fefd1393473d)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unknownArrayProperty")
     def unknown_array_property(self) -> typing.List[typing.Any]:
         return typing.cast(typing.List[typing.Any], jsii.get(self, "unknownArrayProperty"))
 
     @unknown_array_property.setter
     def unknown_array_property(self, value: typing.List[typing.Any]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e49729a44c21aef8c75584ff0991ddba3ee45184cacf816eb1a6a13b99e99ecc)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unknownArrayProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unknownMapProperty")
     def unknown_map_property(self) -> typing.Mapping[builtins.str, typing.Any]:
@@ -344,28 +404,37 @@
     @unknown_map_property.setter
     def unknown_map_property(
         self,
         value: typing.Mapping[builtins.str, typing.Any],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f8de6b30de9bfa884f9de02e2abe57e9394fb7a387b5691f858b7b98817b1db7)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unknownMapProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="unknownProperty")
     def unknown_property(self) -> typing.Any:
         return typing.cast(typing.Any, jsii.get(self, "unknownProperty"))
 
     @unknown_property.setter
     def unknown_property(self, value: typing.Any) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__901c3574a81e006fdf36f73e34f66b34f65ada4bddcb11cd15a51d6e3d9b59e4)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unknownProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="optionalEnumValue")
     def optional_enum_value(self) -> typing.Optional["StringEnum"]:
         return typing.cast(typing.Optional["StringEnum"], jsii.get(self, "optionalEnumValue"))
 
     @optional_enum_value.setter
     def optional_enum_value(self, value: typing.Optional["StringEnum"]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__705bed55c0dbc20a3a1bad9a21931270f0c285e5b3b276e13bca645ffa7ccb0f)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "optionalEnumValue", value)
 
 
 @jsii.enum(jsii_type="jsii-calc.AllTypesEnum")
 class AllTypesEnum(enum.Enum):
@@ -385,36 +454,52 @@
     def get_bar(self, _p1: builtins.str, _p2: jsii.Number) -> None:
         '''
         :param _p1: -
         :param _p2: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__99730dd857f01c8e93755d3e4f1e04f44efd2e63487e37db32f0fae8d36c618e)
+            check_type(argname="argument _p1", value=_p1, expected_type=type_hints["_p1"])
+            check_type(argname="argument _p2", value=_p2, expected_type=type_hints["_p2"])
         return typing.cast(None, jsii.invoke(self, "getBar", [_p1, _p2]))
 
     @jsii.member(jsii_name="getFoo")
     def get_foo(self, with_param: builtins.str) -> builtins.str:
         '''getXxx() is not allowed (see negatives), but getXxx(a, ...) is okay.
 
         :param with_param: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7f25304a2274ca1691dbe05a223f32126250948b15187c5095780e5c9af08c2a)
+            check_type(argname="argument with_param", value=with_param, expected_type=type_hints["with_param"])
         return typing.cast(builtins.str, jsii.invoke(self, "getFoo", [with_param]))
 
     @jsii.member(jsii_name="setBar")
     def set_bar(self, _x: builtins.str, _y: jsii.Number, _z: builtins.bool) -> None:
         '''
         :param _x: -
         :param _y: -
         :param _z: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__12f6979e6d88948e4aebfe8c25ed814c21d19b4b549d6bc2db4620794e706238)
+            check_type(argname="argument _x", value=_x, expected_type=type_hints["_x"])
+            check_type(argname="argument _y", value=_y, expected_type=type_hints["_y"])
+            check_type(argname="argument _z", value=_z, expected_type=type_hints["_z"])
         return typing.cast(None, jsii.invoke(self, "setBar", [_x, _y, _z]))
 
     @jsii.member(jsii_name="setFoo")
     def set_foo(self, _x: builtins.str, _y: jsii.Number) -> None:
         '''setFoo(x) is not allowed (see negatives), but setXxx(a, b, ...) is okay.
 
         :param _x: -
         :param _y: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca978ab380897c8607252c370202d45bc72e8b5cdc52549bb53b870299333d52)
+            check_type(argname="argument _x", value=_x, expected_type=type_hints["_x"])
+            check_type(argname="argument _y", value=_y, expected_type=type_hints["_y"])
         return typing.cast(None, jsii.invoke(self, "setFoo", [_x, _y]))
 
 
 class AmbiguousParameters(
     metaclass=jsii.JSIIMeta,
@@ -430,10 +515,13 @@
         '''
         :param scope_: -
         :param scope: 
         :param props: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__35fb7428c2ad70583f7b280c07cec184905b51e8e896efe6cc88eaf83a6f65c3)
+            check_type(argname="argument scope_", value=scope_, expected_type=type_hints["scope_"])
         props_ = StructParameterType(scope=scope, props=props)
 
         jsii.create(self.__class__, self, [scope_, props_])
 
     @builtins.property
@@ -480,10 +568,13 @@
     @jsii.member(jsii_name="overrideMe")
     def override_me(self, mult: jsii.Number) -> jsii.Number:
         '''
         :param mult: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__49537950cbbeb6e2c62cb1b8a079cc9bb5cc6d06d95cf2229128539d2be886a3)
+            check_type(argname="argument mult", value=mult, expected_type=type_hints["mult"])
         return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMe", [mult]))
 
     @jsii.member(jsii_name="overrideMeToo")
     def override_me_too(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMeToo", []))
@@ -544,10 +635,14 @@
         '''Creates a BinaryOperation.
 
         :param lhs: Left-hand side operand.
         :param rhs: Right-hand side operand.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__408890be1949f7684db536e79081b85d00d72250ca9eb19c74db6ad226564784)
+            check_type(argname="argument lhs", value=lhs, expected_type=type_hints["lhs"])
+            check_type(argname="argument rhs", value=rhs, expected_type=type_hints["rhs"])
         jsii.create(self.__class__, self, [lhs, rhs])
 
     @jsii.member(jsii_name="hello")
     def hello(self) -> builtins.str:
         '''Say hello!'''
@@ -608,10 +703,13 @@
 
         :param value: the value that should be returned.
 
         :return: \`\`value\`\`
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__67894f861ef38d2769b440d2fe71f549cb9e333247b385c5d6ae862b2eb04fc5)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(typing.Any, jsii.invoke(self, "giveItBack", [value]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, BurriedAnonymousObject).__jsii_proxy_class__ = lambda : _BurriedAnonymousObjectProxy
 
@@ -661,18 +759,24 @@
     def add(self, value: jsii.Number) -> None:
         '''Adds a number to the current value.
 
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__106b87a3d0b194bda7cee057654f752c82d9a92a3775bcc3b2dc5cf7814ba84d)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "add", [value]))
 
     @jsii.member(jsii_name="mul")
     def mul(self, value: jsii.Number) -> None:
         '''Multiplies the current value by a number.
 
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b0e9a9c8546dd024e1568b2e6d11bd847e53548d624f33afffdffacc77fe01ef)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "mul", [value]))
 
     @jsii.member(jsii_name="neg")
     def neg(self) -> None:
         '''Negates the current value.'''
@@ -682,10 +786,13 @@
     def pow(self, value: jsii.Number) -> None:
         '''Raises the current value by a power.
 
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c62707f1a80d6bc26c0b74205f8892c1777e6ed97359263df05628018d8ef6fc)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "pow", [value]))
 
     @jsii.member(jsii_name="readUnionValue")
     def read_union_value(self) -> jsii.Number:
         '''Returns teh value of the union property (if defined).'''
@@ -717,20 +824,26 @@
         '''The current value.'''
         return typing.cast(_scope_jsii_calc_lib_c61f082f.NumericValue, jsii.get(self, "curr"))
 
     @curr.setter
     def curr(self, value: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c74abb191c66f86aed2c139ec3e50b0442b6d3bdcd41beb06db17c9b3c5d93d0)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "curr", value)
 
     @builtins.property
     @jsii.member(jsii_name="maxValue")
     def max_value(self) -> typing.Optional[jsii.Number]:
         '''The maximum value allows in this calculator.'''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxValue"))
 
     @max_value.setter
     def max_value(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1af5d9bb897bd9bfc2029e92d33fc306fc090e2d0a9bc0bd70fb01762e798fe6)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "maxValue", value)
 
     @builtins.property
     @jsii.member(jsii_name="unionProperty")
     def union_property(
@@ -742,10 +855,13 @@
     @union_property.setter
     def union_property(
         self,
         value: typing.Optional[typing.Union["Add", "Multiply", "Power"]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__349b2a1dce95cb7ff4c5a7772d81772697767c5f4e7e5fd709847ff5e526c3c1)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionProperty", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.CalculatorProps",
@@ -762,10 +878,14 @@
         '''Properties for Calculator.
 
         :param initial_value: The initial value of the calculator. NOTE: Any number works here, it's fine. Default: 0
         :param maximum_value: The maximum value the calculator can store. Default: none
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__21033948ed66f89716ed818c4cf9e5a38a9252e042231e1e8e1672356d403bef)
+            check_type(argname="argument initial_value", value=initial_value, expected_type=type_hints["initial_value"])
+            check_type(argname="argument maximum_value", value=maximum_value, expected_type=type_hints["maximum_value"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if initial_value is not None:
             self._values["initial_value"] = initial_value
         if maximum_value is not None:
             self._values["maximum_value"] = maximum_value
@@ -811,10 +931,13 @@
         union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]]],
     ) -> None:
         '''
         :param union_property: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9e749834c2e46eee6370de7b60daabbff6e5c16febe9775b98a2b961b0d4e335)
+            check_type(argname="argument union_property", value=union_property, expected_type=type_hints["union_property"])
         jsii.create(self.__class__, self, [union_property])
 
     @builtins.property
     @jsii.member(jsii_name="unionProperty")
     def union_property(
@@ -825,10 +948,13 @@
     @union_property.setter
     def union_property(
         self,
         value: typing.List[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__80b80f78c4ac7fda46ac2aec7ab826a87bef3eaaba64661c90f346972800baf5)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionProperty", value)
 
 
 class ClassWithCollections(
     metaclass=jsii.JSIIMeta,
@@ -841,10 +967,14 @@
     ) -> None:
         '''
         :param map: -
         :param array: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7eb49cfb1282d7f1bd28096ff0407c0806693194f02f5c053936f99756a2a8fd)
+            check_type(argname="argument map", value=map, expected_type=type_hints["map"])
+            check_type(argname="argument array", value=array, expected_type=type_hints["array"])
         jsii.create(self.__class__, self, [map, array])
 
     @jsii.member(jsii_name="createAList")
     @builtins.classmethod
     def create_a_list(cls) -> typing.List[builtins.str]:
@@ -860,37 +990,49 @@
     def static_array(cls) -> typing.List[builtins.str]:  # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(typing.List[builtins.str], jsii.sget(cls, "staticArray"))
 
     @static_array.setter # type: ignore[no-redef]
     def static_array(cls, value: typing.List[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__964903eb68623806c91fc9026cacfdc726cfbb287698530724c5a9938a7bb2ca)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.sset(cls, "staticArray", value)
 
     @jsii.python.classproperty
     @jsii.member(jsii_name="staticMap")
     def static_map(cls) -> typing.Mapping[builtins.str, builtins.str]:  # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.sget(cls, "staticMap"))
 
     @static_map.setter # type: ignore[no-redef]
     def static_map(cls, value: typing.Mapping[builtins.str, builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8dd7203701e4915203e4778820ee40fe6bdd6f0bb2855c200f375606277e06c8)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.sset(cls, "staticMap", value)
 
     @builtins.property
     @jsii.member(jsii_name="array")
     def array(self) -> typing.List[builtins.str]:
         return typing.cast(typing.List[builtins.str], jsii.get(self, "array"))
 
     @array.setter
     def array(self, value: typing.List[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c0c76fec28076841e36c26581c26385de1e984d96e91ea434a61c4bf36c9b4d9)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "array", value)
 
     @builtins.property
     @jsii.member(jsii_name="map")
     def map(self) -> typing.Mapping[builtins.str, builtins.str]:
         return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "map"))
 
     @map.setter
     def map(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5461a3c7bb81040765e4ca2e9effb12cc7f5fb018e5e1b8b21501a3f9cd6a8b3)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "map", value)
 
 
 class ClassWithContainerTypes(
     metaclass=jsii.JSIIMeta,
@@ -912,10 +1054,15 @@
         :param obj: -
         :param array_prop: 
         :param obj_prop: 
         :param record_prop: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__11d94174b1d488125abef65967a384ceb599f4948eca6cb9be3d55e1979fb64f)
+            check_type(argname="argument array", value=array, expected_type=type_hints["array"])
+            check_type(argname="argument record", value=record, expected_type=type_hints["record"])
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         props = ContainerProps(
             array_prop=array_prop, obj_prop=obj_prop, record_prop=record_prop
         )
 
         jsii.create(self.__class__, self, [array, record, obj, props])
@@ -965,17 +1112,23 @@
 ):
     def __init__(self, int: builtins.str) -> None:
         '''
         :param int: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c017a39e0da5d21f3a9acbfd00f6a5c84eb4cad306148504e7c835359d35537e)
+            check_type(argname="argument int", value=int, expected_type=type_hints["int"])
         jsii.create(self.__class__, self, [int])
 
     @jsii.member(jsii_name="import")
     def import_(self, assert_: builtins.str) -> builtins.str:
         '''
         :param assert_: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7a756cab89b47a2ae4c08f36162482b60fdf963b8ba638917a63c5e110b4d33e)
+            check_type(argname="argument assert_", value=assert_, expected_type=type_hints["assert_"])
         return typing.cast(builtins.str, jsii.invoke(self, "import", [assert_]))
 
     @builtins.property
     @jsii.member(jsii_name="int")
     def int(self) -> builtins.str:
@@ -994,10 +1147,13 @@
     def mutable_object(self) -> "IMutableObjectLiteral":
         return typing.cast("IMutableObjectLiteral", jsii.get(self, "mutableObject"))
 
     @mutable_object.setter
     def mutable_object(self, value: "IMutableObjectLiteral") -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3afbef7e05ef43a18b9260b86660c09b15be66fabeae128c9a9f99b729da7143)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableObject", value)
 
 
 class ClassWithNestedUnion(
     metaclass=jsii.JSIIMeta,
@@ -1008,10 +1164,13 @@
         union_property: typing.Sequence[typing.Union[typing.Mapping[builtins.str, typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]], typing.Sequence[typing.Union[typing.Union["StructA", typing.Dict[builtins.str, typing.Any]], typing.Union["StructB", typing.Dict[builtins.str, typing.Any]]]]]],
     ) -> None:
         '''
         :param union_property: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0b8f0f729686dad01c8555a3b1bc47509e495bd18f1560ef045b558884b2a1fb)
+            check_type(argname="argument union_property", value=union_property, expected_type=type_hints["union_property"])
         jsii.create(self.__class__, self, [union_property])
 
     @builtins.property
     @jsii.member(jsii_name="unionProperty")
     def union_property(
@@ -1022,10 +1181,13 @@
     @union_property.setter
     def union_property(
         self,
         value: typing.List[typing.Union[typing.Mapping[builtins.str, typing.Union["StructA", "StructB"]], typing.List[typing.Union["StructA", "StructB"]]]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a8a15eb37393d5188c71779e29278367f7b3600c6dd48bdbcd502cdf510c3c15)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionProperty", value)
 
 
 class ConfusingToJackson(
     metaclass=jsii.JSIIMeta,
@@ -1056,10 +1218,13 @@
     @union_property.setter
     def union_property(
         self,
         value: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ec229cc92e04670f4dca9546759b3b39ee813eb1aa18057135bb155d08971e6a)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "unionProperty", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.ConfusingToJacksonStruct",
@@ -1073,10 +1238,13 @@
         union_property: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.Sequence[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, "AbstractClass"]]]] = None,
     ) -> None:
         '''
         :param union_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__481b1113b85e6dc9d7ba31c3ef5654e3550abac1edef9204348ab0f9554f61c1)
+            check_type(argname="argument union_property", value=union_property, expected_type=type_hints["union_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if union_property is not None:
             self._values["union_property"] = union_property
 
     @builtins.property
@@ -1104,10 +1272,13 @@
 ):
     def __init__(self, consumer: "PartiallyInitializedThisConsumer") -> None:
         '''
         :param consumer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5676fcb3395f1db1a013537fa52220553e5e418c2a9d97aa2f9541c00ffe259e)
+            check_type(argname="argument consumer", value=consumer, expected_type=type_hints["consumer"])
         jsii.create(self.__class__, self, [consumer])
 
 
 class Constructors(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Constructors"):
     def __init__(self) -> None:
@@ -1155,10 +1326,13 @@
 ):
     def __init__(self, delegate: "IStructReturningDelegate") -> None:
         '''
         :param delegate: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5c5defc6d683ee91707f8b7770d8d2fb11d381b9c928d7e5d6e2c5c495395f38)
+            check_type(argname="argument delegate", value=delegate, expected_type=type_hints["delegate"])
         jsii.create(self.__class__, self, [delegate])
 
     @jsii.member(jsii_name="workItBaby")
     def work_it_baby(self) -> "StructB":
         return typing.cast("StructB", jsii.invoke(self, "workItBaby", []))
@@ -1187,10 +1361,13 @@
 
         Returns whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1df814299f3f9720be108d84bdfd61bc591699a79a3c8ac6d450bfb0a9610278)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByObjectLiteral", [ringer]))
 
     @jsii.member(jsii_name="staticImplementedByPrivateClass")
     @builtins.classmethod
     def static_implemented_by_private_class(
@@ -1201,10 +1378,13 @@
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2f08bd2d56e856071db5f777b63fe2577f9e96dbfcd91e4044d0eda2d26f9017)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByPrivateClass", [ringer]))
 
     @jsii.member(jsii_name="staticImplementedByPublicClass")
     @builtins.classmethod
     def static_implemented_by_public_class(cls, ringer: "IBellRinger") -> builtins.bool:
@@ -1212,10 +1392,13 @@
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4a2b7f0a05298ddaec112cb088cc71cfa2856aaa1d8414a5157d581b6d5a7293)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticImplementedByPublicClass", [ringer]))
 
     @jsii.member(jsii_name="staticWhenTypedAsClass")
     @builtins.classmethod
     def static_when_typed_as_class(cls, ringer: "IConcreteBellRinger") -> builtins.bool:
@@ -1223,50 +1406,65 @@
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f751da3f5766ea4973eb2d89086565259f0a3cd626425a7eec723afd7b64f392)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "staticWhenTypedAsClass", [ringer]))
 
     @jsii.member(jsii_name="implementedByObjectLiteral")
     def implemented_by_object_literal(self, ringer: "IBellRinger") -> builtins.bool:
         '''...if the interface is implemented using an object literal.
 
         Returns whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cca04fe4a4c41a0034087ab0c574d1d2f1d0427d87a806fc660446b6a7e5290a)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.invoke(self, "implementedByObjectLiteral", [ringer]))
 
     @jsii.member(jsii_name="implementedByPrivateClass")
     def implemented_by_private_class(self, ringer: "IBellRinger") -> builtins.bool:
         '''...if the interface is implemented using a private class.
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7bde53b867de290d21a419baa46b8e833a0d394835a1ce2be3b429179b2ddce5)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.invoke(self, "implementedByPrivateClass", [ringer]))
 
     @jsii.member(jsii_name="implementedByPublicClass")
     def implemented_by_public_class(self, ringer: "IBellRinger") -> builtins.bool:
         '''...if the interface is implemented using a public class.
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__988e53d92b16fb4b7224c654f985a074cbfa7dd5f567df005b41522641ad92ac)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.invoke(self, "implementedByPublicClass", [ringer]))
 
     @jsii.member(jsii_name="whenTypedAsClass")
     def when_typed_as_class(self, ringer: "IConcreteBellRinger") -> builtins.bool:
         '''If the parameter is a concrete class instead of an interface.
 
         Return whether the bell was rung.
 
         :param ringer: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1d786308546ae61deacb465c6f501fe7e0be028973494548b57e0480759ed460)
+            check_type(argname="argument ringer", value=ringer, expected_type=type_hints["ringer"])
         return typing.cast(builtins.bool, jsii.invoke(self, "whenTypedAsClass", [ringer]))
 
 
 class ConsumersOfThisCrazyTypeSystem(
     metaclass=jsii.JSIIMeta,
@@ -1281,20 +1479,26 @@
         obj: "IAnotherPublicInterface",
     ) -> builtins.str:
         '''
         :param obj: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__83037a3f429b90a38d2d9532a347144030578d83f68817b1a5677ebcd1b38e12)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         return typing.cast(builtins.str, jsii.invoke(self, "consumeAnotherPublicInterface", [obj]))
 
     @jsii.member(jsii_name="consumeNonInternalInterface")
     def consume_non_internal_interface(
         self,
         obj: "INonInternalInterface",
     ) -> typing.Any:
         '''
         :param obj: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__139bf4e63e56bef32e364c5972e055de5cba153d49cc821740fba1d51f73ef70)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         return typing.cast(typing.Any, jsii.invoke(self, "consumeNonInternalInterface", [obj]))
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.ContainerProps",
@@ -1316,10 +1520,15 @@
         '''
         :param array_prop: 
         :param obj_prop: 
         :param record_prop: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2be181b08e5a2c0e1e3f3a84732a423af31039117701d35431ee251d343ca9d5)
+            check_type(argname="argument array_prop", value=array_prop, expected_type=type_hints["array_prop"])
+            check_type(argname="argument obj_prop", value=obj_prop, expected_type=type_hints["obj_prop"])
+            check_type(argname="argument record_prop", value=record_prop, expected_type=type_hints["record_prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "array_prop": array_prop,
             "obj_prop": obj_prop,
             "record_prop": record_prop,
         }
@@ -1385,17 +1594,23 @@
         data: typing.Mapping[builtins.str, typing.Any],
     ) -> builtins.str:
         '''
         :param data: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dd941dcba8415b4b4dbb95bc3f55ac3404bdaf303822dfc7093fb615dc66b2cf)
+            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
         return typing.cast(builtins.str, jsii.invoke(self, "renderArbitrary", [data]))
 
     @jsii.member(jsii_name="renderMap")
     def render_map(self, map: typing.Mapping[builtins.str, typing.Any]) -> builtins.str:
         '''
         :param map: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9008dfc97234c0f2895caaa88d20a94de081c3cd97c38f9a012f13cdae75fbd6)
+            check_type(argname="argument map", value=map, expected_type=type_hints["map"])
         return typing.cast(builtins.str, jsii.invoke(self, "renderMap", [map]))
 
 
 class Default(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Default"):
     '''A class named "Default".
@@ -1424,10 +1639,15 @@
         '''
         :param arg1: -
         :param arg2: -
         :param arg3: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__019e6ec86ae7ee325dc404a7025eaf0edcb164e166535a831bccf6658adfbb10)
+            check_type(argname="argument arg1", value=arg1, expected_type=type_hints["arg1"])
+            check_type(argname="argument arg2", value=arg2, expected_type=type_hints["arg2"])
+            check_type(argname="argument arg3", value=arg3, expected_type=type_hints["arg3"])
         jsii.create(self.__class__, self, [arg1, arg2, arg3])
 
     @builtins.property
     @jsii.member(jsii_name="arg1")
     def arg1(self) -> jsii.Number:
@@ -1485,10 +1705,14 @@
 
         :deprecated: this constructor is "just" okay
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f64945b01dd806fcd872f369983e1fa6b3db8811cb0682ac6adf88aebb0aabda)
+            check_type(argname="argument readonly_string", value=readonly_string, expected_type=type_hints["readonly_string"])
+            check_type(argname="argument mutable_number", value=mutable_number, expected_type=type_hints["mutable_number"])
         jsii.create(self.__class__, self, [readonly_string, mutable_number])
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -1518,10 +1742,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3aef3220b38be7daf4208453b1766d9eafb6a74bd51dfb351d21235a205afa34)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
 
 @jsii.enum(jsii_type="jsii-calc.DeprecatedEnum")
 class DeprecatedEnum(enum.Enum):
@@ -1557,10 +1784,13 @@
 
         :deprecated: it just wraps a string
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cdee1d6893b4921a8d7cf0a9c957a543b69f7a98eb3cedd7ece84871fc81c767)
+            check_type(argname="argument readonly_property", value=readonly_property, expected_type=type_hints["readonly_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "readonly_property": readonly_property,
         }
 
     @builtins.property
@@ -1625,10 +1855,21 @@
         :param non_primitive: An example of a non primitive property.
         :param another_optional: This is optional.
         :param optional_any: 
         :param optional_array: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c544311353634d5a2f08144f0c184afbcb700d8304b9f49deae99f19e1e7b0af)
+            check_type(argname="argument anumber", value=anumber, expected_type=type_hints["anumber"])
+            check_type(argname="argument astring", value=astring, expected_type=type_hints["astring"])
+            check_type(argname="argument first_optional", value=first_optional, expected_type=type_hints["first_optional"])
+            check_type(argname="argument another_required", value=another_required, expected_type=type_hints["another_required"])
+            check_type(argname="argument bool", value=bool, expected_type=type_hints["bool"])
+            check_type(argname="argument non_primitive", value=non_primitive, expected_type=type_hints["non_primitive"])
+            check_type(argname="argument another_optional", value=another_optional, expected_type=type_hints["another_optional"])
+            check_type(argname="argument optional_any", value=optional_any, expected_type=type_hints["optional_any"])
+            check_type(argname="argument optional_array", value=optional_array, expected_type=type_hints["optional_array"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "anumber": anumber,
             "astring": astring,
             "another_required": another_required,
             "bool": bool,
@@ -1749,10 +1990,16 @@
         :param hoisted_top: 
         :param left: 
         :param right: 
         :param bottom: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__865cdfdd094ca753189170221ee7d6a0e59c2c0bcfdeff3dc37bb87dd39515ca)
+            check_type(argname="argument hoisted_top", value=hoisted_top, expected_type=type_hints["hoisted_top"])
+            check_type(argname="argument left", value=left, expected_type=type_hints["left"])
+            check_type(argname="argument right", value=right, expected_type=type_hints["right"])
+            check_type(argname="argument bottom", value=bottom, expected_type=type_hints["bottom"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if hoisted_top is not None:
             self._values["hoisted_top"] = hoisted_top
         if left is not None:
             self._values["left"] = left
@@ -1810,10 +2057,13 @@
 class DiamondInheritanceBaseLevelStruct:
     def __init__(self, *, base_level_property: builtins.str) -> None:
         '''
         :param base_level_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cfa52ba952c3d4a7e6df7fba3f619bf3ac14c52e829cce862a5fa495e45d0e70)
+            check_type(argname="argument base_level_property", value=base_level_property, expected_type=type_hints["base_level_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "base_level_property": base_level_property,
         }
 
     @builtins.property
@@ -1851,10 +2101,14 @@
     ) -> None:
         '''
         :param base_level_property: 
         :param first_mid_level_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__354311bd3d60d2b3b4ea927d6a96bdf66aa6d1109c29bfcd96266051c7c30a5e)
+            check_type(argname="argument base_level_property", value=base_level_property, expected_type=type_hints["base_level_property"])
+            check_type(argname="argument first_mid_level_property", value=first_mid_level_property, expected_type=type_hints["first_mid_level_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "base_level_property": base_level_property,
             "first_mid_level_property": first_mid_level_property,
         }
 
@@ -1899,10 +2153,14 @@
     ) -> None:
         '''
         :param base_level_property: 
         :param second_mid_level_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8074c5f38699399b9e6f8708c125bef5d7c89118c36ffcce8582d66cac2197da)
+            check_type(argname="argument base_level_property", value=base_level_property, expected_type=type_hints["base_level_property"])
+            check_type(argname="argument second_mid_level_property", value=second_mid_level_property, expected_type=type_hints["second_mid_level_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "base_level_property": base_level_property,
             "second_mid_level_property": second_mid_level_property,
         }
 
@@ -1958,10 +2216,16 @@
         :param base_level_property: 
         :param first_mid_level_property: 
         :param second_mid_level_property: 
         :param top_level_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9384691e88dd3ab7e55516762b2076445d94bd6d9348db1b93f79de9f4ae0ea1)
+            check_type(argname="argument base_level_property", value=base_level_property, expected_type=type_hints["base_level_property"])
+            check_type(argname="argument first_mid_level_property", value=first_mid_level_property, expected_type=type_hints["first_mid_level_property"])
+            check_type(argname="argument second_mid_level_property", value=second_mid_level_property, expected_type=type_hints["second_mid_level_property"])
+            check_type(argname="argument top_level_property", value=top_level_property, expected_type=type_hints["top_level_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "base_level_property": base_level_property,
             "first_mid_level_property": first_mid_level_property,
             "second_mid_level_property": second_mid_level_property,
             "top_level_property": top_level_property,
@@ -2041,10 +2305,13 @@
     @jsii.member(jsii_name="changePrivatePropertyValue")
     def change_private_property_value(self, new_value: builtins.str) -> None:
         '''
         :param new_value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5ae2124576c295a0c88fc75be0e57258f0f72e63c733e7493367b8558266510e)
+            check_type(argname="argument new_value", value=new_value, expected_type=type_hints["new_value"])
         return typing.cast(None, jsii.invoke(self, "changePrivatePropertyValue", [new_value]))
 
     @jsii.member(jsii_name="privateMethodValue")
     def private_method_value(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.invoke(self, "privateMethodValue", []))
@@ -2073,10 +2340,15 @@
         '''
         :param _required_any: -
         :param _optional_any: -
         :param _optional_string: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8ffaadb351f5c2c48a7368068d5c88e0c7836deefe0e13aa9fe53ac104052fd5)
+            check_type(argname="argument _required_any", value=_required_any, expected_type=type_hints["_required_any"])
+            check_type(argname="argument _optional_any", value=_optional_any, expected_type=type_hints["_optional_any"])
+            check_type(argname="argument _optional_string", value=_optional_string, expected_type=type_hints["_optional_string"])
         return typing.cast(None, jsii.invoke(self, "method", [_required_any, _optional_any, _optional_string]))
 
 
 class DocumentedClass(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.DocumentedClass"):
     '''Here's the first line of the TSDoc comment.
@@ -2140,10 +2412,14 @@
     ) -> builtins.str:
         '''
         :param optional: -
         :param things: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5af7b38b9b5c170ebd3e05c215e05f10e6843b03868850dad87a5a149b90e790)
+            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
+            check_type(argname="argument things", value=things, expected_type=typing.Tuple[type_hints["things"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(builtins.str, jsii.invoke(self, "optionalAndVariadic", [optional, *things]))
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.DummyObj",
@@ -2153,10 +2429,13 @@
 class DummyObj:
     def __init__(self, *, example: builtins.str) -> None:
         '''
         :param example: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ae5d543014149876cec8b005abbb94c112981cccaf318870c7fe4e8353c2c675)
+            check_type(argname="argument example", value=example, expected_type=type_hints["example"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "example": example,
         }
 
     @builtins.property
@@ -2185,28 +2464,37 @@
 
     def __init__(self, value_store: builtins.str) -> None:
         '''
         :param value_store: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c0d457497f870b36d210f01af9890c6624684d1e53da833858e801c18baf9fbb)
+            check_type(argname="argument value_store", value=value_store, expected_type=type_hints["value_store"])
         jsii.create(self.__class__, self, [value_store])
 
     @builtins.property
     @jsii.member(jsii_name="dynamicProperty")
     def dynamic_property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "dynamicProperty"))
 
     @dynamic_property.setter
     def dynamic_property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4f40c12fae2ef2673f3f324c0c452f65c187c1b3e6552b86768465a2d20de051)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "dynamicProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="valueStore")
     def value_store(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "valueStore"))
 
     @value_store.setter
     def value_store(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9106fb2a86e944ce0c61537852ab2d310a8a53448c6946af051de0325a67fa1a)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "valueStore", value)
 
 
 class DynamicPropertyBearerChild(
     DynamicPropertyBearer,
@@ -2215,20 +2503,26 @@
 ):
     def __init__(self, original_value: builtins.str) -> None:
         '''
         :param original_value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ad557fbd0532aa4220227645f5aae3e73ebae6b529cfe074430abf30d18cd5e9)
+            check_type(argname="argument original_value", value=original_value, expected_type=type_hints["original_value"])
         jsii.create(self.__class__, self, [original_value])
 
     @jsii.member(jsii_name="overrideValue")
     def override_value(self, new_value: builtins.str) -> builtins.str:
         '''Sets \`\`this.dynamicProperty\`\` to the new value, and returns the old value.
 
         :param new_value: the new value to be set.
 
         :return: the old value that was set.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a4026611d197b83d9a37b973ba97c69254e674921a7d89d0eb57ac41a19b636e)
+            check_type(argname="argument new_value", value=new_value, expected_type=type_hints["new_value"])
         return typing.cast(builtins.str, jsii.invoke(self, "overrideValue", [new_value]))
 
     @builtins.property
     @jsii.member(jsii_name="originalValue")
     def original_value(self) -> builtins.str:
@@ -2241,10 +2535,13 @@
     def __init__(self, clock: "IWallClock") -> None:
         '''Creates a new instance of Entropy.
 
         :param clock: your implementation of \`\`WallClock\`\`.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2a7f203302b2610301f1b36f34453db0f5572f2e02b0bc4c9933fd670e594222)
+            check_type(argname="argument clock", value=clock, expected_type=type_hints["clock"])
         jsii.create(self.__class__, self, [clock])
 
     @jsii.member(jsii_name="increase")
     def increase(self) -> builtins.str:
         '''Increases entropy by consuming time from the clock (yes, this is a long shot, please don't judge).
@@ -2272,10 +2569,13 @@
 
         :param word: the value to return.
 
         :return: \`\`word\`\`.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a90d161fb7d47a195a192cf987ac6968fc2c6fbe27005bdd7684478a3d956e66)
+            check_type(argname="argument word", value=word, expected_type=type_hints["word"])
         return typing.cast(builtins.str, jsii.invoke(self, "repeat", [word]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, Entropy).__jsii_proxy_class__ = lambda : _EntropyProxy
 
@@ -2312,10 +2612,14 @@
         are being erased when sending values from native code to JS.
 
         :param opts: -
         :param key: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b87cc89f87e9b1c180227625f3aba9395da5a8b258a88e605d466edb9004d709)
+            check_type(argname="argument opts", value=opts, expected_type=type_hints["opts"])
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "doesKeyExist", [opts, key]))
 
     @jsii.member(jsii_name="prop1IsNull")
     @builtins.classmethod
     def prop1_is_null(cls) -> typing.Mapping[builtins.str, typing.Any]:
@@ -2343,10 +2647,14 @@
     ) -> None:
         '''
         :param option1: 
         :param option2: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d34e4f5dab670ec3ea298ec2cda50be32700f7f52dcef6a618ca9cb3706062ee)
+            check_type(argname="argument option1", value=option1, expected_type=type_hints["option1"])
+            check_type(argname="argument option2", value=option2, expected_type=type_hints["option2"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if option1 is not None:
             self._values["option1"] = option1
         if option2 is not None:
             self._values["option2"] = option2
@@ -2390,10 +2698,14 @@
         :param readonly_string: -
         :param mutable_number: -
 
         :stability: experimental
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6a92c7223d00e7a0a2f0611cbb689671885b835bb26eedc8eb4a4d12e4ed5021)
+            check_type(argname="argument readonly_string", value=readonly_string, expected_type=type_hints["readonly_string"])
+            check_type(argname="argument mutable_number", value=mutable_number, expected_type=type_hints["mutable_number"])
         jsii.create(self.__class__, self, [readonly_string, mutable_number])
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -2417,10 +2729,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__52559292c6e04ad49e53e443b1a4c56149833b8f12876d779bb8860fcb231b41)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
 
 @jsii.enum(jsii_type="jsii-calc.ExperimentalEnum")
 class ExperimentalEnum(enum.Enum):
@@ -2448,10 +2763,13 @@
         '''
         :param readonly_property: 
 
         :stability: experimental
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b0c8f4c6eca5af7072a4a7c737950b39e75c61a56c505deb94edc5cd0995ed7d)
+            check_type(argname="argument readonly_property", value=readonly_property, expected_type=type_hints["readonly_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "readonly_property": readonly_property,
         }
 
     @builtins.property
@@ -2481,10 +2799,13 @@
 ):
     def __init__(self, success: builtins.bool) -> None:
         '''
         :param success: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dad018fa707514e8023df185b5e6e0a4b611bec563fe57abd9b81939b8833ebb)
+            check_type(argname="argument success", value=success, expected_type=type_hints["success"])
         jsii.create(self.__class__, self, [success])
 
     @builtins.property
     @jsii.member(jsii_name="success")
     def success(self) -> builtins.bool:
@@ -2500,10 +2821,14 @@
     def __init__(self, *, boom: builtins.bool, prop: builtins.str) -> None:
         '''
         :param boom: 
         :param prop: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__861a5ec03219f6c9fecd1b039faa2e53075227ff0d28f8eb66929909bc0c3096)
+            check_type(argname="argument boom", value=boom, expected_type=type_hints["boom"])
+            check_type(argname="argument prop", value=prop, expected_type=type_hints["prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "boom": boom,
             "prop": prop,
         }
 
@@ -2545,10 +2870,14 @@
         :param readonly_string: -
         :param mutable_number: -
 
         :external: true
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__82149b1f61aca58419f6ba4c74c8bb1c5c241433707e64ea4626937b294d8fe5)
+            check_type(argname="argument readonly_string", value=readonly_string, expected_type=type_hints["readonly_string"])
+            check_type(argname="argument mutable_number", value=mutable_number, expected_type=type_hints["mutable_number"])
         jsii.create(self.__class__, self, [readonly_string, mutable_number])
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -2572,10 +2901,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8380ec30b1f8773df7b5b27be8811be79b04f1d17c8eca83f83927eb56cdfd34)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
 
 @jsii.enum(jsii_type="jsii-calc.ExternalEnum")
 class ExternalEnum(enum.Enum):
@@ -2603,10 +2935,13 @@
         '''
         :param readonly_property: 
 
         :external: true
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8e8843a5fc914ec2c1e3baccdad526ea4d48eee37296f6812f3c0673ef86794f)
+            check_type(argname="argument readonly_property", value=readonly_property, expected_type=type_hints["readonly_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "readonly_property": readonly_property,
         }
 
     @builtins.property
@@ -2749,10 +3084,13 @@
     def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
         '''These are some arguments you can pass to a method.
 
         :param name: The name of the greetee. Default: world
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3dce87825e36304d54521ce5524aa7e230fa5d505b0abbc79101fd9014f2cbd9)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if name is not None:
             self._values["name"] = name
 
     @builtins.property
@@ -2789,10 +3127,13 @@
         friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
     ) -> builtins.str:
         '''
         :param friendly: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d17f0544be961cba6cabfbb40f28c196963de107fcaef9c56d8227bdcb359431)
+            check_type(argname="argument friendly", value=friendly, expected_type=type_hints["friendly"])
         return typing.cast(builtins.str, jsii.invoke(self, "betterGreeting", [friendly]))
 
 
 @jsii.interface(jsii_type="jsii-calc.IAnonymousImplementationProvider")
 class IAnonymousImplementationProvider(typing_extensions.Protocol):
@@ -2872,10 +3213,13 @@
     def a(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "a"))
 
     @a.setter
     def a(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3eabfcad9a21b26024f4c1480ca127a3d6c6888067f0ae991d5922a49bfe81d4)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "a", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IAnotherPublicInterface).__jsii_proxy_class__ = lambda : _IAnotherPublicInterfaceProxy
 
@@ -2918,10 +3262,13 @@
     @jsii.member(jsii_name="yourTurn")
     def your_turn(self, bell: IBell) -> None:
         '''
         :param bell: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d127476ce3b6e59ff9f375f547c1b6e1826d7a3969612c0605ebd0017d2b985d)
+            check_type(argname="argument bell", value=bell, expected_type=type_hints["bell"])
         return typing.cast(None, jsii.invoke(self, "yourTurn", [bell]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IBellRinger).__jsii_proxy_class__ = lambda : _IBellRingerProxy
 
@@ -2946,10 +3293,13 @@
     @jsii.member(jsii_name="yourTurn")
     def your_turn(self, bell: "Bell") -> None:
         '''
         :param bell: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2c34aaac5945bdc61c4f56492dee5608e1852940835d94d3e991fed377db66f2)
+            check_type(argname="argument bell", value=bell, expected_type=type_hints["bell"])
         return typing.cast(None, jsii.invoke(self, "yourTurn", [bell]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IConcreteBellRinger).__jsii_proxy_class__ = lambda : _IConcreteBellRingerProxy
 
@@ -3005,10 +3355,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e4d76200a6c5bdbdd51f208229da8bfd8f6f4c967af28e1e733579780e9d4a0e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -3063,10 +3416,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6e68d313f3254be7145220b211c66f45749aa8efc15aaf93d96330eb3cb7c6c7)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -3108,10 +3464,13 @@
     def private(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "private"))
 
     @private.setter
     def private(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8199a83e86f8a4cf29ddc53d2b2151c37c7fa10d29562b454127376d1867d6da)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "private", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IExtendsPrivateInterface).__jsii_proxy_class__ = lambda : _IExtendsPrivateInterfaceProxy
 
@@ -3157,10 +3516,13 @@
         '''
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a904d745cb9f037de717ed7a2b1d3a207493564662fdbe1d7c63e60a24f9bace)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         '''
@@ -3342,10 +3704,14 @@
     ) -> None:
         '''
         :param arg1: -
         :param arg2: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5568c72c746dd5221cb6fb7b741ed7a3346c346d7a30863c5abe3d99ada53098)
+            check_type(argname="argument arg1", value=arg1, expected_type=type_hints["arg1"])
+            check_type(argname="argument arg2", value=arg2, expected_type=type_hints["arg2"])
         return typing.cast(None, jsii.invoke(self, "hello", [arg1, arg2]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IInterfaceWithOptionalMethodArguments).__jsii_proxy_class__ = lambda : _IInterfaceWithOptionalMethodArgumentsProxy
 
@@ -3380,10 +3746,13 @@
     def read_write_string(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "readWriteString"))
 
     @read_write_string.setter
     def read_write_string(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__858de6e8785f18ad264a158ca83a0fc1e0a6299efa9f77a0b31eaaffaa5b086c)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "readWriteString", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IInterfaceWithProperties).__jsii_proxy_class__ = lambda : _IInterfaceWithPropertiesProxy
 
@@ -3413,10 +3782,13 @@
     def foo(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.get(self, "foo"))
 
     @foo.setter
     def foo(self, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c571c6749392bc04e123a99b926edaf10b88be6b6d6b6a3937cae9893af5119e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "foo", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IInterfaceWithPropertiesExtension).__jsii_proxy_class__ = lambda : _IInterfaceWithPropertiesExtensionProxy
 
@@ -3936,10 +4308,13 @@
     def value(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "value"))
 
     @value.setter
     def value(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e0395944061fad9d5156b633dc20682ff9759ae0acb88df574b159f4919ab3a5)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "value", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IMutableObjectLiteral).__jsii_proxy_class__ = lambda : _IMutableObjectLiteralProxy
 
@@ -3975,19 +4350,25 @@
     def b(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "b"))
 
     @b.setter
     def b(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9d1e4198ba3f4e6b6a6f4ce0a4a185223ec216368c0c3304c69b029aba13ca49)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "b", value)
 
     @builtins.property
     @jsii.member(jsii_name="c")
     def c(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "c"))
 
     @c.setter
     def c(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6774e195ab25dab5790e1d187eb30be56997804d5186753a9928f2575f81977b)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "c", value)
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, INonInternalInterface).__jsii_proxy_class__ = lambda : _INonInternalInterfaceProxy
 
@@ -4020,10 +4401,13 @@
     def property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "property"))
 
     @property.setter
     def property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__831f664cd567fd4e707fd175e9c9e13519f3ca587b792d7d5bc79f427589a802)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "property", value)
 
     @jsii.member(jsii_name="wasSet")
     def was_set(self) -> builtins.bool:
         return typing.cast(builtins.bool, jsii.invoke(self, "wasSet", []))
@@ -4216,10 +4600,13 @@
     def mutable_property(self) -> typing.Optional[jsii.Number]:
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__254a58386276f7b7d5a41dddd674375b8942c2cad4deb6c2d24b55d240d14350)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         return typing.cast(None, jsii.invoke(self, "method", []))
@@ -4286,10 +4673,13 @@
     def prop(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "prop"))
 
     @prop.setter
     def prop(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__10bb8b026d6c8368d479cf0da8b27c049c5f9088f173a63624e515dd36607439)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "prop", value)
 
 
 class Implementation(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Implementation"):
     def __init__(self) -> None:
@@ -4335,10 +4725,13 @@
     def private(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "private"))
 
     @private.setter
     def private(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2df4d055b033cdfdf7ad915b451ddc787ad68fb64b7e02386a9d8e591c1657af)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "private", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.ImplictBaseOfBase",
@@ -4356,10 +4749,15 @@
         '''
         :param foo: -
         :param bar: -
         :param goo: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b70592e4d080897239bf5f8b0de5b6b464cd9e888e39fca1082c04b5cbeca890)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
+            check_type(argname="argument goo", value=goo, expected_type=type_hints["goo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
             "bar": bar,
             "goo": goo,
         }
@@ -4434,10 +4832,13 @@
         count: jsii.Number,
     ) -> typing.List[_scope_jsii_calc_lib_c61f082f.IDoublable]:
         '''
         :param count: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1d6e348a61ed27bfc8b7928365798b43e0130ca2b720c1105baca04fa093d194)
+            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
         return typing.cast(typing.List[_scope_jsii_calc_lib_c61f082f.IDoublable], jsii.sinvoke(cls, "makeInterfaces", [count]))
 
 
 class Isomorphism(metaclass=jsii.JSIIAbstractClass, jsii_type="jsii-calc.Isomorphism"):
     '''Checks the "same instance" isomorphism is preserved within the constructor.
@@ -4542,19 +4943,25 @@
     def prop_a(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "propA"))
 
     @prop_a.setter
     def prop_a(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__30ce308abdc1d2462c00bf7a4acc194ec05d61ddee24b2e79c674aa7034e5ffa)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "propA", value)
 
     @builtins.property
     @jsii.member(jsii_name="propB")
     def prop_b(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.get(self, "propB"))
 
     @prop_b.setter
     def prop_b(self, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__eef7c487e6f0c4d81dd633cf70121104ff8f3458fa52a418df64bcab9fe4bd3e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "propB", value)
 
 
 class JavaReservedWords(
     metaclass=jsii.JSIIMeta,
@@ -4776,10 +5183,13 @@
     def while_(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "while"))
 
     @while_.setter
     def while_(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a7654af9a241e67ad498c3eb33b98e6cdb1558487bb9b02dcce41f75334b76ad)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "while", value)
 
 
 @jsii.implements(IJsii487External2, IJsii487External)
 class Jsii487Derived(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Jsii487Derived"):
@@ -4881,10 +5291,13 @@
     @builtins.classmethod
     def stringify(cls, value: typing.Any = None) -> typing.Optional[builtins.str]:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__43f45c49ecee3d08351b82aa5cdc3548d9dafa534cd2d99da8b5c5c9188e9a54)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(typing.Optional[builtins.str], jsii.sinvoke(cls, "stringify", [value]))
 
 
 class LevelOne(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.LevelOne"):
     '''Validates that nested classes get correct code generation for the occasional forward reference.'''
@@ -4914,10 +5327,13 @@
     class PropBooleanValue:
         def __init__(self, *, value: builtins.bool) -> None:
             '''
             :param value: 
             '''
+            if __debug__:
+                type_hints = typing.get_type_hints(_typecheckingstub__ef705a05998260349d35c748c557e65cf539d53e136eb9191250080bdce852c3)
+                check_type(argname="argument value", value=value, expected_type=type_hints["value"])
             self._values: typing.Dict[builtins.str, typing.Any] = {
                 "value": value,
             }
 
         @builtins.property
@@ -4951,10 +5367,13 @@
             '''
             :param prop: 
             '''
             if isinstance(prop, dict):
                 prop = LevelOne.PropBooleanValue(**prop)
+            if __debug__:
+                type_hints = typing.get_type_hints(_typecheckingstub__2a9e65060bf85c3d49b79ada1f9394ae146c380a4212c190065e031098d570b8)
+                check_type(argname="argument prop", value=prop, expected_type=type_hints["prop"])
             self._values: typing.Dict[builtins.str, typing.Any] = {
                 "prop": prop,
             }
 
         @builtins.property
@@ -4989,10 +5408,13 @@
         '''
         :param prop: 
         '''
         if isinstance(prop, dict):
             prop = LevelOne.PropProperty(**prop)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__479be5d5625f656c28cf12ffdc2cef9d6d74aae555551630f440fcb05351d261)
+            check_type(argname="argument prop", value=prop, expected_type=type_hints["prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "prop": prop,
         }
 
     @builtins.property
@@ -5040,10 +5462,17 @@
         :param cpu: The number of cpu units used by the task. Valid values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 0.5GB, 1GB, 2GB 512 (.5 vCPU) - Available memory values: 1GB, 2GB, 3GB, 4GB 1024 (1 vCPU) - Available memory values: 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB 2048 (2 vCPU) - Available memory values: Between 4GB and 16GB in 1GB increments 4096 (4 vCPU) - Available memory values: Between 8GB and 30GB in 1GB increments This default is set in the underlying FargateTaskDefinition construct. Default: 256
         :param memory_mib: The amount (in MiB) of memory used by the task. This field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 0.5GB, 1GB, 2GB - Available cpu values: 256 (.25 vCPU) 1GB, 2GB, 3GB, 4GB - Available cpu values: 512 (.5 vCPU) 2GB, 3GB, 4GB, 5GB, 6GB, 7GB, 8GB - Available cpu values: 1024 (1 vCPU) Between 4GB and 16GB in 1GB increments - Available cpu values: 2048 (2 vCPU) Between 8GB and 30GB in 1GB increments - Available cpu values: 4096 (4 vCPU) This default is set in the underlying FargateTaskDefinition construct. Default: 512
         :param public_load_balancer: Determines whether the Application Load Balancer will be internet-facing. Default: true
         :param public_tasks: Determines whether your Fargate Service will be assigned a public IP address. Default: false
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b3d89a25beb0ebd10c196d941aa924197ae9a2def08f1f414c190a2a6d943d9c)
+            check_type(argname="argument container_port", value=container_port, expected_type=type_hints["container_port"])
+            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
+            check_type(argname="argument memory_mib", value=memory_mib, expected_type=type_hints["memory_mib"])
+            check_type(argname="argument public_load_balancer", value=public_load_balancer, expected_type=type_hints["public_load_balancer"])
+            check_type(argname="argument public_tasks", value=public_tasks, expected_type=type_hints["public_tasks"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if container_port is not None:
             self._values["container_port"] = container_port
         if cpu is not None:
             self._values["cpu"] = cpu
@@ -5170,10 +5599,14 @@
         '''Creates a BinaryOperation.
 
         :param lhs: Left-hand side operand.
         :param rhs: Right-hand side operand.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7e73465ea858e34d4df8697d34f29a53ca3c3a41c47946382e5d49f498e3747d)
+            check_type(argname="argument lhs", value=lhs, expected_type=type_hints["lhs"])
+            check_type(argname="argument rhs", value=rhs, expected_type=type_hints["rhs"])
         jsii.create(self.__class__, self, [lhs, rhs])
 
     @jsii.member(jsii_name="farewell")
     def farewell(self) -> builtins.str:
         '''Say farewell.'''
@@ -5221,10 +5654,13 @@
 class NestedStruct:
     def __init__(self, *, number_prop: jsii.Number) -> None:
         '''
         :param number_prop: When provided, must be > 0.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__04dae031a5097183ccda93eb91ec51a8a6fa1133134a6a398f1f05c581bc0091)
+            check_type(argname="argument number_prop", value=number_prop, expected_type=type_hints["number_prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "number_prop": number_prop,
         }
 
     @builtins.property
@@ -5295,17 +5731,24 @@
     def __init__(self, _param1: builtins.str, optional: typing.Any = None) -> None:
         '''
         :param _param1: -
         :param optional: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__218107d38285901ff40e08163f0de0bac5d835bd64c21c0a735e8d72399ebe35)
+            check_type(argname="argument _param1", value=_param1, expected_type=type_hints["_param1"])
+            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
         jsii.create(self.__class__, self, [_param1, optional])
 
     @jsii.member(jsii_name="giveMeUndefined")
     def give_me_undefined(self, value: typing.Any = None) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a109cd8429db09172895a3eb04ca7e9d5c92129c7ca7a50f85fa89b6f6ab366b)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "giveMeUndefined", [value]))
 
     @jsii.member(jsii_name="giveMeUndefinedInsideAnObject")
     def give_me_undefined_inside_an_object(
         self,
@@ -5333,10 +5776,13 @@
     def change_me_to_undefined(self) -> typing.Optional[builtins.str]:
         return typing.cast(typing.Optional[builtins.str], jsii.get(self, "changeMeToUndefined"))
 
     @change_me_to_undefined.setter
     def change_me_to_undefined(self, value: typing.Optional[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7102c29a709c4297fb88615c74a3e42a584364ac4ccba5c1db42a65e05184d1b)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "changeMeToUndefined", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.NullShouldBeTreatedAsUndefinedData",
@@ -5355,10 +5801,14 @@
     ) -> None:
         '''
         :param array_with_three_elements_and_undefined_as_second_argument: 
         :param this_should_be_undefined: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ae8d47cabe4d36f88c891d250d7e792432b0d153223789ec3687e714ba92a5f3)
+            check_type(argname="argument array_with_three_elements_and_undefined_as_second_argument", value=array_with_three_elements_and_undefined_as_second_argument, expected_type=type_hints["array_with_three_elements_and_undefined_as_second_argument"])
+            check_type(argname="argument this_should_be_undefined", value=this_should_be_undefined, expected_type=type_hints["this_should_be_undefined"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "array_with_three_elements_and_undefined_as_second_argument": array_with_three_elements_and_undefined_as_second_argument,
         }
         if this_should_be_undefined is not None:
             self._values["this_should_be_undefined"] = this_should_be_undefined
@@ -5393,17 +5843,23 @@
 
     def __init__(self, generator: IRandomNumberGenerator) -> None:
         '''
         :param generator: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3c1812783ba0b3b2146a3dd9609a6e12af404502ff5fbb9b9a9be49bf576122b)
+            check_type(argname="argument generator", value=generator, expected_type=type_hints["generator"])
         jsii.create(self.__class__, self, [generator])
 
     @jsii.member(jsii_name="isSameGenerator")
     def is_same_generator(self, gen: IRandomNumberGenerator) -> builtins.bool:
         '''
         :param gen: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__151b90e9765ce9a05ae13e568f4ba7c9e36e34c1cd991c5c1ee0249869fd4cce)
+            check_type(argname="argument gen", value=gen, expected_type=type_hints["gen"])
         return typing.cast(builtins.bool, jsii.invoke(self, "isSameGenerator", [gen]))
 
     @jsii.member(jsii_name="nextTimes100")
     def next_times100(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.invoke(self, "nextTimes100", []))
@@ -5413,10 +5869,13 @@
     def generator(self) -> IRandomNumberGenerator:
         return typing.cast(IRandomNumberGenerator, jsii.get(self, "generator"))
 
     @generator.setter
     def generator(self, value: IRandomNumberGenerator) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0f5a1cc548d3db6e156cec5671bc04b980132e529c77f3bb5aaa58427db35e7c)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "generator", value)
 
 
 class ObjectRefsInCollections(
     metaclass=jsii.JSIIMeta,
@@ -5434,10 +5893,13 @@
     ) -> jsii.Number:
         '''Returns the sum of all values.
 
         :param values: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f5cb9f9511b0248cd4c0c4bec4eed9e75e7690012237fdb1b39b3f7b3bb0392e)
+            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
         return typing.cast(jsii.Number, jsii.invoke(self, "sumFromArray", [values]))
 
     @jsii.member(jsii_name="sumFromMap")
     def sum_from_map(
         self,
@@ -5445,10 +5907,13 @@
     ) -> jsii.Number:
         '''Returns the sum of all values in a map.
 
         :param values: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca5199647728e53a1ec89d4fd7dad9aeb7239f8c1213c51b4e2eda734daa4cf4)
+            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
         return typing.cast(jsii.Number, jsii.invoke(self, "sumFromMap", [values]))
 
 
 class ObjectWithPropertyProvider(
     metaclass=jsii.JSIIMeta,
@@ -5489,10 +5954,13 @@
 ):
     def __init__(self, delegate: IInterfaceWithOptionalMethodArguments) -> None:
         '''
         :param delegate: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__da93d15e57e6e2a1857cd7df156fb2a55ec91715c97323f20268def40f72137c)
+            check_type(argname="argument delegate", value=delegate, expected_type=type_hints["delegate"])
         jsii.create(self.__class__, self, [delegate])
 
     @jsii.member(jsii_name="invokeWithOptional")
     def invoke_with_optional(self) -> None:
         return typing.cast(None, jsii.invoke(self, "invokeWithOptional", []))
@@ -5515,10 +5983,15 @@
         '''
         :param arg1: -
         :param arg2: -
         :param arg3: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5f6c5e5b55379123a8bd2bc457d9a5e9a0d34dd512b2bd2f59c6a5bec2a95f14)
+            check_type(argname="argument arg1", value=arg1, expected_type=type_hints["arg1"])
+            check_type(argname="argument arg2", value=arg2, expected_type=type_hints["arg2"])
+            check_type(argname="argument arg3", value=arg3, expected_type=type_hints["arg3"])
         jsii.create(self.__class__, self, [arg1, arg2, arg3])
 
     @builtins.property
     @jsii.member(jsii_name="arg1")
     def arg1(self) -> jsii.Number:
@@ -5543,10 +6016,13 @@
 class OptionalStruct:
     def __init__(self, *, field: typing.Optional[builtins.str] = None) -> None:
         '''
         :param field: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__26ecd0d4ea200acf388a8b91f17bfd3c09b6c7f8e0a84228b89c27ace672d0b1)
+            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
         if field is not None:
             self._values["field"] = field
 
     @builtins.property
@@ -5622,10 +6098,13 @@
     def _override_read_write(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "overrideReadWrite"))
 
     @_override_read_write.setter
     def _override_read_write(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__72ca8c3c148afe2b76dc14b63b8e2baf0bbf28802add3f88490cb5d3792825fb)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "overrideReadWrite", value)
 
 
 class OverrideReturnsObject(
     metaclass=jsii.JSIIMeta,
@@ -5637,10 +6116,13 @@
     @jsii.member(jsii_name="test")
     def test(self, obj: IReturnsNumber) -> jsii.Number:
         '''
         :param obj: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca8d417ddf787890441d6903718eebaf7fde3508b3466202724fdac3a17ba79b)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         return typing.cast(jsii.Number, jsii.invoke(self, "test", [obj]))
 
 
 class ParamShadowsBuiltins(
     metaclass=jsii.JSIIMeta,
@@ -5662,10 +6144,14 @@
         :param str: should be set to something that is NOT a valid expression in Python (e.g: "\${NOPE}"").
         :param boolean_property: 
         :param string_property: 
         :param struct_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__32a51b5d61d5ca58d33e8f6b9d9e1c4f16b39bf431a669250d4c290de0bbf46f)
+            check_type(argname="argument builtins", value=builtins, expected_type=type_hints["builtins"])
+            check_type(argname="argument str", value=str, expected_type=type_hints["str"])
         props = ParamShadowsBuiltinsProps(
             boolean_property=boolean_property,
             string_property=string_property,
             struct_property=struct_property,
         )
@@ -5695,10 +6181,15 @@
         :param string_property: 
         :param struct_property: 
         '''
         if isinstance(struct_property, dict):
             struct_property = StructA(**struct_property)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c93d69c5c8307eec2d1c6e8d5f9892234fbdd24bb5cce3f5ea1e210276bc58c1)
+            check_type(argname="argument boolean_property", value=boolean_property, expected_type=type_hints["boolean_property"])
+            check_type(argname="argument string_property", value=string_property, expected_type=type_hints["string_property"])
+            check_type(argname="argument struct_property", value=struct_property, expected_type=type_hints["struct_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "boolean_property": boolean_property,
             "string_property": string_property,
             "struct_property": struct_property,
         }
@@ -5751,10 +6242,13 @@
         scope: _scope_jsii_calc_lib_c61f082f.Number,
     ) -> _scope_jsii_calc_lib_c61f082f.Number:
         '''
         :param scope: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ae63c91319764cabd02536ac5b03026eb3f4071497b2a04adf93ca02985507ae)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
         return typing.cast(_scope_jsii_calc_lib_c61f082f.Number, jsii.invoke(self, "useScope", [scope]))
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.ParentStruct982",
@@ -5765,10 +6259,13 @@
     def __init__(self, *, foo: builtins.str) -> None:
         '''https://github.com/aws/jsii/issues/982.
 
         :param foo: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f6db465208dd616dc4f171643676a159b21fe5963ec9a3d1fd752e5cb291868d)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
 
     @builtins.property
@@ -5823,10 +6320,15 @@
         '''
         :param obj: -
         :param dt: -
         :param ev: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__85c3ad65f24d8d5af99d7777a0379b793f45ac0e0e39714f279b8f2d58dbcfdb)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
+            check_type(argname="argument dt", value=dt, expected_type=type_hints["dt"])
+            check_type(argname="argument ev", value=ev, expected_type=type_hints["ev"])
         return typing.cast(builtins.str, jsii.invoke(self, "consumePartiallyInitializedThis", [obj, dt, ev]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, PartiallyInitializedThisConsumer).__jsii_proxy_class__ = lambda : _PartiallyInitializedThisConsumerProxy
 
@@ -5841,10 +6343,13 @@
         friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
     ) -> builtins.str:
         '''
         :param friendly: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__edbbf85a7c4217635da7418d28aa61c4e11f7a0c1e9c960528ed4e7bee1ad541)
+            check_type(argname="argument friendly", value=friendly, expected_type=type_hints["friendly"])
         return typing.cast(builtins.str, jsii.invoke(self, "sayHello", [friendly]))
 
 
 class Power(
     _CompositeOperation_1c4d123b,
@@ -5861,10 +6366,14 @@
         '''Creates a Power operation.
 
         :param base: The base of the power.
         :param pow: The number of times to multiply.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__df4f41b4c003b9ba61f07f4d41a4059f167ea41c03ea29933966d2caeb831d8c)
+            check_type(argname="argument base", value=base, expected_type=type_hints["base"])
+            check_type(argname="argument pow", value=pow, expected_type=type_hints["pow"])
         jsii.create(self.__class__, self, [base, pow])
 
     @builtins.property
     @jsii.member(jsii_name="base")
     def base(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
@@ -6087,10 +6596,13 @@
         value: _scope_jsii_calc_lib_c61f082f.EnumFromScopedModule,
     ) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__235768085718ab33214221cff3145bb2a82c28916350f273995760a428a1aba3)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "saveFoo", [value]))
 
     @builtins.property
     @jsii.member(jsii_name="foo")
     def foo(
@@ -6101,10 +6613,13 @@
     @foo.setter
     def foo(
         self,
         value: typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__100c679fa10c1938fc087475a1e5fcdf7c2cbff383b1c02b1d09471cb4f23123)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "foo", value)
 
 
 class ReturnsPrivateImplementationOfInterface(
     metaclass=jsii.JSIIMeta,
@@ -6146,10 +6661,14 @@
         :param string_prop: May not be empty.
         :param nested_struct: 
         '''
         if isinstance(nested_struct, dict):
             nested_struct = NestedStruct(**nested_struct)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cf66d7b4f4a567aefacbafc24f61d33a942afde3d167676ed65ea82da95cd36e)
+            check_type(argname="argument string_prop", value=string_prop, expected_type=type_hints["string_prop"])
+            check_type(argname="argument nested_struct", value=nested_struct, expected_type=type_hints["nested_struct"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "string_prop": string_prop,
         }
         if nested_struct is not None:
             self._values["nested_struct"] = nested_struct
@@ -6216,17 +6735,25 @@
         '''
         :param arg1: -
         :param arg2: -
         :param arg3: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6db501e892de783af62ff728e59cc3155afc51ddc2dff77cce61ffe698e2e1f3)
+            check_type(argname="argument arg1", value=arg1, expected_type=type_hints["arg1"])
+            check_type(argname="argument arg2", value=arg2, expected_type=type_hints["arg2"])
+            check_type(argname="argument arg3", value=arg3, expected_type=type_hints["arg3"])
         return typing.cast(None, jsii.invoke(self, "methodWithDefaultedArguments", [arg1, arg2, arg3]))
 
     @jsii.member(jsii_name="methodWithOptionalAnyArgument")
     def method_with_optional_any_argument(self, arg: typing.Any = None) -> None:
         '''
         :param arg: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5978f09aaa3317742377437d5735571f672119325c2b5d69f26153bae6764c85)
+            check_type(argname="argument arg", value=arg, expected_type=type_hints["arg"])
         return typing.cast(None, jsii.invoke(self, "methodWithOptionalAnyArgument", [arg]))
 
     @jsii.member(jsii_name="methodWithOptionalArguments")
     def method_with_optional_arguments(
         self,
@@ -6238,10 +6765,15 @@
 
         :param arg1: -
         :param arg2: -
         :param arg3: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c894904fd4904d7e110da91df846a8ec0970051a274bba5ad95c2b7dc1125cc2)
+            check_type(argname="argument arg1", value=arg1, expected_type=type_hints["arg1"])
+            check_type(argname="argument arg2", value=arg2, expected_type=type_hints["arg2"])
+            check_type(argname="argument arg3", value=arg3, expected_type=type_hints["arg3"])
         return typing.cast(None, jsii.invoke(self, "methodWithOptionalArguments", [arg1, arg2, arg3]))
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.SecondLevelStruct",
@@ -6260,10 +6792,14 @@
     ) -> None:
         '''
         :param deeper_required_prop: It's long and required.
         :param deeper_optional_prop: It's long, but you'll almost never pass it.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e7383b9a36a10b88815e6c310c7b13c611260f5ccb143b75dac114873643350d)
+            check_type(argname="argument deeper_required_prop", value=deeper_required_prop, expected_type=type_hints["deeper_required_prop"])
+            check_type(argname="argument deeper_optional_prop", value=deeper_optional_prop, expected_type=type_hints["deeper_optional_prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "deeper_required_prop": deeper_required_prop,
         }
         if deeper_optional_prop is not None:
             self._values["deeper_optional_prop"] = deeper_optional_prop
@@ -6325,10 +6861,13 @@
     @jsii.member(jsii_name="isSingletonInt")
     def is_singleton_int(self, value: jsii.Number) -> builtins.bool:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2ccde09a2986c421795069d44c46d9e2d7470609094b8b7177c6b154360f7435)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(builtins.bool, jsii.invoke(self, "isSingletonInt", [value]))
 
 
 @jsii.enum(jsii_type="jsii-calc.SingletonIntEnum")
 class SingletonIntEnum(enum.Enum):
@@ -6347,10 +6886,13 @@
     @jsii.member(jsii_name="isSingletonString")
     def is_singleton_string(self, value: builtins.str) -> builtins.bool:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__76cbdc0bba36d674ab013a40d091c1f3ccb139f10e78844ebc868bfa5d707ef8)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(builtins.bool, jsii.invoke(self, "isSingletonString", [value]))
 
 
 @jsii.enum(jsii_type="jsii-calc.SingletonStringEnum")
 class SingletonStringEnum(enum.Enum):
@@ -6374,10 +6916,14 @@
     ) -> None:
         '''
         :param property: 
         :param yet_anoter_one: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1b795ca2a3052da38144d10d87f230e74bcfa497af1262580f53908be48f6710)
+            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
+            check_type(argname="argument yet_anoter_one", value=yet_anoter_one, expected_type=type_hints["yet_anoter_one"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "property": property,
             "yet_anoter_one": yet_anoter_one,
         }
 
@@ -6428,10 +6974,14 @@
     ) -> None:
         '''
         :param readonly_string: -
         :param mutable_number: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8c577a76d55e32f4b62a2a005d0c321bf9d0784b2f6cea5f10e297f3f79fc4bb)
+            check_type(argname="argument readonly_string", value=readonly_string, expected_type=type_hints["readonly_string"])
+            check_type(argname="argument mutable_number", value=mutable_number, expected_type=type_hints["mutable_number"])
         jsii.create(self.__class__, self, [readonly_string, mutable_number])
 
     @jsii.member(jsii_name="method")
     def method(self) -> None:
         return typing.cast(None, jsii.invoke(self, "method", []))
@@ -6446,10 +6996,13 @@
     def mutable_property(self) -> typing.Optional[jsii.Number]:
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "mutableProperty"))
 
     @mutable_property.setter
     def mutable_property(self, value: typing.Optional[jsii.Number]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__737be2f0376e64bd8c0980aee9fc6afd796bb4d0cb3415eab28d054f15881752)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "mutableProperty", value)
 
 
 @jsii.enum(jsii_type="jsii-calc.StableEnum")
 class StableEnum(enum.Enum):
@@ -6465,10 +7018,13 @@
 class StableStruct:
     def __init__(self, *, readonly_property: builtins.str) -> None:
         '''
         :param readonly_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4bbf1eebbce12768b1d2ef90968ffdbe749e42ce8bcdaf4c8750314d2160c5ea)
+            check_type(argname="argument readonly_property", value=readonly_property, expected_type=type_hints["readonly_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "readonly_property": readonly_property,
         }
 
     @builtins.property
@@ -6505,10 +7061,13 @@
     def static_variable(cls) -> builtins.bool:  # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(builtins.bool, jsii.sget(cls, "staticVariable"))
 
     @static_variable.setter # type: ignore[no-redef]
     def static_variable(cls, value: builtins.bool) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cf00e16ec45ebcadc1f7003eb344ecf452096a12a1a76ff0e15fce1066d716d2)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.sset(cls, "staticVariable", value)
 
 
 class StaticHelloParent(
     metaclass=jsii.JSIIMeta,
@@ -6538,19 +7097,25 @@
 class Statics(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.Statics"):
     def __init__(self, value: builtins.str) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__69df39c5fc3367bba974a46518d9122ce067721f56037ef6e1faedf479222822)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.create(self.__class__, self, [value])
 
     @jsii.member(jsii_name="staticMethod")
     @builtins.classmethod
     def static_method(cls, name: builtins.str) -> builtins.str:
         '''Jsdocs for static method.
 
         :param name: The name of the person to say hello to.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c4597464b7867e98bf0052f7808e080b75874d088aeac980865a4fc19e47a6d1)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
         return typing.cast(builtins.str, jsii.sinvoke(cls, "staticMethod", [name]))
 
     @jsii.member(jsii_name="justMethod")
     def just_method(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.invoke(self, "justMethod", []))
@@ -6587,19 +7152,25 @@
         '''
         return typing.cast("Statics", jsii.sget(cls, "instance"))
 
     @instance.setter # type: ignore[no-redef]
     def instance(cls, value: "Statics") -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__748a4d0813e4a3ab750bd52215b9ff4dee315d39b160d47884780ea7c4b10daf)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.sset(cls, "instance", value)
 
     @jsii.python.classproperty
     @jsii.member(jsii_name="nonConstStatic")
     def non_const_static(cls) -> jsii.Number:  # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(jsii.Number, jsii.sget(cls, "nonConstStatic"))
 
     @non_const_static.setter # type: ignore[no-redef]
     def non_const_static(cls, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5d0ed37ae4b7f5bd294a768da342f4735c6636e0197883a5727e46ed81deec69)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.sset(cls, "nonConstStatic", value)
 
     @builtins.property
     @jsii.member(jsii_name="value")
     def value(self) -> builtins.str:
@@ -6622,10 +7193,13 @@
     def you_see_me(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "youSeeMe"))
 
     @you_see_me.setter
     def you_see_me(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__aa3b9a5342b6fe1366fac3279219c5bae15389881ddd050c544c1d0001853482)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "youSeeMe", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.StructA",
@@ -6648,10 +7222,15 @@
 
         :param required_string: 
         :param optional_number: 
         :param optional_string: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c9e4f6413d6ce49f4a289256d84d0fa97f7abac1877fc8d49f80f4a7d83a4972)
+            check_type(argname="argument required_string", value=required_string, expected_type=type_hints["required_string"])
+            check_type(argname="argument optional_number", value=optional_number, expected_type=type_hints["optional_number"])
+            check_type(argname="argument optional_string", value=optional_string, expected_type=type_hints["optional_string"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "required_string": required_string,
         }
         if optional_number is not None:
             self._values["optional_number"] = optional_number
@@ -6709,10 +7288,15 @@
         :param optional_boolean: 
         :param optional_struct_a: 
         '''
         if isinstance(optional_struct_a, dict):
             optional_struct_a = StructA(**optional_struct_a)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4d335a3a7bbc35ed76509a5e85466d6d29221efebdd6dd4de639ef040628f332)
+            check_type(argname="argument required_string", value=required_string, expected_type=type_hints["required_string"])
+            check_type(argname="argument optional_boolean", value=optional_boolean, expected_type=type_hints["optional_boolean"])
+            check_type(argname="argument optional_struct_a", value=optional_struct_a, expected_type=type_hints["optional_struct_a"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "required_string": required_string,
         }
         if optional_boolean is not None:
             self._values["optional_boolean"] = optional_boolean
@@ -6764,10 +7348,14 @@
         See: https://github.com/aws/aws-cdk/issues/4302
 
         :param scope: 
         :param props: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7eb7b6caeb33bbd3740ca0fc027022df9d4fade4a7d1943a334f2869ab44bd98)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "scope": scope,
         }
         if props is not None:
             self._values["props"] = props
@@ -6810,10 +7398,14 @@
     ) -> jsii.Number:
         '''
         :param _positional: -
         :param inputs: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e3587fc6359e7cd1adf0bb70ed66e1cd69faa462a530e07c8d25a96b942cb943)
+            check_type(argname="argument _positional", value=_positional, expected_type=type_hints["_positional"])
+            check_type(argname="argument inputs", value=inputs, expected_type=typing.Tuple[type_hints["inputs"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(jsii.Number, jsii.sinvoke(cls, "howManyVarArgsDidIPass", [_positional, *inputs]))
 
     @jsii.member(jsii_name="roundTrip")
     @builtins.classmethod
     def round_trip(
@@ -6828,10 +7420,13 @@
         :param _positional: -
         :param required: This is a required field.
         :param second_level: A union to really stress test our serialization.
         :param optional: You don't have to pass this.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b60fd8dad9496da93546e0555f2f8a7a34711e7160c06dc64a47f095f1539d02)
+            check_type(argname="argument _positional", value=_positional, expected_type=type_hints["_positional"])
         input = TopLevelStruct(
             required=required, second_level=second_level, optional=optional
         )
 
         return typing.cast("TopLevelStruct", jsii.sinvoke(cls, "roundTrip", [_positional, input]))
@@ -6848,10 +7443,13 @@
         struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
     ) -> builtins.bool:
         '''
         :param struct: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1c22dd35a08877498e4c2c0ed61e220c19d83da3b6a1e278dfcb7af4d76d2df8)
+            check_type(argname="argument struct", value=struct, expected_type=type_hints["struct"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "isStructA", [struct]))
 
     @jsii.member(jsii_name="isStructB")
     @builtins.classmethod
     def is_struct_b(
@@ -6859,18 +7457,24 @@
         struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
     ) -> builtins.bool:
         '''
         :param struct: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bfb5d0235b42940b9a17c7bb3182f454c7652fdb031f8993719a701d42833623)
+            check_type(argname="argument struct", value=struct, expected_type=type_hints["struct"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "isStructB", [struct]))
 
     @jsii.member(jsii_name="provideStruct")
     @builtins.classmethod
     def provide_struct(cls, which: builtins.str) -> typing.Union[StructA, StructB]:
         '''
         :param which: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e3e3d0b072ef214d95806fb0366dd1f4a92b97932f845c9364616c9348bce502)
+            check_type(argname="argument which", value=which, expected_type=type_hints["which"])
         return typing.cast(typing.Union[StructA, StructB], jsii.sinvoke(cls, "provideStruct", [which]))
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.StructWithCollectionOfUnionts",
@@ -6884,10 +7488,13 @@
         union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]]],
     ) -> None:
         '''
         :param union_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__06173422e8b2a410ef992bee26115592516245e72f1a99397919d18bfebc1259)
+            check_type(argname="argument union_property", value=union_property, expected_type=type_hints["union_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "union_property": union_property,
         }
 
     @builtins.property
@@ -6924,10 +7531,14 @@
     ) -> None:
         '''
         :param foo: An enum value.
         :param bar: Optional enum value (of type integer). Default: AllTypesEnum.YOUR_ENUM_VALUE
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9fac60639e71eb35a422d891e6b571b3ba2118da50de35e8ba784bbb73928be9)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
         if bar is not None:
             self._values["bar"] = bar
@@ -6983,10 +7594,16 @@
         :param default: 
         :param assert_: 
         :param result: 
         :param that: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__21b11cdfe2d95237cdddef417a67936ff8529ea3cef4bd7e80fe498f1e27527d)
+            check_type(argname="argument default", value=default, expected_type=type_hints["default"])
+            check_type(argname="argument assert_", value=assert_, expected_type=type_hints["assert_"])
+            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
+            check_type(argname="argument that", value=that, expected_type=type_hints["that"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "default": default,
         }
         if assert_ is not None:
             self._values["assert_"] = assert_
@@ -7056,10 +7673,13 @@
     @parts.setter
     def parts(
         self,
         value: typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue],
     ) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e2e14d04b1a68f16d9aef0965aa4ffbc51af3cbd2d201ac6e236d861b10c2fbf)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "parts", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.SupportsNiceJavaBuilderProps",
@@ -7075,10 +7695,14 @@
     ) -> None:
         '''
         :param bar: Some number, like 42.
         :param id: An \`\`id\`\` field here is terrible API design, because the constructor of \`\`SupportsNiceJavaBuilder\`\` already has a parameter named \`\`id\`\`. But here we are, doing it like we didn't care.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__11e78aa6557af36be636eea7a1a9b1d6ebf38d63d876b270de65a5f23152b605)
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bar": bar,
         }
         if id is not None:
             self._values["id"] = id
@@ -7127,10 +7751,13 @@
         '''
         :param id_: some identifier of your choice.
         :param bar: Some number, like 42.
         :param id: An \`\`id\`\` field here is terrible API design, because the constructor of \`\`SupportsNiceJavaBuilder\`\` already has a parameter named \`\`id\`\`. But here we are, doing it like we didn't care.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__46b91a4f1b85f01437aa8a6dda82c7c9e02f0b2ae5324f8c1591fa7ff74feaa0)
+            check_type(argname="argument id_", value=id_, expected_type=type_hints["id_"])
         props = SupportsNiceJavaBuilderProps(bar=bar, id=id)
 
         jsii.create(self.__class__, self, [id_, props])
 
     @builtins.property
@@ -7168,17 +7795,23 @@
     @jsii.member(jsii_name="modifyOtherProperty")
     def modify_other_property(self, value: builtins.str) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a961c6dee96c75a70470863d82c09136094c1d72d47aafe7f105c7733536dd4d)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "modifyOtherProperty", [value]))
 
     @jsii.member(jsii_name="modifyValueOfTheProperty")
     def modify_value_of_the_property(self, value: builtins.str) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f3d4d3109122672e8fa17c64fb60787d84a098ee0ee0857d4a10ffe5345a1908)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "modifyValueOfTheProperty", [value]))
 
     @jsii.member(jsii_name="readA")
     def read_a(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.invoke(self, "readA", []))
@@ -7198,17 +7831,23 @@
     @jsii.member(jsii_name="virtualMethod")
     def virtual_method(self, n: jsii.Number) -> jsii.Number:
         '''
         :param n: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ba36c4cb32b9551fe1c3e91bd834b2e97f7ee93d0b5919acfb1c4fd3d6161295)
+            check_type(argname="argument n", value=n, expected_type=type_hints["n"])
         return typing.cast(jsii.Number, jsii.invoke(self, "virtualMethod", [n]))
 
     @jsii.member(jsii_name="writeA")
     def write_a(self, value: jsii.Number) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7118412729d7ec6272cded791897b09f12ee70e1ca550853121f98ceb30ee0e7)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(None, jsii.invoke(self, "writeA", [value]))
 
     @builtins.property
     @jsii.member(jsii_name="readonlyProperty")
     def readonly_property(self) -> builtins.str:
@@ -7219,46 +7858,61 @@
     def a(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.get(self, "a"))
 
     @a.setter
     def a(self, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c361a6694d6564ff5c16af012cfaf94cac0a971928a1d0fb014c27f971287836)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "a", value)
 
     @builtins.property
     @jsii.member(jsii_name="callerIsProperty")
     def caller_is_property(self) -> jsii.Number:
         return typing.cast(jsii.Number, jsii.get(self, "callerIsProperty"))
 
     @caller_is_property.setter
     def caller_is_property(self, value: jsii.Number) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d5d44f6e3395b0db421bab95a6dd7d1560538c63f136025c6b216ffb01eae179)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "callerIsProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="otherProperty")
     def other_property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "otherProperty"))
 
     @other_property.setter
     def other_property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__64c8c65ae76fcafb4b6d28e75f8fd31efad60ab9e71d11cbd5877c28c45d8f70)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "otherProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="theProperty")
     def the_property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "theProperty"))
 
     @the_property.setter
     def the_property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__52ea95020be0094da769c873214a182768aa2de47b1c4c3dff43f1226edfe281)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "theProperty", value)
 
     @builtins.property
     @jsii.member(jsii_name="valueOfOtherProperty")
     def value_of_other_property(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "valueOfOtherProperty"))
 
     @value_of_other_property.setter
     def value_of_other_property(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__21d6ffe465a7e42c257c8318bf2bee38ecbc6b1959e6e945e769e365afb3e55d)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "valueOfOtherProperty", value)
 
 
 class TestStructWithEnum(
     metaclass=jsii.JSIIMeta,
@@ -7341,10 +7995,15 @@
         '''
         :param required: This is a required field.
         :param second_level: A union to really stress test our serialization.
         :param optional: You don't have to pass this.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__74359fdf4e6a6505a1c0bc4c2c687826dde0a7696de75fc39f9ed57d89137f96)
+            check_type(argname="argument required", value=required, expected_type=type_hints["required"])
+            check_type(argname="argument second_level", value=second_level, expected_type=type_hints["second_level"])
+            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "required": required,
             "second_level": second_level,
         }
         if optional is not None:
@@ -7435,10 +8094,13 @@
 
     def __init__(self, operand: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
         '''
         :param operand: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e31f878fe14747887a58683a15ca9c8ab54ec35cd6e3a665ad70dd53deadb573)
+            check_type(argname="argument operand", value=operand, expected_type=type_hints["operand"])
         jsii.create(self.__class__, self, [operand])
 
     @builtins.property
     @jsii.member(jsii_name="operand")
     def operand(self) -> _scope_jsii_calc_lib_c61f082f.NumericValue:
@@ -7469,10 +8131,14 @@
     ) -> None:
         '''
         :param bar: 
         :param foo: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__223de5294ccc50da976adb8794cb8556981e31d63a2c8b249f7dfbd9e2d99eac)
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bar": bar,
         }
         if foo is not None:
             self._values["foo"] = foo
@@ -7509,10 +8175,13 @@
 
     def __init__(self, delegate: typing.Mapping[builtins.str, typing.Any]) -> None:
         '''
         :param delegate: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__aaaf822e80c6473bff9b1da58151a278cd846ae0614db9af97bc57ea6f899ce2)
+            check_type(argname="argument delegate", value=delegate, expected_type=type_hints["delegate"])
         jsii.create(self.__class__, self, [delegate])
 
     @jsii.python.classproperty
     @jsii.member(jsii_name="reflector")
     def REFLECTOR(cls) -> _scope_jsii_calc_lib_custom_submodule_name_c61f082f.Reflector:
@@ -7555,10 +8224,13 @@
 ):
     def __init__(self, obj: IInterfaceWithProperties) -> None:
         '''
         :param obj: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__73d1545891c65d400938add489402441cb083c61d214ad7a922b6417d3984732)
+            check_type(argname="argument obj", value=obj, expected_type=type_hints["obj"])
         jsii.create(self.__class__, self, [obj])
 
     @jsii.member(jsii_name="justRead")
     def just_read(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.invoke(self, "justRead", []))
@@ -7569,17 +8241,23 @@
         ext: IInterfaceWithPropertiesExtension,
     ) -> builtins.str:
         '''
         :param ext: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__60f3870a6dceb3773397b75ec3f3b664f38c2cc3d2f37dc055262663d12f41a8)
+            check_type(argname="argument ext", value=ext, expected_type=type_hints["ext"])
         return typing.cast(builtins.str, jsii.invoke(self, "readStringAndNumber", [ext]))
 
     @jsii.member(jsii_name="writeAndRead")
     def write_and_read(self, value: builtins.str) -> builtins.str:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__42edcb376aed0b6e6fec7d7df016bda9e3a31df0e47ecabb5465d1c84d16a414)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         return typing.cast(builtins.str, jsii.invoke(self, "writeAndRead", [value]))
 
     @builtins.property
     @jsii.member(jsii_name="obj")
     def obj(self) -> IInterfaceWithProperties:
@@ -7589,25 +8267,34 @@
 class VariadicInvoker(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.VariadicInvoker"):
     def __init__(self, method: "VariadicMethod") -> None:
         '''
         :param method: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6d238d6a2f6e464c570c3176db3d78d62e0be9908b705705c8f6d7b6b2385c54)
+            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
         jsii.create(self.__class__, self, [method])
 
     @jsii.member(jsii_name="asArray")
     def as_array(self, *values: jsii.Number) -> typing.List[jsii.Number]:
         '''
         :param values: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__43f32dfb73f1a7fe9c86c00bbc381391db4812c13b5b72363ddcfcd57638c368)
+            check_type(argname="argument values", value=values, expected_type=typing.Tuple[type_hints["values"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(typing.List[jsii.Number], jsii.invoke(self, "asArray", [*values]))
 
 
 class VariadicMethod(metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.VariadicMethod"):
     def __init__(self, *prefix: jsii.Number) -> None:
         '''
         :param prefix: a prefix that will be use for all values returned by \`\`#asArray\`\`.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a33769c23320f9f6bce3e3a70c594135cf44ca5c9c6d1de1cae8cc62a99d49e9)
+            check_type(argname="argument prefix", value=prefix, expected_type=typing.Tuple[type_hints["prefix"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         jsii.create(self.__class__, self, [*prefix])
 
     @jsii.member(jsii_name="asArray")
     def as_array(
         self,
@@ -7616,10 +8303,14 @@
     ) -> typing.List[jsii.Number]:
         '''
         :param first: the first element of the array to be returned (after the \`\`prefix\`\` provided at construction time).
         :param others: other elements to be included in the array.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1c18f2c7d91dcdc13843ff1637ed95a1f1c1ed99384d6276ee493b0ca579b4a4)
+            check_type(argname="argument first", value=first, expected_type=type_hints["first"])
+            check_type(argname="argument others", value=others, expected_type=typing.Tuple[type_hints["others"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         return typing.cast(typing.List[jsii.Number], jsii.invoke(self, "asArray", [first, *others]))
 
 
 class VariadicTypeUnion(
     metaclass=jsii.JSIIMeta,
@@ -7627,19 +8318,25 @@
 ):
     def __init__(self, *union: typing.Union[StructA, StructB]) -> None:
         '''
         :param union: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f18ff2aa5c744d99cc2b37e705d6ed44823660f714c20539c148c9e34e123752)
+            check_type(argname="argument union", value=union, expected_type=typing.Tuple[type_hints["union"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         jsii.create(self.__class__, self, [*union])
 
     @builtins.property
     @jsii.member(jsii_name="union")
     def union(self) -> typing.List[typing.Union[StructA, StructB]]:
         return typing.cast(typing.List[typing.Union[StructA, StructB]], jsii.get(self, "union"))
 
     @union.setter
     def union(self, value: typing.List[typing.Union[StructA, StructB]]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__01944feab2feb5a9fdf3d356f62de139685f520d3bb3a38ddc5c42d0b03963fe)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "union", value)
 
 
 class VirtualMethodPlayground(
     metaclass=jsii.JSIIMeta,
@@ -7651,38 +8348,53 @@
     @jsii.member(jsii_name="overrideMeAsync")
     def override_me_async(self, index: jsii.Number) -> jsii.Number:
         '''
         :param index: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5efa2ef42e261d5c38c59d5e216e587cb3005bbbb5b4a62e926087ee58478a36)
+            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
         return typing.cast(jsii.Number, jsii.ainvoke(self, "overrideMeAsync", [index]))
 
     @jsii.member(jsii_name="overrideMeSync")
     def override_me_sync(self, index: jsii.Number) -> jsii.Number:
         '''
         :param index: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca8f2360b0292d0b5329ac52818673aece7fb01cf2f09567e60ff65b7728c9cc)
+            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
         return typing.cast(jsii.Number, jsii.invoke(self, "overrideMeSync", [index]))
 
     @jsii.member(jsii_name="parallelSumAsync")
     def parallel_sum_async(self, count: jsii.Number) -> jsii.Number:
         '''
         :param count: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5bc99fd66b59152ee7799cf716c91bec428d7091eb33ece69057f9ca9b9fdb19)
+            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
         return typing.cast(jsii.Number, jsii.ainvoke(self, "parallelSumAsync", [count]))
 
     @jsii.member(jsii_name="serialSumAsync")
     def serial_sum_async(self, count: jsii.Number) -> jsii.Number:
         '''
         :param count: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__58451fb4813d1aa8877a55de41f1ef8bd30300048337edb2bcf16985abbb6f45)
+            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
         return typing.cast(jsii.Number, jsii.ainvoke(self, "serialSumAsync", [count]))
 
     @jsii.member(jsii_name="sumSync")
     def sum_sync(self, count: jsii.Number) -> jsii.Number:
         '''
         :param count: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7ac4c09636b11fefb0a54fbd52b88fc2b4c5c356eb07189a0d2545601f3bef9c)
+            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
         return typing.cast(jsii.Number, jsii.invoke(self, "sumSync", [count]))
 
 
 class VoidCallback(
     metaclass=jsii.JSIIAbstractClass,
@@ -7730,10 +8442,13 @@
 
     def __init__(self, private_field: typing.Optional[builtins.str] = None) -> None:
         '''
         :param private_field: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__01fcbc911a24b1fa352275e1273526114db562d2c278b742181eba6e8cb11ad4)
+            check_type(argname="argument private_field", value=private_field, expected_type=type_hints["private_field"])
         jsii.create(self.__class__, self, [private_field])
 
     @builtins.property
     @jsii.member(jsii_name="success")
     def success(self) -> builtins.bool:
@@ -7774,10 +8489,13 @@
     @jsii.member(jsii_name="abstractMethod")
     def abstract_method(self, name: builtins.str) -> builtins.str:
         '''
         :param name: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__af1f574dee5c4eb581961518ccf32b4060094ed2f9b7e60bece1ed48e3fc45a1)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
         return typing.cast(builtins.str, jsii.invoke(self, "abstractMethod", [name]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, AbstractClass).__jsii_proxy_class__ = lambda : _AbstractClassProxy
 
@@ -7793,10 +8511,14 @@
         '''Creates a BinaryOperation.
 
         :param lhs: Left-hand side operand.
         :param rhs: Right-hand side operand.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c0e59e6ea7e78215051bf4fe6b69de179aefb4116a344decdfaab4b6b15189b8)
+            check_type(argname="argument lhs", value=lhs, expected_type=type_hints["lhs"])
+            check_type(argname="argument rhs", value=rhs, expected_type=type_hints["rhs"])
         jsii.create(self.__class__, self, [lhs, rhs])
 
     @jsii.member(jsii_name="toString")
     def to_string(self) -> builtins.str:
         '''String representation of the value.'''
@@ -7840,10 +8562,13 @@
     def rung(self) -> builtins.bool:
         return typing.cast(builtins.bool, jsii.get(self, "rung"))
 
     @rung.setter
     def rung(self, value: builtins.bool) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fa23831ecd0b539d7689616a0557240dc1a45f924fafe58c0d5f0ac464eecf94)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "rung", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.ChildStruct982",
@@ -7854,10 +8579,14 @@
     def __init__(self, *, foo: builtins.str, bar: jsii.Number) -> None:
         '''
         :param foo: 
         :param bar: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__84a0b7e93c52a4977e9726c1186b64f57ff35c59c5bc0e7250da1d3236e70208)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
+            check_type(argname="argument bar", value=bar, expected_type=type_hints["bar"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
             "bar": bar,
         }
 
@@ -7898,37 +8627,49 @@
     def a(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "a"))
 
     @a.setter
     def a(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__720d53a768711730e792d129fcff6272627608d1d3942f42e3010e61a3463b31)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "a", value)
 
     @builtins.property
     @jsii.member(jsii_name="b")
     def b(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "b"))
 
     @b.setter
     def b(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5236e267a6763b672404dac13a3d5e50c03eb03d35fe2c18cbe7f649933301f1)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "b", value)
 
     @builtins.property
     @jsii.member(jsii_name="c")
     def c(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "c"))
 
     @c.setter
     def c(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1bd3b16d1aaf127e7610a230095bced32c4c3ef1cadc73f6b24c76b3ebffdd8e)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "c", value)
 
     @builtins.property
     @jsii.member(jsii_name="d")
     def d(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "d"))
 
     @d.setter
     def d(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4e685d8185af60a2f5c9bcffe812224568fe893228304e510b4d989f92c19b90)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "d", value)
 
 
 @jsii.implements(INonInternalInterface)
 class ClassThatImplementsThePrivateInterface(
@@ -7943,37 +8684,49 @@
     def a(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "a"))
 
     @a.setter
     def a(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6499a25aa5ac6723e26c4c716dd2d62a1f9ecd75ae2a476d3213fa5fe8792a1d)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "a", value)
 
     @builtins.property
     @jsii.member(jsii_name="b")
     def b(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "b"))
 
     @b.setter
     def b(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5da75e226d085b0daac7742a86525ea697c77a044896ce80d48677f5fadb2d57)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "b", value)
 
     @builtins.property
     @jsii.member(jsii_name="c")
     def c(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "c"))
 
     @c.setter
     def c(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__538f9410afd2d028ca599a233896016121b326bd90d69693e949aff75d72caf3)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "c", value)
 
     @builtins.property
     @jsii.member(jsii_name="e")
     def e(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "e"))
 
     @e.setter
     def e(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ba8bf3471001981f03d1ad5b84a1b0a4a4d7d556c72734d25d96637a60ad2477)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "e", value)
 
 
 @jsii.implements(IInterfaceWithProperties)
 class ClassWithPrivateConstructorAndAutomaticProperties(
@@ -7991,10 +8744,14 @@
     ) -> "ClassWithPrivateConstructorAndAutomaticProperties":
         '''
         :param read_only_string: -
         :param read_write_string: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__71399b17d07223b2b83f0d7b33d5172c49eb3d0cf3fe38d6059d4c9b7f471113)
+            check_type(argname="argument read_only_string", value=read_only_string, expected_type=type_hints["read_only_string"])
+            check_type(argname="argument read_write_string", value=read_write_string, expected_type=type_hints["read_write_string"])
         return typing.cast("ClassWithPrivateConstructorAndAutomaticProperties", jsii.sinvoke(cls, "create", [read_only_string, read_write_string]))
 
     @builtins.property
     @jsii.member(jsii_name="readOnlyString")
     def read_only_string(self) -> builtins.str:
@@ -8005,10 +8762,13 @@
     def read_write_string(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "readWriteString"))
 
     @read_write_string.setter
     def read_write_string(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e308499c7b9268c91ee3dc9e4a9c975efdfaa0cd72bd877383c6c64e8f2768d0)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "readWriteString", value)
 
 
 @jsii.implements(IIndirectlyImplemented)
 class FullCombo(BaseClass, metaclass=jsii.JSIIMeta, jsii_type="jsii-calc.FullCombo"):
@@ -8123,10 +8883,13 @@
 ):
     def __init__(self, property: builtins.str) -> None:
         '''
         :param property: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__148cd823b5de47723c8a76d0553f3ff6c880ba8ecec14b9a86bd89025a18f4d3)
+            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
         jsii.create(self.__class__, self, [property])
 
     @jsii.member(jsii_name="bar")
     def bar(self) -> None:
         return typing.cast(None, jsii.invoke(self, "bar", []))
@@ -8147,10 +8910,13 @@
 
     def __init__(self, operand: _scope_jsii_calc_lib_c61f082f.NumericValue) -> None:
         '''
         :param operand: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e7aa949631662ae6f6ab2804e4a231fa264a1c879d86efa8267e53158c50e647)
+            check_type(argname="argument operand", value=operand, expected_type=type_hints["operand"])
         jsii.create(self.__class__, self, [operand])
 
     @jsii.member(jsii_name="farewell")
     def farewell(self) -> builtins.str:
         '''Say farewell.'''
@@ -8210,10 +8976,16 @@
         :param id: some identifier.
         :param default_bar: the default value of \`\`bar\`\`.
         :param props: some props once can provide.
         :param rest: a variadic continuation.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2f90423a63bd0fc04016022e622b4bf01d35f365e38b15153d0a4d6fa014ee5b)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument default_bar", value=default_bar, expected_type=type_hints["default_bar"])
+            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
+            check_type(argname="argument rest", value=rest, expected_type=typing.Tuple[type_hints["rest"], ...]) # pyright: ignore [reportGeneralTypeIssues]
         jsii.create(self.__class__, self, [id, default_bar, props, *rest])
 
     @builtins.property
     @jsii.member(jsii_name="id")
     def id(self) -> jsii.Number:
@@ -8509,5 +9281,1522 @@
 from . import nodirect
 from . import onlystatic
 from . import python_self
 from . import submodule
 from . import union
+
+def _typecheckingstub__8348af6419fc01178f78ba59cea59d0c7437626169866d772f4e957d09e6e13a(
+    seed: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__06c06b97e36be962012901c4c1f542b3f51b377154f91bf1154d1bd475221829(
+    str: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0f076015f51de68c2d0e6902c0d199c9058ad0bff9c11f58b2aae99578ece6ae(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__81a2d86a9598fa10dde4af8bd70d369967edc6febb332dc788702f6aea07f33c(
+    inp: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__56056c33132184bd4ad46f69c534777112c49b9a987cc7b962d4026cf550998c(
+    value: StringEnum,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1ab9ae75c746f751d2bf2ac254bcd1bee8eae7281ec936e222c9f29765fdcfa4(
+    value: typing.List[typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f88e356a91a703923e622c02850435cc7f632a66f49ca79f00d42590d2928a5e(
+    value: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d81f1a89ccd850ccdb0b96a43000dfcde30f3542bf797051c754610d641f2316(
+    value: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0c663902e9a8a1db9aff59eb8642a68c944dc2e3385744098d2b51ecf2e2e11f(
+    value: typing.List[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__106a83d3c77dbb6dbc6fcd706bca888d57ec37cd4beedf7dcc9d7d4428f44845(
+    value: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5e62ea2f9629943c1138cad77629f47906644279c178b9436e4303e5a5f74c8a(
+    value: datetime.datetime,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f0d83d5dde352e12690bd34359b2272194b20ad0d4585d4cd235a62a68413cc7(
+    value: AllTypesEnum,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8cddc5c03b0b87366a7bf274aedf92ced502b23fe811780c7f8c3da532cba3fc(
+    value: typing.Mapping[typing.Any, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ce34799b1443789feb28cffe434f5bcbb9cb940065992aa75dbb30eb89cd78e6(
+    value: typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c8fb4d044e2e7432d7e661aafdb286ebf21dfe5a82b9908dee57945f6892a63e(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4e3dc199e54a9fbd40ceb20cecf887aa2aeca670e9ba223707466d9670eec9b9(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4a9e87035008a2c1b649b911c8cfc02f2723230d8ced957948b2948c76caf61a(
+    value: typing.List[typing.Union[jsii.Number, _scope_jsii_calc_lib_c61f082f.NumericValue]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__62ebee42e1871545bc2e82cfb9c7fe43b5a607c8f662caff89dda0f0ed99a3df(
+    value: typing.Mapping[builtins.str, typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c9be2756a18e8a40eb03cf55231201574f76abf02996a73d0d75fefd1393473d(
+    value: typing.Union[builtins.str, jsii.Number, _scope_jsii_calc_lib_c61f082f.Number, Multiply],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e49729a44c21aef8c75584ff0991ddba3ee45184cacf816eb1a6a13b99e99ecc(
+    value: typing.List[typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f8de6b30de9bfa884f9de02e2abe57e9394fb7a387b5691f858b7b98817b1db7(
+    value: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__901c3574a81e006fdf36f73e34f66b34f65ada4bddcb11cd15a51d6e3d9b59e4(
+    value: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__705bed55c0dbc20a3a1bad9a21931270f0c285e5b3b276e13bca645ffa7ccb0f(
+    value: typing.Optional[StringEnum],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__99730dd857f01c8e93755d3e4f1e04f44efd2e63487e37db32f0fae8d36c618e(
+    _p1: builtins.str,
+    _p2: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7f25304a2274ca1691dbe05a223f32126250948b15187c5095780e5c9af08c2a(
+    with_param: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__12f6979e6d88948e4aebfe8c25ed814c21d19b4b549d6bc2db4620794e706238(
+    _x: builtins.str,
+    _y: jsii.Number,
+    _z: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ca978ab380897c8607252c370202d45bc72e8b5cdc52549bb53b870299333d52(
+    _x: builtins.str,
+    _y: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__35fb7428c2ad70583f7b280c07cec184905b51e8e896efe6cc88eaf83a6f65c3(
+    scope_: Bell,
+    *,
+    scope: builtins.str,
+    props: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__49537950cbbeb6e2c62cb1b8a079cc9bb5cc6d06d95cf2229128539d2be886a3(
+    mult: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__408890be1949f7684db536e79081b85d00d72250ca9eb19c74db6ad226564784(
+    lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+    rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__67894f861ef38d2769b440d2fe71f549cb9e333247b385c5d6ae862b2eb04fc5(
+    value: typing.Any,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__106b87a3d0b194bda7cee057654f752c82d9a92a3775bcc3b2dc5cf7814ba84d(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b0e9a9c8546dd024e1568b2e6d11bd847e53548d624f33afffdffacc77fe01ef(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c62707f1a80d6bc26c0b74205f8892c1777e6ed97359263df05628018d8ef6fc(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c74abb191c66f86aed2c139ec3e50b0442b6d3bdcd41beb06db17c9b3c5d93d0(
+    value: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1af5d9bb897bd9bfc2029e92d33fc306fc090e2d0a9bc0bd70fb01762e798fe6(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__349b2a1dce95cb7ff4c5a7772d81772697767c5f4e7e5fd709847ff5e526c3c1(
+    value: typing.Optional[typing.Union[Add, Multiply, Power]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__21033948ed66f89716ed818c4cf9e5a38a9252e042231e1e8e1672356d403bef(
+    *,
+    initial_value: typing.Optional[jsii.Number] = None,
+    maximum_value: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9e749834c2e46eee6370de7b60daabbff6e5c16febe9775b98a2b961b0d4e335(
+    union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__80b80f78c4ac7fda46ac2aec7ab826a87bef3eaaba64661c90f346972800baf5(
+    value: typing.List[typing.Mapping[builtins.str, typing.Union[StructA, StructB]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7eb49cfb1282d7f1bd28096ff0407c0806693194f02f5c053936f99756a2a8fd(
+    map: typing.Mapping[builtins.str, builtins.str],
+    array: typing.Sequence[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__964903eb68623806c91fc9026cacfdc726cfbb287698530724c5a9938a7bb2ca(
+    value: typing.List[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8dd7203701e4915203e4778820ee40fe6bdd6f0bb2855c200f375606277e06c8(
+    value: typing.Mapping[builtins.str, builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c0c76fec28076841e36c26581c26385de1e984d96e91ea434a61c4bf36c9b4d9(
+    value: typing.List[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5461a3c7bb81040765e4ca2e9effb12cc7f5fb018e5e1b8b21501a3f9cd6a8b3(
+    value: typing.Mapping[builtins.str, builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__11d94174b1d488125abef65967a384ceb599f4948eca6cb9be3d55e1979fb64f(
+    array: typing.Sequence[typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    record: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    obj: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    *,
+    array_prop: typing.Sequence[typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    obj_prop: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    record_prop: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c017a39e0da5d21f3a9acbfd00f6a5c84eb4cad306148504e7c835359d35537e(
+    int: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7a756cab89b47a2ae4c08f36162482b60fdf963b8ba638917a63c5e110b4d33e(
+    assert_: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3afbef7e05ef43a18b9260b86660c09b15be66fabeae128c9a9f99b729da7143(
+    value: IMutableObjectLiteral,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0b8f0f729686dad01c8555a3b1bc47509e495bd18f1560ef045b558884b2a1fb(
+    union_property: typing.Sequence[typing.Union[typing.Mapping[builtins.str, typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]], typing.Sequence[typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a8a15eb37393d5188c71779e29278367f7b3600c6dd48bdbcd502cdf510c3c15(
+    value: typing.List[typing.Union[typing.Mapping[builtins.str, typing.Union[StructA, StructB]], typing.List[typing.Union[StructA, StructB]]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ec229cc92e04670f4dca9546759b3b39ee813eb1aa18057135bb155d08971e6a(
+    value: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.List[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, AbstractClass]]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__481b1113b85e6dc9d7ba31c3ef5654e3550abac1edef9204348ab0f9554f61c1(
+    *,
+    union_property: typing.Optional[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, typing.Sequence[typing.Union[_scope_jsii_calc_lib_c61f082f.IFriendly, AbstractClass]]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5676fcb3395f1db1a013537fa52220553e5e418c2a9d97aa2f9541c00ffe259e(
+    consumer: PartiallyInitializedThisConsumer,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5c5defc6d683ee91707f8b7770d8d2fb11d381b9c928d7e5d6e2c5c495395f38(
+    delegate: IStructReturningDelegate,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1df814299f3f9720be108d84bdfd61bc591699a79a3c8ac6d450bfb0a9610278(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2f08bd2d56e856071db5f777b63fe2577f9e96dbfcd91e4044d0eda2d26f9017(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4a2b7f0a05298ddaec112cb088cc71cfa2856aaa1d8414a5157d581b6d5a7293(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f751da3f5766ea4973eb2d89086565259f0a3cd626425a7eec723afd7b64f392(
+    ringer: IConcreteBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__cca04fe4a4c41a0034087ab0c574d1d2f1d0427d87a806fc660446b6a7e5290a(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7bde53b867de290d21a419baa46b8e833a0d394835a1ce2be3b429179b2ddce5(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__988e53d92b16fb4b7224c654f985a074cbfa7dd5f567df005b41522641ad92ac(
+    ringer: IBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1d786308546ae61deacb465c6f501fe7e0be028973494548b57e0480759ed460(
+    ringer: IConcreteBellRinger,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__83037a3f429b90a38d2d9532a347144030578d83f68817b1a5677ebcd1b38e12(
+    obj: IAnotherPublicInterface,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__139bf4e63e56bef32e364c5972e055de5cba153d49cc821740fba1d51f73ef70(
+    obj: INonInternalInterface,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2be181b08e5a2c0e1e3f3a84732a423af31039117701d35431ee251d343ca9d5(
+    *,
+    array_prop: typing.Sequence[typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    obj_prop: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+    record_prop: typing.Mapping[builtins.str, typing.Union[DummyObj, typing.Dict[builtins.str, typing.Any]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dd941dcba8415b4b4dbb95bc3f55ac3404bdaf303822dfc7093fb615dc66b2cf(
+    data: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9008dfc97234c0f2895caaa88d20a94de081c3cd97c38f9a012f13cdae75fbd6(
+    map: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__019e6ec86ae7ee325dc404a7025eaf0edcb164e166535a831bccf6658adfbb10(
+    arg1: typing.Optional[jsii.Number] = None,
+    arg2: typing.Optional[builtins.str] = None,
+    arg3: typing.Optional[datetime.datetime] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f64945b01dd806fcd872f369983e1fa6b3db8811cb0682ac6adf88aebb0aabda(
+    readonly_string: builtins.str,
+    mutable_number: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3aef3220b38be7daf4208453b1766d9eafb6a74bd51dfb351d21235a205afa34(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__cdee1d6893b4921a8d7cf0a9c957a543b69f7a98eb3cedd7ece84871fc81c767(
+    *,
+    readonly_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c544311353634d5a2f08144f0c184afbcb700d8304b9f49deae99f19e1e7b0af(
+    *,
+    anumber: jsii.Number,
+    astring: builtins.str,
+    first_optional: typing.Optional[typing.Sequence[builtins.str]] = None,
+    another_required: datetime.datetime,
+    bool: builtins.bool,
+    non_primitive: DoubleTrouble,
+    another_optional: typing.Optional[typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue]] = None,
+    optional_any: typing.Any = None,
+    optional_array: typing.Optional[typing.Sequence[builtins.str]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__865cdfdd094ca753189170221ee7d6a0e59c2c0bcfdeff3dc37bb87dd39515ca(
+    *,
+    hoisted_top: typing.Optional[builtins.str] = None,
+    left: typing.Optional[jsii.Number] = None,
+    right: typing.Optional[builtins.bool] = None,
+    bottom: typing.Optional[datetime.datetime] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__cfa52ba952c3d4a7e6df7fba3f619bf3ac14c52e829cce862a5fa495e45d0e70(
+    *,
+    base_level_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__354311bd3d60d2b3b4ea927d6a96bdf66aa6d1109c29bfcd96266051c7c30a5e(
+    *,
+    base_level_property: builtins.str,
+    first_mid_level_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8074c5f38699399b9e6f8708c125bef5d7c89118c36ffcce8582d66cac2197da(
+    *,
+    base_level_property: builtins.str,
+    second_mid_level_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9384691e88dd3ab7e55516762b2076445d94bd6d9348db1b93f79de9f4ae0ea1(
+    *,
+    base_level_property: builtins.str,
+    first_mid_level_property: builtins.str,
+    second_mid_level_property: builtins.str,
+    top_level_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5ae2124576c295a0c88fc75be0e57258f0f72e63c733e7493367b8558266510e(
+    new_value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8ffaadb351f5c2c48a7368068d5c88e0c7836deefe0e13aa9fe53ac104052fd5(
+    _required_any: typing.Any,
+    _optional_any: typing.Any = None,
+    _optional_string: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5af7b38b9b5c170ebd3e05c215e05f10e6843b03868850dad87a5a149b90e790(
+    optional: typing.Optional[builtins.str] = None,
+    *things: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ae5d543014149876cec8b005abbb94c112981cccaf318870c7fe4e8353c2c675(
+    *,
+    example: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c0d457497f870b36d210f01af9890c6624684d1e53da833858e801c18baf9fbb(
+    value_store: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4f40c12fae2ef2673f3f324c0c452f65c187c1b3e6552b86768465a2d20de051(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9106fb2a86e944ce0c61537852ab2d310a8a53448c6946af051de0325a67fa1a(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ad557fbd0532aa4220227645f5aae3e73ebae6b529cfe074430abf30d18cd5e9(
+    original_value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a4026611d197b83d9a37b973ba97c69254e674921a7d89d0eb57ac41a19b636e(
+    new_value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2a7f203302b2610301f1b36f34453db0f5572f2e02b0bc4c9933fd670e594222(
+    clock: IWallClock,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a90d161fb7d47a195a192cf987ac6968fc2c6fbe27005bdd7684478a3d956e66(
+    word: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b87cc89f87e9b1c180227625f3aba9395da5a8b258a88e605d466edb9004d709(
+    opts: typing.Union[EraseUndefinedHashValuesOptions, typing.Dict[builtins.str, typing.Any]],
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d34e4f5dab670ec3ea298ec2cda50be32700f7f52dcef6a618ca9cb3706062ee(
+    *,
+    option1: typing.Optional[builtins.str] = None,
+    option2: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6a92c7223d00e7a0a2f0611cbb689671885b835bb26eedc8eb4a4d12e4ed5021(
+    readonly_string: builtins.str,
+    mutable_number: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__52559292c6e04ad49e53e443b1a4c56149833b8f12876d779bb8860fcb231b41(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b0c8f4c6eca5af7072a4a7c737950b39e75c61a56c505deb94edc5cd0995ed7d(
+    *,
+    readonly_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dad018fa707514e8023df185b5e6e0a4b611bec563fe57abd9b81939b8833ebb(
+    success: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__861a5ec03219f6c9fecd1b039faa2e53075227ff0d28f8eb66929909bc0c3096(
+    *,
+    boom: builtins.bool,
+    prop: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__82149b1f61aca58419f6ba4c74c8bb1c5c241433707e64ea4626937b294d8fe5(
+    readonly_string: builtins.str,
+    mutable_number: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8380ec30b1f8773df7b5b27be8811be79b04f1d17c8eca83f83927eb56cdfd34(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8e8843a5fc914ec2c1e3baccdad526ea4d48eee37296f6812f3c0673ef86794f(
+    *,
+    readonly_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3dce87825e36304d54521ce5524aa7e230fa5d505b0abbc79101fd9014f2cbd9(
+    *,
+    name: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d17f0544be961cba6cabfbb40f28c196963de107fcaef9c56d8227bdcb359431(
+    friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3eabfcad9a21b26024f4c1480ca127a3d6c6888067f0ae991d5922a49bfe81d4(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d127476ce3b6e59ff9f375f547c1b6e1826d7a3969612c0605ebd0017d2b985d(
+    bell: IBell,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2c34aaac5945bdc61c4f56492dee5608e1852940835d94d3e991fed377db66f2(
+    bell: Bell,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e4d76200a6c5bdbdd51f208229da8bfd8f6f4c967af28e1e733579780e9d4a0e(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6e68d313f3254be7145220b211c66f45749aa8efc15aaf93d96330eb3cb7c6c7(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8199a83e86f8a4cf29ddc53d2b2151c37c7fa10d29562b454127376d1867d6da(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a904d745cb9f037de717ed7a2b1d3a207493564662fdbe1d7c63e60a24f9bace(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5568c72c746dd5221cb6fb7b741ed7a3346c346d7a30863c5abe3d99ada53098(
+    arg1: builtins.str,
+    arg2: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__858de6e8785f18ad264a158ca83a0fc1e0a6299efa9f77a0b31eaaffaa5b086c(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c571c6749392bc04e123a99b926edaf10b88be6b6d6b6a3937cae9893af5119e(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e0395944061fad9d5156b633dc20682ff9759ae0acb88df574b159f4919ab3a5(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9d1e4198ba3f4e6b6a6f4ce0a4a185223ec216368c0c3304c69b029aba13ca49(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6774e195ab25dab5790e1d187eb30be56997804d5186753a9928f2575f81977b(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__831f664cd567fd4e707fd175e9c9e13519f3ca587b792d7d5bc79f427589a802(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__254a58386276f7b7d5a41dddd674375b8942c2cad4deb6c2d24b55d240d14350(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__10bb8b026d6c8368d479cf0da8b27c049c5f9088f173a63624e515dd36607439(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2df4d055b033cdfdf7ad915b451ddc787ad68fb64b7e02386a9d8e591c1657af(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b70592e4d080897239bf5f8b0de5b6b464cd9e888e39fca1082c04b5cbeca890(
+    *,
+    foo: _scope_jsii_calc_base_of_base_49fa37fe.Very,
+    bar: builtins.str,
+    goo: datetime.datetime,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1d6e348a61ed27bfc8b7928365798b43e0130ca2b720c1105baca04fa093d194(
+    count: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__30ce308abdc1d2462c00bf7a4acc194ec05d61ddee24b2e79c674aa7034e5ffa(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__eef7c487e6f0c4d81dd633cf70121104ff8f3458fa52a418df64bcab9fe4bd3e(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a7654af9a241e67ad498c3eb33b98e6cdb1558487bb9b02dcce41f75334b76ad(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__43f45c49ecee3d08351b82aa5cdc3548d9dafa534cd2d99da8b5c5c9188e9a54(
+    value: typing.Any = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ef705a05998260349d35c748c557e65cf539d53e136eb9191250080bdce852c3(
+    *,
+    value: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2a9e65060bf85c3d49b79ada1f9394ae146c380a4212c190065e031098d570b8(
+    *,
+    prop: typing.Union[LevelOne.PropBooleanValue, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__479be5d5625f656c28cf12ffdc2cef9d6d74aae555551630f440fcb05351d261(
+    *,
+    prop: typing.Union[LevelOne.PropProperty, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b3d89a25beb0ebd10c196d941aa924197ae9a2def08f1f414c190a2a6d943d9c(
+    *,
+    container_port: typing.Optional[jsii.Number] = None,
+    cpu: typing.Optional[builtins.str] = None,
+    memory_mib: typing.Optional[builtins.str] = None,
+    public_load_balancer: typing.Optional[builtins.bool] = None,
+    public_tasks: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7e73465ea858e34d4df8697d34f29a53ca3c3a41c47946382e5d49f498e3747d(
+    lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+    rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__04dae031a5097183ccda93eb91ec51a8a6fa1133134a6a398f1f05c581bc0091(
+    *,
+    number_prop: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__218107d38285901ff40e08163f0de0bac5d835bd64c21c0a735e8d72399ebe35(
+    _param1: builtins.str,
+    optional: typing.Any = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a109cd8429db09172895a3eb04ca7e9d5c92129c7ca7a50f85fa89b6f6ab366b(
+    value: typing.Any = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7102c29a709c4297fb88615c74a3e42a584364ac4ccba5c1db42a65e05184d1b(
+    value: typing.Optional[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ae8d47cabe4d36f88c891d250d7e792432b0d153223789ec3687e714ba92a5f3(
+    *,
+    array_with_three_elements_and_undefined_as_second_argument: typing.Sequence[typing.Any],
+    this_should_be_undefined: typing.Any = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3c1812783ba0b3b2146a3dd9609a6e12af404502ff5fbb9b9a9be49bf576122b(
+    generator: IRandomNumberGenerator,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__151b90e9765ce9a05ae13e568f4ba7c9e36e34c1cd991c5c1ee0249869fd4cce(
+    gen: IRandomNumberGenerator,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0f5a1cc548d3db6e156cec5671bc04b980132e529c77f3bb5aaa58427db35e7c(
+    value: IRandomNumberGenerator,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f5cb9f9511b0248cd4c0c4bec4eed9e75e7690012237fdb1b39b3f7b3bb0392e(
+    values: typing.Sequence[_scope_jsii_calc_lib_c61f082f.NumericValue],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ca5199647728e53a1ec89d4fd7dad9aeb7239f8c1213c51b4e2eda734daa4cf4(
+    values: typing.Mapping[builtins.str, _scope_jsii_calc_lib_c61f082f.NumericValue],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__da93d15e57e6e2a1857cd7df156fb2a55ec91715c97323f20268def40f72137c(
+    delegate: IInterfaceWithOptionalMethodArguments,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5f6c5e5b55379123a8bd2bc457d9a5e9a0d34dd512b2bd2f59c6a5bec2a95f14(
+    arg1: jsii.Number,
+    arg2: builtins.str,
+    arg3: typing.Optional[datetime.datetime] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__26ecd0d4ea200acf388a8b91f17bfd3c09b6c7f8e0a84228b89c27ace672d0b1(
+    *,
+    field: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__72ca8c3c148afe2b76dc14b63b8e2baf0bbf28802add3f88490cb5d3792825fb(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ca8d417ddf787890441d6903718eebaf7fde3508b3466202724fdac3a17ba79b(
+    obj: IReturnsNumber,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__32a51b5d61d5ca58d33e8f6b9d9e1c4f16b39bf431a669250d4c290de0bbf46f(
+    builtins: builtins.str,
+    str: builtins.str,
+    *,
+    boolean_property: builtins.bool,
+    string_property: builtins.str,
+    struct_property: typing.Union[StructA, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c93d69c5c8307eec2d1c6e8d5f9892234fbdd24bb5cce3f5ea1e210276bc58c1(
+    *,
+    boolean_property: builtins.bool,
+    string_property: builtins.str,
+    struct_property: typing.Union[StructA, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ae63c91319764cabd02536ac5b03026eb3f4071497b2a04adf93ca02985507ae(
+    scope: _scope_jsii_calc_lib_c61f082f.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f6db465208dd616dc4f171643676a159b21fe5963ec9a3d1fd752e5cb291868d(
+    *,
+    foo: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__85c3ad65f24d8d5af99d7777a0379b793f45ac0e0e39714f279b8f2d58dbcfdb(
+    obj: ConstructorPassesThisOut,
+    dt: datetime.datetime,
+    ev: AllTypesEnum,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__edbbf85a7c4217635da7418d28aa61c4e11f7a0c1e9c960528ed4e7bee1ad541(
+    friendly: _scope_jsii_calc_lib_c61f082f.IFriendly,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__df4f41b4c003b9ba61f07f4d41a4059f167ea41c03ea29933966d2caeb831d8c(
+    base: _scope_jsii_calc_lib_c61f082f.NumericValue,
+    pow: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__235768085718ab33214221cff3145bb2a82c28916350f273995760a428a1aba3(
+    value: _scope_jsii_calc_lib_c61f082f.EnumFromScopedModule,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__100c679fa10c1938fc087475a1e5fcdf7c2cbff383b1c02b1d09471cb4f23123(
+    value: typing.Optional[_scope_jsii_calc_lib_c61f082f.EnumFromScopedModule],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__cf66d7b4f4a567aefacbafc24f61d33a942afde3d167676ed65ea82da95cd36e(
+    *,
+    string_prop: builtins.str,
+    nested_struct: typing.Optional[typing.Union[NestedStruct, typing.Dict[builtins.str, typing.Any]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6db501e892de783af62ff728e59cc3155afc51ddc2dff77cce61ffe698e2e1f3(
+    arg1: typing.Optional[jsii.Number] = None,
+    arg2: typing.Optional[builtins.str] = None,
+    arg3: typing.Optional[datetime.datetime] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5978f09aaa3317742377437d5735571f672119325c2b5d69f26153bae6764c85(
+    arg: typing.Any = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c894904fd4904d7e110da91df846a8ec0970051a274bba5ad95c2b7dc1125cc2(
+    arg1: jsii.Number,
+    arg2: builtins.str,
+    arg3: typing.Optional[datetime.datetime] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e7383b9a36a10b88815e6c310c7b13c611260f5ccb143b75dac114873643350d(
+    *,
+    deeper_required_prop: builtins.str,
+    deeper_optional_prop: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2ccde09a2986c421795069d44c46d9e2d7470609094b8b7177c6b154360f7435(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__76cbdc0bba36d674ab013a40d091c1f3ccb139f10e78844ebc868bfa5d707ef8(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1b795ca2a3052da38144d10d87f230e74bcfa497af1262580f53908be48f6710(
+    *,
+    property: builtins.str,
+    yet_anoter_one: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8c577a76d55e32f4b62a2a005d0c321bf9d0784b2f6cea5f10e297f3f79fc4bb(
+    readonly_string: builtins.str,
+    mutable_number: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__737be2f0376e64bd8c0980aee9fc6afd796bb4d0cb3415eab28d054f15881752(
+    value: typing.Optional[jsii.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4bbf1eebbce12768b1d2ef90968ffdbe749e42ce8bcdaf4c8750314d2160c5ea(
+    *,
+    readonly_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__cf00e16ec45ebcadc1f7003eb344ecf452096a12a1a76ff0e15fce1066d716d2(
+    value: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__69df39c5fc3367bba974a46518d9122ce067721f56037ef6e1faedf479222822(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c4597464b7867e98bf0052f7808e080b75874d088aeac980865a4fc19e47a6d1(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__748a4d0813e4a3ab750bd52215b9ff4dee315d39b160d47884780ea7c4b10daf(
+    value: Statics,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5d0ed37ae4b7f5bd294a768da342f4735c6636e0197883a5727e46ed81deec69(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__aa3b9a5342b6fe1366fac3279219c5bae15389881ddd050c544c1d0001853482(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c9e4f6413d6ce49f4a289256d84d0fa97f7abac1877fc8d49f80f4a7d83a4972(
+    *,
+    required_string: builtins.str,
+    optional_number: typing.Optional[jsii.Number] = None,
+    optional_string: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4d335a3a7bbc35ed76509a5e85466d6d29221efebdd6dd4de639ef040628f332(
+    *,
+    required_string: builtins.str,
+    optional_boolean: typing.Optional[builtins.bool] = None,
+    optional_struct_a: typing.Optional[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7eb7b6caeb33bbd3740ca0fc027022df9d4fade4a7d1943a334f2869ab44bd98(
+    *,
+    scope: builtins.str,
+    props: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e3587fc6359e7cd1adf0bb70ed66e1cd69faa462a530e07c8d25a96b942cb943(
+    _positional: jsii.Number,
+    *inputs: TopLevelStruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b60fd8dad9496da93546e0555f2f8a7a34711e7160c06dc64a47f095f1539d02(
+    _positional: jsii.Number,
+    *,
+    required: builtins.str,
+    second_level: typing.Union[jsii.Number, typing.Union[SecondLevelStruct, typing.Dict[builtins.str, typing.Any]]],
+    optional: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1c22dd35a08877498e4c2c0ed61e220c19d83da3b6a1e278dfcb7af4d76d2df8(
+    struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__bfb5d0235b42940b9a17c7bb3182f454c7652fdb031f8993719a701d42833623(
+    struct: typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e3e3d0b072ef214d95806fb0366dd1f4a92b97932f845c9364616c9348bce502(
+    which: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__06173422e8b2a410ef992bee26115592516245e72f1a99397919d18bfebc1259(
+    *,
+    union_property: typing.Sequence[typing.Mapping[builtins.str, typing.Union[typing.Union[StructA, typing.Dict[builtins.str, typing.Any]], typing.Union[StructB, typing.Dict[builtins.str, typing.Any]]]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9fac60639e71eb35a422d891e6b571b3ba2118da50de35e8ba784bbb73928be9(
+    *,
+    foo: StringEnum,
+    bar: typing.Optional[AllTypesEnum] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__21b11cdfe2d95237cdddef417a67936ff8529ea3cef4bd7e80fe498f1e27527d(
+    *,
+    default: builtins.str,
+    assert_: typing.Optional[builtins.str] = None,
+    result: typing.Optional[builtins.str] = None,
+    that: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e2e14d04b1a68f16d9aef0965aa4ffbc51af3cbd2d201ac6e236d861b10c2fbf(
+    value: typing.List[_scope_jsii_calc_lib_c61f082f.NumericValue],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__11e78aa6557af36be636eea7a1a9b1d6ebf38d63d876b270de65a5f23152b605(
+    *,
+    bar: jsii.Number,
+    id: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__46b91a4f1b85f01437aa8a6dda82c7c9e02f0b2ae5324f8c1591fa7ff74feaa0(
+    id_: jsii.Number,
+    *,
+    bar: jsii.Number,
+    id: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a961c6dee96c75a70470863d82c09136094c1d72d47aafe7f105c7733536dd4d(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f3d4d3109122672e8fa17c64fb60787d84a098ee0ee0857d4a10ffe5345a1908(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ba36c4cb32b9551fe1c3e91bd834b2e97f7ee93d0b5919acfb1c4fd3d6161295(
+    n: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7118412729d7ec6272cded791897b09f12ee70e1ca550853121f98ceb30ee0e7(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c361a6694d6564ff5c16af012cfaf94cac0a971928a1d0fb014c27f971287836(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d5d44f6e3395b0db421bab95a6dd7d1560538c63f136025c6b216ffb01eae179(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__64c8c65ae76fcafb4b6d28e75f8fd31efad60ab9e71d11cbd5877c28c45d8f70(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__52ea95020be0094da769c873214a182768aa2de47b1c4c3dff43f1226edfe281(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__21d6ffe465a7e42c257c8318bf2bee38ecbc6b1959e6e945e769e365afb3e55d(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__74359fdf4e6a6505a1c0bc4c2c687826dde0a7696de75fc39f9ed57d89137f96(
+    *,
+    required: builtins.str,
+    second_level: typing.Union[jsii.Number, typing.Union[SecondLevelStruct, typing.Dict[builtins.str, typing.Any]]],
+    optional: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e31f878fe14747887a58683a15ca9c8ab54ec35cd6e3a665ad70dd53deadb573(
+    operand: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__223de5294ccc50da976adb8794cb8556981e31d63a2c8b249f7dfbd9e2d99eac(
+    *,
+    bar: typing.Union[builtins.str, jsii.Number, AllTypes],
+    foo: typing.Optional[typing.Union[builtins.str, jsii.Number]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__aaaf822e80c6473bff9b1da58151a278cd846ae0614db9af97bc57ea6f899ce2(
+    delegate: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__73d1545891c65d400938add489402441cb083c61d214ad7a922b6417d3984732(
+    obj: IInterfaceWithProperties,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__60f3870a6dceb3773397b75ec3f3b664f38c2cc3d2f37dc055262663d12f41a8(
+    ext: IInterfaceWithPropertiesExtension,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__42edcb376aed0b6e6fec7d7df016bda9e3a31df0e47ecabb5465d1c84d16a414(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6d238d6a2f6e464c570c3176db3d78d62e0be9908b705705c8f6d7b6b2385c54(
+    method: VariadicMethod,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__43f32dfb73f1a7fe9c86c00bbc381391db4812c13b5b72363ddcfcd57638c368(
+    *values: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a33769c23320f9f6bce3e3a70c594135cf44ca5c9c6d1de1cae8cc62a99d49e9(
+    *prefix: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1c18f2c7d91dcdc13843ff1637ed95a1f1c1ed99384d6276ee493b0ca579b4a4(
+    first: jsii.Number,
+    *others: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f18ff2aa5c744d99cc2b37e705d6ed44823660f714c20539c148c9e34e123752(
+    *union: typing.Union[StructA, StructB],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__01944feab2feb5a9fdf3d356f62de139685f520d3bb3a38ddc5c42d0b03963fe(
+    value: typing.List[typing.Union[StructA, StructB]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5efa2ef42e261d5c38c59d5e216e587cb3005bbbb5b4a62e926087ee58478a36(
+    index: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ca8f2360b0292d0b5329ac52818673aece7fb01cf2f09567e60ff65b7728c9cc(
+    index: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5bc99fd66b59152ee7799cf716c91bec428d7091eb33ece69057f9ca9b9fdb19(
+    count: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__58451fb4813d1aa8877a55de41f1ef8bd30300048337edb2bcf16985abbb6f45(
+    count: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7ac4c09636b11fefb0a54fbd52b88fc2b4c5c356eb07189a0d2545601f3bef9c(
+    count: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__01fcbc911a24b1fa352275e1273526114db562d2c278b742181eba6e8cb11ad4(
+    private_field: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__af1f574dee5c4eb581961518ccf32b4060094ed2f9b7e60bece1ed48e3fc45a1(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c0e59e6ea7e78215051bf4fe6b69de179aefb4116a344decdfaab4b6b15189b8(
+    lhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+    rhs: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__fa23831ecd0b539d7689616a0557240dc1a45f924fafe58c0d5f0ac464eecf94(
+    value: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__84a0b7e93c52a4977e9726c1186b64f57ff35c59c5bc0e7250da1d3236e70208(
+    *,
+    foo: builtins.str,
+    bar: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__720d53a768711730e792d129fcff6272627608d1d3942f42e3010e61a3463b31(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5236e267a6763b672404dac13a3d5e50c03eb03d35fe2c18cbe7f649933301f1(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1bd3b16d1aaf127e7610a230095bced32c4c3ef1cadc73f6b24c76b3ebffdd8e(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4e685d8185af60a2f5c9bcffe812224568fe893228304e510b4d989f92c19b90(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6499a25aa5ac6723e26c4c716dd2d62a1f9ecd75ae2a476d3213fa5fe8792a1d(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5da75e226d085b0daac7742a86525ea697c77a044896ce80d48677f5fadb2d57(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__538f9410afd2d028ca599a233896016121b326bd90d69693e949aff75d72caf3(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ba8bf3471001981f03d1ad5b84a1b0a4a4d7d556c72734d25d96637a60ad2477(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__71399b17d07223b2b83f0d7b33d5172c49eb3d0cf3fe38d6059d4c9b7f471113(
+    read_only_string: builtins.str,
+    read_write_string: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e308499c7b9268c91ee3dc9e4a9c975efdfaa0cd72bd877383c6c64e8f2768d0(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__148cd823b5de47723c8a76d0553f3ff6c880ba8ecec14b9a86bd89025a18f4d3(
+    property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__e7aa949631662ae6f6ab2804e4a231fa264a1c879d86efa8267e53158c50e647(
+    operand: _scope_jsii_calc_lib_c61f082f.NumericValue,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2f90423a63bd0fc04016022e622b4bf01d35f365e38b15153d0a4d6fa014ee5b(
+    id: jsii.Number,
+    default_bar: typing.Optional[jsii.Number] = None,
+    props: typing.Optional[typing.Union[SupportsNiceJavaBuilderProps, typing.Dict[builtins.str, typing.Any]]] = None,
+    *rest: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/anonymous/__init__.py.diff 1`] = `
--- python/src/jsii_calc/anonymous/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/anonymous/__init__.py	--runtime-type-checking
@@ -54,31 +54,58 @@
     @builtins.classmethod
     def consume(cls, option: typing.Union[IOptionA, IOptionB]) -> builtins.str:
         '''
         :param option: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__132536bffc9129421b4ae0a6539d0bbfdc1c52c3de007c4546d2f2626ba8c31e)
+            check_type(argname="argument option", value=option, expected_type=type_hints["option"])
         return typing.cast(builtins.str, jsii.sinvoke(cls, "consume", [option]))
 
     @jsii.member(jsii_name="privideAsAny")
     @builtins.classmethod
     def privide_as_any(cls, which: builtins.str) -> typing.Any:
         '''
         :param which: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d461fff988e22833dcf37c5193332d48b9e455d605f2a1e708ab0d111a1659c7)
+            check_type(argname="argument which", value=which, expected_type=type_hints["which"])
         return typing.cast(typing.Any, jsii.sinvoke(cls, "privideAsAny", [which]))
 
     @jsii.member(jsii_name="provide")
     @builtins.classmethod
     def provide(cls, which: builtins.str) -> typing.Union[IOptionA, IOptionB]:
         '''
         :param which: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f841b966136dfd090628b12290eedd178724cc8f332e05aba2b3a035f07dae50)
+            check_type(argname="argument which", value=which, expected_type=type_hints["which"])
         return typing.cast(typing.Union[IOptionA, IOptionB], jsii.sinvoke(cls, "provide", [which]))
 
 
 __all__ = [
     "IOptionA",
     "IOptionB",
     "UseOptions",
 ]
 
 publication.publish()
+
+def _typecheckingstub__132536bffc9129421b4ae0a6539d0bbfdc1c52c3de007c4546d2f2626ba8c31e(
+    option: typing.Union[IOptionA, IOptionB],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d461fff988e22833dcf37c5193332d48b9e455d605f2a1e708ab0d111a1659c7(
+    which: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f841b966136dfd090628b12290eedd178724cc8f332e05aba2b3a035f07dae50(
+    which: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/cdk16625/__init__.py.diff 1`] = `
--- python/src/jsii_calc/cdk16625/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/cdk16625/__init__.py	--runtime-type-checking
@@ -42,10 +42,13 @@
     def _unwrap(self, gen: _IRandomNumberGenerator_9643a8b9) -> jsii.Number:
         '''Implement this functin to return \`\`gen.next()\`\`. It is extremely important that the \`\`donotimport\`\` submodule is NEVER explicitly loaded in the testing application (otherwise this test is void).
 
         :param gen: a VERY pseudo random number generator.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__92f621cedc18f68d281c38191023e89bba6348836db623bc5d780630324b992b)
+            check_type(argname="argument gen", value=gen, expected_type=type_hints["gen"])
         return typing.cast(jsii.Number, jsii.invoke(self, "unwrap", [gen]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
 typing.cast(typing.Any, Cdk16625).__jsii_proxy_class__ = lambda : _Cdk16625Proxy
 
@@ -57,5 +60,11 @@
 
 publication.publish()
 
 # Loading modules to ensure their types are registered with the jsii runtime library
 from . import donotimport
+
+def _typecheckingstub__92f621cedc18f68d281c38191023e89bba6348836db623bc5d780630324b992b(
+    gen: _IRandomNumberGenerator_9643a8b9,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/cdk16625/donotimport/__init__.py.diff 1`] = `
--- python/src/jsii_calc/cdk16625/donotimport/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/cdk16625/donotimport/__init__.py	--runtime-type-checking
@@ -31,10 +31,13 @@
 
     def __init__(self, value: jsii.Number) -> None:
         '''
         :param value: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e2659669d69691129e05836f0722a48449fe2efe197706d9d59c10c141470a4b)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.create(self.__class__, self, [value])
 
     @jsii.member(jsii_name="next")
     def next(self) -> jsii.Number:
         '''Not quite random, but it'll do.
@@ -47,5 +50,11 @@
 __all__ = [
     "UnimportedSubmoduleType",
 ]
 
 publication.publish()
+
+def _typecheckingstub__e2659669d69691129e05836f0722a48449fe2efe197706d9d59c10c141470a4b(
+    value: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/cdk22369/__init__.py.diff 1`] = `
--- python/src/jsii_calc/cdk22369/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/cdk22369/__init__.py	--runtime-type-checking
@@ -31,10 +31,13 @@
 class AcceptsPathProps:
     def __init__(self, *, source_path: builtins.str) -> None:
         '''
         :param source_path: A path that doesn't exist.
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5a067c851774273f33badeac9c167720ebde25d4301ab096dec54b2e615dc8a4)
+            check_type(argname="argument source_path", value=source_path, expected_type=type_hints["source_path"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "source_path": source_path,
         }
 
     @builtins.property
@@ -60,5 +63,12 @@
     "AcceptsPath",
     "AcceptsPathProps",
 ]
 
 publication.publish()
+
+def _typecheckingstub__5a067c851774273f33badeac9c167720ebde25d4301ab096dec54b2e615dc8a4(
+    *,
+    source_path: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/composition/__init__.py.diff 1`] = `
--- python/src/jsii_calc/composition/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/composition/__init__.py	--runtime-type-checking
@@ -52,30 +52,39 @@
         '''A set of postfixes to include in a decorated .toString().'''
         return typing.cast(typing.List[builtins.str], jsii.get(self, "decorationPostfixes"))
 
     @decoration_postfixes.setter
     def decoration_postfixes(self, value: typing.List[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f546e09b5b6c86dfee3f946eff8913ea8feb763a4156fb8aad45ecc179c63e62)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "decorationPostfixes", value)
 
     @builtins.property
     @jsii.member(jsii_name="decorationPrefixes")
     def decoration_prefixes(self) -> typing.List[builtins.str]:
         '''A set of prefixes to include in a decorated .toString().'''
         return typing.cast(typing.List[builtins.str], jsii.get(self, "decorationPrefixes"))
 
     @decoration_prefixes.setter
     def decoration_prefixes(self, value: typing.List[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__abce94053402e9d1fcf1605226fa2c285e1340ec8219cfd1061f917e876a9051)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "decorationPrefixes", value)
 
     @builtins.property
     @jsii.member(jsii_name="stringStyle")
     def string_style(self) -> "CompositeOperation.CompositionStringStyle":
         '''The .toString() style.'''
         return typing.cast("CompositeOperation.CompositionStringStyle", jsii.get(self, "stringStyle"))
 
     @string_style.setter
     def string_style(self, value: "CompositeOperation.CompositionStringStyle") -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9dbbc353e0ea03d68edfa3977eadeb5446b56a89ffb921cb8406ba9fca0805b0)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "stringStyle", value)
 
     @jsii.enum(
         jsii_type="jsii-calc.composition.CompositeOperation.CompositionStringStyle"
     )
@@ -108,5 +117,23 @@
 __all__ = [
     "CompositeOperation",
 ]
 
 publication.publish()
+
+def _typecheckingstub__f546e09b5b6c86dfee3f946eff8913ea8feb763a4156fb8aad45ecc179c63e62(
+    value: typing.List[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__abce94053402e9d1fcf1605226fa2c285e1340ec8219cfd1061f917e876a9051(
+    value: typing.List[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9dbbc353e0ea03d68edfa3977eadeb5446b56a89ffb921cb8406ba9fca0805b0(
+    value: CompositeOperation.CompositionStringStyle,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/derived_class_has_no_properties/__init__.py.diff 1`] = `
--- python/src/jsii_calc/derived_class_has_no_properties/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/derived_class_has_no_properties/__init__.py	--runtime-type-checking
@@ -25,10 +25,13 @@
     def prop(self) -> builtins.str:
         return typing.cast(builtins.str, jsii.get(self, "prop"))
 
     @prop.setter
     def prop(self, value: builtins.str) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4b95d284137921c7cbf29a9e3a15da0a5cf9dda87efad87aa9ed601662f00b2c)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "prop", value)
 
 
 class Derived(
     Base,
@@ -43,5 +46,11 @@
     "Base",
     "Derived",
 ]
 
 publication.publish()
+
+def _typecheckingstub__4b95d284137921c7cbf29a9e3a15da0a5cf9dda87efad87aa9ed601662f00b2c(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/homonymous_forward_references/bar/__init__.py.diff 1`] = `
--- python/src/jsii_calc/homonymous_forward_references/bar/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/homonymous_forward_references/bar/__init__.py	--runtime-type-checking
@@ -46,10 +46,13 @@
         '''
         :param homonymous: 
         '''
         if isinstance(homonymous, dict):
             homonymous = Homonymous(**homonymous)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a201923592702b83e439b8af921b7eae6f1b86b0eeeffb6c2b506d66a57d4c3a)
+            check_type(argname="argument homonymous", value=homonymous, expected_type=type_hints["homonymous"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "homonymous": homonymous,
         }
 
     @builtins.property
@@ -78,10 +81,13 @@
 class Homonymous:
     def __init__(self, *, numeric_property: jsii.Number) -> None:
         '''
         :param numeric_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b7814834f12f5cbacf39dd7bdb11da208ae4c429011eff511d21e10d621cf9d5)
+            check_type(argname="argument numeric_property", value=numeric_property, expected_type=type_hints["numeric_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "numeric_property": numeric_property,
         }
 
     @builtins.property
@@ -107,5 +113,19 @@
     "ConsumerProps",
     "Homonymous",
 ]
 
 publication.publish()
+
+def _typecheckingstub__a201923592702b83e439b8af921b7eae6f1b86b0eeeffb6c2b506d66a57d4c3a(
+    *,
+    homonymous: typing.Union[Homonymous, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b7814834f12f5cbacf39dd7bdb11da208ae4c429011eff511d21e10d621cf9d5(
+    *,
+    numeric_property: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/homonymous_forward_references/foo/__init__.py.diff 1`] = `
--- python/src/jsii_calc/homonymous_forward_references/foo/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/homonymous_forward_references/foo/__init__.py	--runtime-type-checking
@@ -46,10 +46,13 @@
         '''
         :param homonymous: 
         '''
         if isinstance(homonymous, dict):
             homonymous = Homonymous(**homonymous)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__56bad81fb024ccb6a97af9b4edcb748a4d5e34e81491c4222bb761bc0e5890b6)
+            check_type(argname="argument homonymous", value=homonymous, expected_type=type_hints["homonymous"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "homonymous": homonymous,
         }
 
     @builtins.property
@@ -78,10 +81,13 @@
 class Homonymous:
     def __init__(self, *, string_property: builtins.str) -> None:
         '''
         :param string_property: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__57e873ae26cc34d45d619900518aa9fbc9f512fa9ca964387f9bcd933e461123)
+            check_type(argname="argument string_property", value=string_property, expected_type=type_hints["string_property"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "string_property": string_property,
         }
 
     @builtins.property
@@ -107,5 +113,19 @@
     "ConsumerProps",
     "Homonymous",
 ]
 
 publication.publish()
+
+def _typecheckingstub__56bad81fb024ccb6a97af9b4edcb748a4d5e34e81491c4222bb761bc0e5890b6(
+    *,
+    homonymous: typing.Union[Homonymous, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__57e873ae26cc34d45d619900518aa9fbc9f512fa9ca964387f9bcd933e461123(
+    *,
+    string_property: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/interface_in_namespace_includes_classes/__init__.py.diff 1`] = `
--- python/src/jsii_calc/interface_in_namespace_includes_classes/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/interface_in_namespace_includes_classes/__init__.py	--runtime-type-checking
@@ -25,10 +25,13 @@
     def bar(self) -> typing.Optional[builtins.str]:
         return typing.cast(typing.Optional[builtins.str], jsii.get(self, "bar"))
 
     @bar.setter
     def bar(self, value: typing.Optional[builtins.str]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3319085b675e83451882dd81f7704e88da2e392266f9d5188ecb22725f3f71bb)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "bar", value)
 
 
 @jsii.data_type(
     jsii_type="jsii-calc.InterfaceInNamespaceIncludesClasses.Hello",
@@ -38,10 +41,13 @@
 class Hello:
     def __init__(self, *, foo: jsii.Number) -> None:
         '''
         :param foo: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5c05b45db7e873d4164cc7295b5d2800ba4bed1813d4a2d57aad8cedb292186d)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
 
     @builtins.property
@@ -66,5 +72,18 @@
     "Foo",
     "Hello",
 ]
 
 publication.publish()
+
+def _typecheckingstub__3319085b675e83451882dd81f7704e88da2e392266f9d5188ecb22725f3f71bb(
+    value: typing.Optional[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5c05b45db7e873d4164cc7295b5d2800ba4bed1813d4a2d57aad8cedb292186d(
+    *,
+    foo: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/interface_in_namespace_only_interface/__init__.py.diff 1`] = `
--- python/src/jsii_calc/interface_in_namespace_only_interface/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/interface_in_namespace_only_interface/__init__.py	--runtime-type-checking
@@ -21,10 +21,13 @@
 class Hello:
     def __init__(self, *, foo: jsii.Number) -> None:
         '''
         :param foo: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cc86cfd2ea53d0ae81d6d80ed07db33f3ca7b140e37166ba1d572a8ed2a78d2c)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
 
     @builtins.property
@@ -48,5 +51,12 @@
 __all__ = [
     "Hello",
 ]
 
 publication.publish()
+
+def _typecheckingstub__cc86cfd2ea53d0ae81d6d80ed07db33f3ca7b140e37166ba1d572a8ed2a78d2c(
+    *,
+    foo: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/jsii3656/__init__.py.diff 1`] = `
--- python/src/jsii_calc/jsii3656/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/jsii3656/__init__.py	--runtime-type-checking
@@ -27,10 +27,14 @@
     ) -> None:
         '''
         :param name: 
         :param count: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9754f0ac616c8a4339db020e52a796e65577c9909ed5e25d0c696417da04377c)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "name": name,
         }
         if count is not None:
             self._values["count"] = count
@@ -69,10 +73,13 @@
     @builtins.classmethod
     def call_abstract(cls, receiver: "OverrideMe") -> builtins.bool:
         '''
         :param receiver: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__37c9a298f20a606212f074bd150ba5bc37e38a4cc1f9b2672facafd80734afc1)
+            check_type(argname="argument receiver", value=receiver, expected_type=type_hints["receiver"])
         return typing.cast(builtins.bool, jsii.sinvoke(cls, "callAbstract", [receiver]))
 
     @jsii.member(jsii_name="implementMe")
     @abc.abstractmethod
     def implement_me(
@@ -112,5 +119,19 @@
     "ImplementMeOpts",
     "OverrideMe",
 ]
 
 publication.publish()
+
+def _typecheckingstub__9754f0ac616c8a4339db020e52a796e65577c9909ed5e25d0c696417da04377c(
+    *,
+    name: builtins.str,
+    count: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__37c9a298f20a606212f074bd150ba5bc37e38a4cc1f9b2672facafd80734afc1(
+    receiver: OverrideMe,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2530/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2530/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2530/__init__.py	--runtime-type-checking
@@ -21,28 +21,55 @@
 
     def __init__(self, _: jsii.Number) -> None:
         '''
         :param _: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d62f783e4108a6327009d506f8ae7f5aca2734de07314ffd120f24d3e918f697)
+            check_type(argname="argument _", value=_, expected_type=type_hints["_"])
         jsii.create(self.__class__, self, [_])
 
     @jsii.member(jsii_name="bar")
     @builtins.classmethod
     def bar(cls, _: builtins.bool) -> None:
         '''
         :param _: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f35c91dda02ec538c4e5ee9182aaa01ba14f837c78951f48bb0abd1a866a4d5c)
+            check_type(argname="argument _", value=_, expected_type=type_hints["_"])
         return typing.cast(None, jsii.sinvoke(cls, "bar", [_]))
 
     @jsii.member(jsii_name="foo")
     def foo(self, _: builtins.str) -> None:
         '''
         :param _: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dd74e61269fd21c6a0b0983199f27c5d4df8a4447ff77e770890f58f6c9b6969)
+            check_type(argname="argument _", value=_, expected_type=type_hints["_"])
         return typing.cast(None, jsii.invoke(self, "foo", [_]))
 
 
 __all__ = [
     "MyClass",
 ]
 
 publication.publish()
+
+def _typecheckingstub__d62f783e4108a6327009d506f8ae7f5aca2734de07314ffd120f24d3e918f697(
+    _: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f35c91dda02ec538c4e5ee9182aaa01ba14f837c78951f48bb0abd1a866a4d5c(
+    _: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dd74e61269fd21c6a0b0983199f27c5d4df8a4447ff77e770890f58f6c9b6969(
+    _: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2647/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2647/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2647/__init__.py	--runtime-type-checking
@@ -31,10 +31,13 @@
         '''
         :param very: -
 
         :stability: deprecated
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3b33906576528227344dbb0f079876c5dccd08a32f3dbaa0acdc3f444c5fe448)
+            check_type(argname="argument very", value=very, expected_type=type_hints["very"])
         jsii.create(self.__class__, self, [very])
 
     @jsii.member(jsii_name="hello")
     def hello(self) -> builtins.str:
         '''Say hello!'''
@@ -48,5 +51,11 @@
 __all__ = [
     "ExtendAndImplement",
 ]
 
 publication.publish()
+
+def _typecheckingstub__3b33906576528227344dbb0f079876c5dccd08a32f3dbaa0acdc3f444c5fe448(
+    very: _scope_jsii_calc_base_of_base_49fa37fe.Very,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2689/methods/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2689/methods/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2689/methods/__init__.py	--runtime-type-checking
@@ -29,23 +29,41 @@
         _bar: typing.Mapping[builtins.str, typing.Union[_scope_jsii_calc_base_734f0262.BaseProps, typing.Dict[builtins.str, typing.Any]]],
     ) -> None:
         '''
         :param _bar: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cfbe1bc46497cbad551fc80c4d304742daa30493dee8c65b7119cafdeb06e9af)
+            check_type(argname="argument _bar", value=_bar, expected_type=type_hints["_bar"])
         return typing.cast(None, jsii.invoke(self, "bar", [_bar]))
 
     @jsii.member(jsii_name="foo")
     def foo(
         self,
         _values: typing.Sequence[_scope_jsii_calc_lib_c61f082f.Number],
     ) -> None:
         '''
         :param _values: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__40045f17e26efacbabd3e103d903497e18761a611301d901fcdebc3cf8baaced)
+            check_type(argname="argument _values", value=_values, expected_type=type_hints["_values"])
         return typing.cast(None, jsii.invoke(self, "foo", [_values]))
 
 
 __all__ = [
     "MyClass",
 ]
 
 publication.publish()
+
+def _typecheckingstub__cfbe1bc46497cbad551fc80c4d304742daa30493dee8c65b7119cafdeb06e9af(
+    _bar: typing.Mapping[builtins.str, typing.Union[_scope_jsii_calc_base_734f0262.BaseProps, typing.Dict[builtins.str, typing.Any]]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__40045f17e26efacbabd3e103d903497e18761a611301d901fcdebc3cf8baaced(
+    _values: typing.Sequence[_scope_jsii_calc_lib_c61f082f.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2689/structs/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2689/structs/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2689/structs/__init__.py	--runtime-type-checking
@@ -30,10 +30,14 @@
     ) -> None:
         '''
         :param base_map: 
         :param numbers: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__71fe496245d27f33a2ded522fdf47757e7fb41b578fd3ec479cd5b45534588fc)
+            check_type(argname="argument base_map", value=base_map, expected_type=type_hints["base_map"])
+            check_type(argname="argument numbers", value=numbers, expected_type=type_hints["numbers"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "base_map": base_map,
             "numbers": numbers,
         }
 
@@ -66,5 +70,13 @@
 __all__ = [
     "MyStruct",
 ]
 
 publication.publish()
+
+def _typecheckingstub__71fe496245d27f33a2ded522fdf47757e7fb41b578fd3ec479cd5b45534588fc(
+    *,
+    base_map: typing.Mapping[builtins.str, typing.Union[_scope_jsii_calc_base_734f0262.BaseProps, typing.Dict[builtins.str, typing.Any]]],
+    numbers: typing.Sequence[_scope_jsii_calc_lib_c61f082f.Number],
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2692/submodule1/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2692/submodule1/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2692/submodule1/__init__.py	--runtime-type-checking
@@ -21,10 +21,13 @@
 class Bar:
     def __init__(self, *, bar1: builtins.str) -> None:
         '''
         :param bar1: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6602c05b71ef2e77c650dd283c33ba4543f756dbbca5d1c31752ee29f836b1f5)
+            check_type(argname="argument bar1", value=bar1, expected_type=type_hints["bar1"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bar1": bar1,
         }
 
     @builtins.property
@@ -48,5 +51,12 @@
 __all__ = [
     "Bar",
 ]
 
 publication.publish()
+
+def _typecheckingstub__6602c05b71ef2e77c650dd283c33ba4543f756dbbca5d1c31752ee29f836b1f5(
+    *,
+    bar1: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/module2692/submodule2/__init__.py.diff 1`] = `
--- python/src/jsii_calc/module2692/submodule2/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/module2692/submodule2/__init__.py	--runtime-type-checking
@@ -23,10 +23,13 @@
 class Bar:
     def __init__(self, *, bar2: builtins.str) -> None:
         '''
         :param bar2: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d9a43a9ecad39319deef77fa38822e65c584450447849fb04c34b767a8c0881d)
+            check_type(argname="argument bar2", value=bar2, expected_type=type_hints["bar2"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bar2": bar2,
         }
 
     @builtins.property
@@ -63,10 +66,15 @@
         '''
         :param bar2: 
         :param bar1: 
         :param foo2: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__717272f96a16c5ea04b9406364f96f18d1c2b16b183b81ef7bae856ebd371a43)
+            check_type(argname="argument bar2", value=bar2, expected_type=type_hints["bar2"])
+            check_type(argname="argument bar1", value=bar1, expected_type=type_hints["bar1"])
+            check_type(argname="argument foo2", value=foo2, expected_type=type_hints["foo2"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bar2": bar2,
             "bar1": bar1,
             "foo2": foo2,
         }
@@ -105,5 +113,21 @@
     "Bar",
     "Foo",
 ]
 
 publication.publish()
+
+def _typecheckingstub__d9a43a9ecad39319deef77fa38822e65c584450447849fb04c34b767a8c0881d(
+    *,
+    bar2: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__717272f96a16c5ea04b9406364f96f18d1c2b16b183b81ef7bae856ebd371a43(
+    *,
+    bar2: builtins.str,
+    bar1: builtins.str,
+    foo2: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/python_self/__init__.py.diff 1`] = `
--- python/src/jsii_calc/python_self/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/python_self/__init__.py	--runtime-type-checking
@@ -19,17 +19,23 @@
 ):
     def __init__(self_, self: builtins.str) -> None:
         '''
         :param self: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5cc662603963e69f50f446fe7bf40b3f3ccf17842ed59562f45f4eb63848155b)
+            check_type(argname="argument self", value=self, expected_type=type_hints["self"])
         jsii.create(self_.__class__, self_, [self])
 
     @jsii.member(jsii_name="method")
     def method(self_, self: jsii.Number) -> builtins.str:
         '''
         :param self: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7085240966e9682f4d0598c65f482b932ae1281420f2cead92f0036488d061d4)
+            check_type(argname="argument self", value=self, expected_type=type_hints["self"])
         return typing.cast(builtins.str, jsii.invoke(self_, "method", [self]))
 
     @builtins.property
     @jsii.member(jsii_name="self")
     def self(self) -> builtins.str:
@@ -70,10 +76,13 @@
     @jsii.member(jsii_name="method")
     def method(self_, self: jsii.Number) -> builtins.str:
         '''
         :param self: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8e4a50df1f139ac6d917c0954b0b6346aeeb47f16abae33b345a5aa2aa02fc99)
+            check_type(argname="argument self", value=self, expected_type=type_hints["self"])
         return typing.cast(builtins.str, jsii.invoke(self_, "method", [self]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
 typing.cast(typing.Any, IInterfaceWithSelf).__jsii_proxy_class__ = lambda : _IInterfaceWithSelfProxy
 
@@ -86,10 +95,13 @@
 class StructWithSelf:
     def __init__(self_, *, self: builtins.str) -> None:
         '''
         :param self: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__796022ef7b07de2b3997ff905b7451854b30a5e8e06145e4cc31e88f0ea8b0d0)
+            check_type(argname="argument self", value=self, expected_type=type_hints["self"])
         self_._values: typing.Dict[builtins.str, typing.Any] = {
             "self": self,
         }
 
     @builtins.property
@@ -116,5 +128,30 @@
     "IInterfaceWithSelf",
     "StructWithSelf",
 ]
 
 publication.publish()
+
+def _typecheckingstub__5cc662603963e69f50f446fe7bf40b3f3ccf17842ed59562f45f4eb63848155b(
+    self: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7085240966e9682f4d0598c65f482b932ae1281420f2cead92f0036488d061d4(
+    self: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8e4a50df1f139ac6d917c0954b0b6346aeeb47f16abae33b345a5aa2aa02fc99(
+    self: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__796022ef7b07de2b3997ff905b7451854b30a5e8e06145e4cc31e88f0ea8b0d0(
+    *,
+    self: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/submodule/__init__.py.diff 1`] = `
--- python/src/jsii_calc/submodule/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/submodule/__init__.py	--runtime-type-checking
@@ -39,10 +39,13 @@
 
         :param foo: 
 
         :see: https://github.com/aws/jsii/issues/2637
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a44c39bd2002b354344d30dcb1ae0e2dc7ef8f604c2d31c61616cbbfc6a6fc40)
+            check_type(argname="argument foo", value=foo, expected_type=type_hints["foo"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "foo": foo,
         }
 
     @builtins.property
@@ -107,10 +110,13 @@
     def all_types(self) -> typing.Optional[_AllTypes_b08307c5]:
         return typing.cast(typing.Optional[_AllTypes_b08307c5], jsii.get(self, "allTypes"))
 
     @all_types.setter
     def all_types(self, value: typing.Optional[_AllTypes_b08307c5]) -> None:
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bfa98c91ee81ff3f0ca8bdba51d8e53f57e5260e9d6071534e9caa5ba2ffaed1)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         jsii.set(self, "allTypes", value)
 
 
 __all__ = [
     "Default",
@@ -130,5 +136,18 @@
 from . import child
 from . import isolated
 from . import nested_submodule
 from . import param
 from . import returnsparam
+
+def _typecheckingstub__a44c39bd2002b354344d30dcb1ae0e2dc7ef8f604c2d31c61616cbbfc6a6fc40(
+    *,
+    foo: jsii.Number,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__bfa98c91ee81ff3f0ca8bdba51d8e53f57e5260e9d6071534e9caa5ba2ffaed1(
+    value: typing.Optional[_AllTypes_b08307c5],
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/submodule/back_references/__init__.py.diff 1`] = `
--- python/src/jsii_calc/submodule/back_references/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/submodule/back_references/__init__.py	--runtime-type-checking
@@ -23,10 +23,13 @@
 class MyClassReference:
     def __init__(self, *, reference: _MyClass_a2fdc0b6) -> None:
         '''
         :param reference: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e7f53d1efa418d6ee29ababd1c2660c1d3d9a5d3de3ad874b2d0cd7c6481139b)
+            check_type(argname="argument reference", value=reference, expected_type=type_hints["reference"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "reference": reference,
         }
 
     @builtins.property
@@ -50,5 +53,12 @@
 __all__ = [
     "MyClassReference",
 ]
 
 publication.publish()
+
+def _typecheckingstub__e7f53d1efa418d6ee29ababd1c2660c1d3d9a5d3de3ad874b2d0cd7c6481139b(
+    *,
+    reference: _MyClass_a2fdc0b6,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/submodule/child/__init__.py.diff 1`] = `
--- python/src/jsii_calc/submodule/child/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/submodule/child/__init__.py	--runtime-type-checking
@@ -73,10 +73,13 @@
 class SomeStruct:
     def __init__(self, *, prop: SomeEnum) -> None:
         '''
         :param prop: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ce6e4bc4b6c503e757ba9e0640368ea37840d2ca58311e6ec8b98cdcda077f48)
+            check_type(argname="argument prop", value=prop, expected_type=type_hints["prop"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "prop": prop,
         }
 
     @builtins.property
@@ -105,10 +108,13 @@
 class Structure:
     def __init__(self, *, bool: builtins.bool) -> None:
         '''
         :param bool: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f4dc81f7243c5c317d71ab682231a51bf3c3a189d9be68c17b8d41246c0abef5)
+            check_type(argname="argument bool", value=bool, expected_type=type_hints["bool"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "bool": bool,
         }
 
     @builtins.property
@@ -143,10 +149,14 @@
     ) -> None:
         '''
         :param prop: 
         :param extra: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b3b6b38208a14cadd94ba787e4091f753debb361ad5dd2ee9d037908f5677d8b)
+            check_type(argname="argument prop", value=prop, expected_type=type_hints["prop"])
+            check_type(argname="argument extra", value=extra, expected_type=type_hints["extra"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "prop": prop,
         }
         if extra is not None:
             self._values["extra"] = extra
@@ -184,5 +194,27 @@
     "SomeStruct",
     "Structure",
 ]
 
 publication.publish()
+
+def _typecheckingstub__ce6e4bc4b6c503e757ba9e0640368ea37840d2ca58311e6ec8b98cdcda077f48(
+    *,
+    prop: SomeEnum,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f4dc81f7243c5c317d71ab682231a51bf3c3a189d9be68c17b8d41246c0abef5(
+    *,
+    bool: builtins.bool,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b3b6b38208a14cadd94ba787e4091f753debb361ad5dd2ee9d037908f5677d8b(
+    *,
+    prop: SomeEnum,
+    extra: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/submodule/param/__init__.py.diff 1`] = `
--- python/src/jsii_calc/submodule/param/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/submodule/param/__init__.py	--runtime-type-checking
@@ -21,10 +21,13 @@
 class SpecialParameter:
     def __init__(self, *, value: builtins.str) -> None:
         '''
         :param value: 
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__25c6f5775c01f503690c503a264eb256af186a94c0c65bd43d6a11942ff54b1c)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
             "value": value,
         }
 
     @builtins.property
@@ -48,5 +51,12 @@
 __all__ = [
     "SpecialParameter",
 ]
 
 publication.publish()
+
+def _typecheckingstub__25c6f5775c01f503690c503a264eb256af186a94c0c65bd43d6a11942ff54b1c(
+    *,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
`;

exports[`Generated code for "jsii-calc": <runtime-type-check-diff>/python/src/jsii_calc/union/__init__.py.diff 1`] = `
--- python/src/jsii_calc/union/__init__.py	--no-runtime-type-checking
+++ python/src/jsii_calc/union/__init__.py	--runtime-type-checking
@@ -23,10 +23,13 @@
         param: typing.Union["IResolvable", "Resolvable", _scope_jsii_calc_lib_c61f082f.IFriendly],
     ) -> None:
         '''
         :param param: -
         '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__62dfa3c0a0a719fea295807df31fd40fd66b0e76cf44d9f742ffb421f8e4ca77)
+            check_type(argname="argument param", value=param, expected_type=type_hints["param"])
         return typing.cast(None, jsii.sinvoke(cls, "unionType", [param]))
 
 
 @jsii.interface(jsii_type="jsii-calc.union.IResolvable")
 class IResolvable(typing_extensions.Protocol):
@@ -58,5 +61,11 @@
     "IResolvable",
     "Resolvable",
 ]
 
 publication.publish()
+
+def _typecheckingstub__62dfa3c0a0a719fea295807df31fd40fd66b0e76cf44d9f742ffb421f8e4ca77(
+    param: typing.Union[IResolvable, Resolvable, _scope_jsii_calc_lib_c61f082f.IFriendly],
+) -> None:
+    """Type checking stubs"""
+    pass
`;
